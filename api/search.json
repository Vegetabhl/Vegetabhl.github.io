[{"id":"5fc3c8705ea835b2bb6930af6ce60158","title":"Winning 住院病历","content":"住院病历1 住院病历组成\n2 会诊申请流程\n会诊申请科室填写会诊申请一&gt;会诊接收后答复一&gt;会诊接收科室填写会诊反馈一&gt;会诊申请科室反馈一&gt;完成\n\n会诊撤销流程正好按顺序反过来\n\n\n3 病历的审核、撤销\n下级医师提交病历后，上级医师可以进行审核。审核通过后如果下级医师又想修改，需要上级医师先撤销审核。上级医师没审核的话可以直接撤销。\n痕迹可以看到下级医师提交后所作的操作\n\n\n4 病历的操作记录查看、历史病历查看\n病历上右键属性查看操作记录，很实用的功能。比如其他医师发现病历是灰色图标无法修改，就可以看下是不是其他医师创建的，是不是还没有提交。\n\n下方第二张图这里可以看历史病历\n\n\n\n\n5 病历归档流程、撤销归档流程\n病历归档针对的是出院患者，需要科室手动申请归档、或者到期也会自动归档。\n\n撤销归档需要科室申请、科主任、医务科、病案室依次审核通过。(三级审核)\n\n\n\n6 病历借阅\n病历借阅针对的归档病历(出院患者)，需要科室申请一&gt;管理科室审批一&gt;借阅一&gt;到期会自动回收\n\n\n7 质控1.科室环节质控\n\n\n\n质控评分这里是需要根据文件手动维护需要的评分项\n提交完问题后如果没有质控结束可以先不点完成质控，方便后续继续质控\n\n\n\n上级质控完成后，下级医师就可以看到了\n\n\n\n下级医师完成整改后，上级医师可以在科室整改跟踪模块查看。\n\n\n8 病历模板宏：提取信息后医师无法修改，一般只用在病人基本信息的提取。如果需要新的宏，只能联系开发来添加。\n元素：提取信息后医师可以更改。所有要医师可以编辑的都使用元素。\n–\n常见的特殊元素：\n123病历名称：勾选框：（如果要用复选框，没有的话在管理里面新增）医师签名：这个如果后期上CA的话，只能添加元素数据检索唯一键是S0_65536的元素，如下图。\n\n\n如果当前病历(首次病程记录)中的主诉要调用入院记录中主诉的数据，选中当前病历的主诉元素，属性下有个缺省值设置，在病历模板入口下，依次选择，看下图。\n\n固定标题指的是入院记录中有个标题元素是主诉，调用的这个元素后的数据.\n数据源指的是入院记录中有个元素是主诉，直接调用的这个元素的数据。\n\n\n","slug":"winning 住院病历","date":"2024-12-30T15:48:51.199Z","categories_index":"工作","tags_index":"工作","author_index":"Vegetabhl"},{"id":"4f29ce88c66bb19bbd3457ec6add2391","title":"Winning 药房、药库系统","content":"[TOC]\n1 药品字典基本维护\n\n1.1 临床目录在(药库管理一&gt;设置一&gt;药品临床目录设置)模块\n\n1.2 规格目录规格目录、产地目录字典的维护都在(药库管理一&gt;设置一&gt;药品字典设置)模块\n\n注意下收费大项目的药品标志\n1.3 产地目录规格目录、产地目录字典的维护都在(药库管理一&gt;设置一&gt;药品字典设置) 模块\n帐目类别是在基础his信息维护下的(系统配置一&gt;药品系统一&gt;药品账目设置)模块维护的\n单位系数设定好后如果发现系数设定错误，如果进行了入库操作产生了库存，就无法再修改。只能停用该药品，库存清零，重新维护该药品，所以要谨慎。\n\n2 药库业务\n首先基础数据维护\n\n药库和药房在**(系统配置一&gt;基础表一&gt;科室设置)**模块中添加对应科室\n\n药房和药库代码在**(系统配置一&gt;药品系统一&gt;药库代码设置、药房代码设置)**模块设置\n\n\n\n1.药库未启用就去入库或者盘点会报如下错误：\n\n2.启用药库前需要先在**(药库管理一&gt;设置一&gt;初值设置、系统启用)**模块做初值设定，否则新建入库单或者盘点会发现没有数据，然后系统启用。\n\n2.1 药库业务-进1.采购计划模块\n\n（药库管理一&gt;计划报警一&gt;药品采购计划）模块\n\n2.药品入库模块\n\n（药库管理一&gt;库存管理一&gt;药品入库）一&gt;新入库单一&gt;复核一&gt;记账\n\n其中入库方式正常和挂账区别在于，正常是供货商药品将药品发来时，必须携带发票(货票同行)，即必须要录入发票号。挂账则不需要录入发票。\n如果是采用的挂账入库，会生成一笔台账记录，在（药库管理一&gt;财务一&gt;药库台账）模块能看到。供货商送来发票后财务那边要记得冲账，冲账是在**(药库管理一&gt;库存管理一&gt;在途冲证)**模块进行冲账。\n\n\n入库完成之后如果发现入库数据错误：\n\n如果是部分药品明细入库信息错误，在**(药库管理一&gt;库存管理一&gt;药品入库_支持红冲)**模块进行红冲，然后重新对这个药品重新进行入库即可。\n\n如果是整张入库单都录入错误，在**(药库管理一&gt;库存管理一&gt;药品入库撤销)**模块进行撤销，然后重新入库即可。\n\n\n最后入库成功之后可以进行入库查询，查看库存是否有变化。\n3.药品退货模块\n\n**(药库管理一&gt;库存管理一&gt;药品退货)**模块\n\n比如有破损的药品，快过期并且不再维护的药品、或者不再销售的药品，需要退货给供货商。\n2.2 销1.药品出库模块 (这个是直接出库到药房)\n\n（药库管理一&gt;库存管理一&gt;药品出库）一&gt;新出库单一&gt;新出库单(或者取单据-&gt;取申请单)\n\n药库直接出库到药房、或者药房先打请领单，然后药库根据请领单进行出库(就是上面的取单据出库的方式)\n\n2.科室发药模块\n\n（药库管理一&gt;库存管理一&gt;科室发药）模块\n\n2.3 存1.药品盘点模块\n\n（药库管理一&gt;库存管理一&gt;药品盘点、药品盘点录入）模块\n\n单人盘点就用药品盘点模块就行\n如果是多人盘点的情况下，用药品盘点录入模块进行盘点\n2.4 药库台账\n（药库管理一&gt;财务一&gt;药库台账、药品对账、台账月结）模块\n\n定期对药品进行盘点。月底盘点完后需要依次进行药库台账、药品对账、台账月结。\n\n3 药房(以下均以门诊药房为例)1.首先基础数据维护：药库代码设置、药房代码设置\n(药库和药房在科室设置中添加)\n\n**(系统配置一&gt;药品系统一&gt;科室设置)**模块\n\n**(系统配置一&gt;基础表一&gt;科室设置)**模块\n\n\n2.收、发、配窗口设置。\n\n**(系统配置一&gt;门诊系统一&gt;收、发、配窗口设置)**模块、收发配窗口设置\n\n\n\n3.1 进1.药房请领流程：\n1.**(门诊药房一&gt;库存管理一&gt;药房请领)**模块一&gt;新请领单一&gt;单据存盘\n2.药房请领之后，药库在药库出库模块就可以看到了，然后出库。详细参照2.2章节\n3.药库出库后，药房这边在**(门诊药房一&gt;库存管理一&gt;药品入库)**模块进行药品入库。到此药房请领流程就完成了\n\n备注：除了正常的药房请领、药库直接出库到药房外，还可以在（门诊药房一&gt;库存管理一&gt;外部入库）模块对药房的药品进行入库。这种是针对的是不走药库。\n2.药房退库流程：\n1.**(门诊药房一&gt;库存管理一&gt;药房退库)**模块一&gt;新退库单一&gt;单据存盘\n2.药房退库之后，药库在**(药库管理一&gt;库存管理一&gt;药房退库)**模块就可以看到了，然后接收\n\n\n3.2 销发药、退药业务流程\n3.3 存台账的月结等等\n","slug":"Winning 药房、药库系统","date":"2024-12-28T14:35:06.284Z","categories_index":"工作","tags_index":"工作","author_index":"Vegetabhl"},{"id":"bd8dc2dc805bea8f596381ac4c12c817","title":"Winning 人员基本信息维护&权限添加","content":"人员基本信息维护&amp;权限添加1 医生基本信息维护和权限添加1.1 职工信息登记-分配权限\n这里科室、病区都添加只是控制的默认登录设置，只要登录的话执行1.2，参照u5013。只有登录护士站需要同时有病区和科室对应才可以登录，其余比如手术管理系统、门诊输液系统这些只需要有科室即可(记账在科室)。\n\n科室设置：勾选对应病区，护士站登录时必需要有科室和病区的对应关系。\n\n职称的不同会影响抗菌药物和手术等级权限的分配。\n\n勾选对应的权限\n\n\n\n\n1.2 医生对应病区设置\n添加个人所在的所有病区和科室\n科室设置：勾选对应病区，护士站登录时必需要有科室和病区的对应关系。\n\n\n\n1.3 住院医生站修改用户权限\n签名和职称会同步his，如果没传过来，手动添加下\n医生权限添加护理表单权限，过滤入院，除产科外，其余科室医生只勾选入院护理评估记录单所有权限(除新增和删除外)–这个目前不用了\n\n\n\n2 护士基本信息维护和权限添加2.1 职工信息登记-分配权限同1.1\n2.2 护理系统添加病历权限\n2.3 检验系统导入对应人员\n2.4 护理系统内部权限添加\n分配（角色）岗位\n\n如果限定只有特定某些人拥有的权限，这里岗位最好在his单独再分配一个。例如临床项目设置的权限只分配给蒋浩主任，由于他目前所在的岗位权限还有其他人，为了避免多人都有这个临床项目权限。那就单独设置一个检验管理员的岗位，只加他一个人。只给这个岗位分配临床项目权限。\n\n\n添加权限\n\n\n3 医技权限分配his人员导入，分配对应权限。不写了。\n4输液室–省略\n5 手术室–省略\n","slug":"Winning 人员基本信息维护&权限添加","date":"2024-12-23T14:30:13.223Z","categories_index":"工作","tags_index":"工作","author_index":"Vegetabhl"},{"id":"e0749a230089fbaecf273d937919b50f","title":"《挂号收费出入院》练习指引路径","content":"《挂号收费出入院》练习指引路径 \n\n\n\n序号\n模块\n模块内容\n\n\n\n1\n基本信息登记\n基本信息登记界面，刷卡、读卡或读身份证，补全必填信息\n\n\n2\n基本信息维护\n基本信息维护菜单-查找患者信息-修改信息-点击修改按钮\n\n\n3\n挂号登记\n1、读取患者信息  2、选择挂号类别  3、选择需要挂号的科室或专家  4、挂号收费\n\n\n4\n凭证修改\n一、修改患者门诊凭证信息  医保凭证修改菜单-检索患者信息-界面下方选择新费用类别  二、修改患者本次挂号的凭证信息  门诊挂号-日常工作-挂号登记界面，加载患者信息后，左侧患者列表“费用类别”处，双击选择修改的费用类别\n\n\n5\n退号\n挂号登记界面-点击退号按钮-检索患者信息-加载挂号记录-选中记录-点击作废\n\n\n6\n单次收费\n门诊收费界面-检索患者信息-勾选需收费处方信息-点击收费\n\n\n7\n多次收费\n单次收费后，系统提示“是否加载未收费处方”-点击“是”-继续收银\n\n\n8\n退费\n当日退药退费&#x2F;隔日退药退费界面-检索患者信息-加载已收处方明细-点击退费处理或快捷键F9全退  注：退药退费需医生先申请退费\n\n\n9\n处方解锁\n收费时提示“处方被锁定”。门诊收费-收费工作-门诊收费处方处理-定位患者-加载锁定处方-点击处方状态更新\n\n\n10\n发票异常处理\n一、补打重打挂号收费凭条  门诊收费-查询-门诊多发票打印-定位患者，勾选打印记录-打印凭条  二、电子发票打印  门诊收费-电子发票-门诊发票-定位收费记录-打印\n\n\n11\n门诊合并结账\n门诊挂号-财务-门诊合并结账-点击统计，查询数据-点击结账-打印结账单\n\n\n12\n合并结账单统计\n门诊挂号-财务-合并结账单统计-账单筛选-账单统计\n\n\n13\n入院登记\n开入院单：通过卡号或病历号加载入院单信息或点击入院单选择入院单记录，补全其他必填信息  未开入院单但有门诊建档信息：通过卡号或病历号加载门诊登记基本信息后，补全必填信息  门诊未建档：通过卡号或病历号，弹出门诊基本信息登记界面建档。建档完成后不全入院登记必填信息\n\n\n14\n入院取消\n左侧列表选种患者或右侧通过卡号磁卡定位患者后，点击取消入院\n\n\n15\n预交金管理\n预交金收：检索患者信息-选择支付方式-录入预交金额-保存  预交金退：检索患者信息-选中需退记录-点击退费\n\n\n16\n医保凭证修改\n医保凭证修改菜单-检索患者信息-界面下方选择新费用类别\n\n\n17\n病人结账\n出院结算：  选择患者后-点击预结算-选择使用预交金记录-点击执行结算  单项结算：  选择患者后-住院结算扩展功能-单项结算-通过日期或项目或金额筛选费用后-点击确定-选择使用预交金记录-执行结算\n\n\n18\n取消结账\n定位患者后-选中需取消结算记录-点击取消结算\n\n\n19\n出院病人费用清单\n定位患者后-点击打印-打印患者费用清单\n\n\n20\n操作员结账\n点击统计-结账-打印。打印本次结账的单据\n\n\n","slug":"《挂号收费出入院》练习指引路径","date":"2024-11-21T14:53:20.380Z","categories_index":"工作","tags_index":"工作","author_index":"Vegetabhl"},{"id":"f3b2e5de3bb3466e90ad92e6ab572687","title":"Winning Health","content":"[TOC]\n0 系统安装0.1 各科室安装需求\n\n\n系统\n科室\n\n\n\nHIS\n护士站、药房、收款室、所有辅助科室和行政科室\n\n\n门诊医生站\n门诊医生站、住院医生站\n\n\n住院医生站\n门诊医生站、住院医生站\n\n\n护理工作站  (–检验采集–执行科室设置常规室)  n2700\n护士站\n\n\n门诊输液室.net版本\n门诊输液室、新院护士站\n\n\n手术管理系统.net版本\n手术室、介入\n\n\n打印插件LS60(Techsvr)  (–打印设置)\n医生站、护士站\n\n\nsetup.exe\n医生站、叫号windows设备\n\n\n.net\n基本都需要\n\n\n医技系统\n彩超、放射、内镜、检验、输血\n\n\n0.2 HIS系统安装\n右击his，文件位置，双击打开，选择快捷方式，勾选对应所需的客户端保存即可。\n\n.net 版本共两个，版本要求4.5，上图所示。\n给各科室安装的时候不需要安装完整his，安装对应所需客户端即可。\n对应角色使用对应权限账号，做好权限控制。权限划分甘老师负责的。\n0.3 医技系统安装0.3.1 检验安装\n0.3.2 检查安装\n1 HIS医生站和护士站需要同时有病区和科室对应才可以登录，其余比如手术管理系统、门诊输液系统这些只需要有科室即可(记账在科室)\n1.1 人员基本信息维护详细参照：https://vegetabhl.netlify.app/post/Winning%20%E4%BA%BA%E5%91%98%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E7%BB%B4%E6%8A%A4&amp;%E6%9D%83%E9%99%90%E6%B7%BB%E5%8A%A0\n\n职工操作登记：登记个人基本信息，需要注意，在职工操作登记模块添加的人员科室和病区信息，会默认同步到医生站的操作人员管理模块中的科室和病区，即登录工作站默认显示的个人所在科室和病区。\n医生对应病区设置：添加个人所在的所有病区和科室\n科室设置：勾选对应病区，工作站登录时必需要有科室和病区的对应关系。\n\n1.2 权限维护详细参照：https://vegetabhl.netlify.app/post/Winning%20%E4%BA%BA%E5%91%98%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E7%BB%B4%E6%8A%A4&amp;%E6%9D%83%E9%99%90%E6%B7%BB%E5%8A%A0\n\n护士：his勾选权限-护理系统添加病历权限-检验系统导入对应人员\n医生：his勾选权限-住院医生站用户权限-添加用户签名     -医生权限添加护理表单权限，过滤入院，除产科外，其余科室医生只勾选入院护理评估记录单所有权限(除新增和删除外)\n\n1.3收费项目维护：勾选医技使用后，住院下的医技医嘱(不包括有独立医技系统的科室)，医技系统这边才可以看到。然后才能确认（确费）。\n门诊都可以看到，勾不勾选在医技没确认前医生都可以直接退。\n注：检验检查项目的成套收费项目在护理系统下的临床项目目录中维护，然后添加在医生站下的申请单目录中维护。\n\n1.4  医技确费药品除外\n\n上图是最基本的确费逻辑，但是不完全正确，如下：\n由于检验、检查是走申请单的，这些组套项目先在护理系统的临床项目设置维护，然后在申请单维护。\n申请单也可以控制执行科室。（仅仅针对右图当前申请单模板下的项目）\n\n如果申请单设置的执行科室和组套主项目设置的执行科室不一致(比如常规心电图，参考下图)\n\n或者说组套项目的主项目在his收费项目中没设置执行科室，即未勾选医技执行(比如骨密度测定)，但是申请单设置了\n\n\n那么申请单优先级更高，一切以申请单设置的执行科室为准。\n但是申请单只控制执行科室，对于该项目是否是勾选了医技执行，还是以该收费项目在his中为准。\n\n\n–\n所以问题来了，如果一个走申请单的项目它既在医技科室执行，又在病区执行。那就必须要在申请单模板中维护两个，参考上图心电图和心电图科室执行。\n病区执行的维护一个没勾选医技执行的项目，医生开这个。(病区发送后计费到医生选的执行科室(注意不一定是计费到病区，看选的执行科室))\n医技科室维护一个勾选了医技执行的项目，医生开这个。(医技科室计费确认后计到医技科室)\n\n举例：(胃镜室计费)\n\n存在的问题：\n门诊(维护成套)：\n\n维护成套。如果开胃肠镜，报告走媒介的话。只会收一个报告费。\n门诊上直接开卫材会不会违规？\n氧气吸入等这些治疗不是必开的项目，如果维护成套，难道要病人再去退吗？病人嫌麻烦，医生也会嫌麻烦。\n\n住院：\n暂时还好，后续不知道还好不好……\n1.5 医技科室如何计费\n1住院计费使用\n2 住院计费，会自动刷新病人。\n3医技退费\n4 门诊医技确认使用\n6 不用\n7 不用\n10 住院确认加补记账使用\n–\n注意查看计费和确认，这是两个状态。\n1.6 住院发药模式(以bid为例，截止2024-12-22，测试库)9-15两个时间点\n\n\n以设置的时间点会往后加59分59秒，即10点、16点时间点为准。不知道为什么要加这样一个隐藏逻辑。\n\n且只是药品这样，其他的非医技确认的项目等都是医嘱发送后在9，15点执行，记账也是这两个时间点。\n\n\n1.6.1药品(包含注射费的药品)药房什么时候发药什么时候记账\n1.6.1.1 当天首次开的药品(长嘱) 10点前核对、发送\n\n药房会发三组药，记账记三组药，注射费只会记两次。\n\n\n\n10-16点核对、发送\n\n药房会发两组药，记账记两组药，注射费只会记一次。\n\n\n\n16点后核对、发送\n\n药房会发一组药，记账记一组药，不会记注射费。\n\n\n\n1.6.1.2 隔日发送的药品(长嘱) 10点前核对、发送\n\n发两组药，记账记两次\n\n10-16点核对、发送\n\n发两组药，记账记两次\n\n16点后核对、发送\n\n发两组药，记账记两次\n\n1.6.1.3 药品发药模式总结\n只有当天首次开的长期药，药才会发到第二天上午。即多开半天的药。并且只有首次开的长期药才会限制不同时间段开的数量不一致。\n隔日药护士站不论什么时间段发送，只要药房发药，都会发两组药，记两次(bid)。\n药房什么时候发药，什么时候记账，以药房发药时间为准。\n\n1.6.2 其他项目，例如悬空灸等非医技确认的项目(不一定都是病区执行，主要是非医技确认)病区核对发送完后就记上账了\n1.6.2.1 当天首次开的项目 9点前核对、发送\n\n会在9，15点整执行，记账也是这两个时间点。\n\n\n9-15点核对、发送\n\n只会在15点执行一次，记账也在15点记一次\n\n15点后核对、发送\n\n当日不会执行，不会记账\n\n1.6.2.2 隔日 9点前核对、发送\n\n隔日的治疗，即使护士站11点发送的，依然在9和15点记了两次。\n\n9-15点核对、发送\n\n隔日的治疗，即使护士站11点发送的，依然在9和15点记了两次。\n\n\n15点后核对、发送\n\n隔日的治疗，即使护士站11点发送的，依然在9和15点记了两次。\n\n1.6.2.3 非医技确认项目执行、记账模式总结\n首次开的治疗才会限制不同时间段，开的次数不一样。\n隔日发送的治疗，护士站不论什么时间段发送，都是固定的记两次(bid)。\n病区发送后就记上账了，记账时间为固定时间点，9或15点。这两个时间点执行。\n\n1.7 第一章注意事项\n很多控制都是在可调参数下，需要靠时间在使用过程中来了解。\n当时收费项目维护说的要勾选体检，后来不知道为什么又不需要勾选了，回头问下。\n\n\n2 门诊挂号\n2.1 排班相关设置\n2.1.1 科室专家预约标志设置 1.挂号科室，勾选大科室，后续排班处才能显示待排班科室。\n  2.专家挂号，点击专家，后续排班处才能显示，待排班专家。\n\n2.1.2 预约排班设置\n预约科目这里回车选择科室，能被预约的科室要在科室专家预约标志设置里面勾选上。如下图\n\n\n设置排版模板（号别那里有自定义的模板，如果没有符合要求的就手动输）\n\n上面挂号时间如果不是全天的，需要依次添加上午，下午，夜间。\n排版设置好后直接生成就可以了，常见问题如可能会有冲突排班。\n\n排班停诊有两种\n\n模板停诊后，以后再生成排班表也不会有这个科室\n查询排班表后停诊当前排班\n\n2.2 挂号登记2.2.1 分配发票号首先给每一个操作员分配发票号，发票号和号序一样不能重复。\n门诊挂号、收费，住院、出院等全部都要先分配操作员发票号，下面不再赘述\n\n门诊上只有挂号(GH) 和收费(SF)，住院还包括预交金(YJJ)等，下图。\n\n2.2.2 挂号登记入口：【挂号系统】-【日常工作】-【挂号登记】\n\n第一步：通过病历号、卡号或身份证号检索患者信息\n\n患者已建档直接带出患者建档信息\n患者未建档，弹出基本信息登记界面，进行患者登记；\n\n​          患者建档时，如果无法获取患者身份证和电话，可以勾选临时卡；\n登记成功后，关闭登记界面挂号主界面会自动带出患者信息。\n第二步：选择挂号类别。\n\n普通挂号：科室和专家挂号 \n专家挂号：挂专家号   \n急诊挂号：只有预检病人可以急诊挂号 (预检这个不用)\n\n\n第三步：通过拼音\\代码检索本次挂号的科室或专家\n\n第四步：点击【挂号】，系统根据患者处方自动计算应缴金额，弹出收银界面，操作员在此界面可选择现金等多种支付方式。默认现金.\n\n在其他选项下有个挂号查询，常用\n\n\n2.2.3  基本信息维护\n入口一：【挂号系统】-【日常工作】-【基本信息维护】\n入口二：【挂号系统】-【日常工作】-【挂号登记】-快捷键F9调出基本信息维护菜单\n\n可以通过读卡定位，包括磁卡，保障卡，IC卡 ；也可以通过病历号，姓名，身份证号，电话号码进行定位，将病人的基本信息加载出来进行修改\n\n2.2.4 医保凭证修改2.2.4.1 修改患者医保凭证信息\n入口一：【挂号系统】-【日常工作】-【基本信息维护】-【医保凭证修改】\n\n入口二：【挂号系统】-【日常工作】-【挂号登记】-【其他功能】-【凭证修改】\n\n入口三：【挂号系统】-【日常工作】-【医保凭证修改】\n\n\n可以通过读卡定位，包括磁卡，保障卡，IC卡 ；也可以通过病历号进行定位，加载患者信息后，界面下方选择新费用类别。\n\n2.2.4.2. 修改当次挂号医保凭证信息入口：【挂号系统】-【日常工作】-【挂号登记】\n左侧患者列表，费用类别处双击-选择本次挂号结算的费用类别\n\n2.2.5  退号入口：【挂号系统】-【日常工作】-【挂号登记】-【退号】\n通过读卡、病历号、姓名定位患者，选中需退记录，点击【作废】\n\n3 门诊收费3.1 收费窗口设置\n3.2 通过卡号、病历号等定位需要缴费的患者点击【收费】按钮，系统根据患者处方自动计算应缴金额，弹出收银界面，操作员在此界面可选择现金等多种支付方式，默认现金，快捷键F1可切换扫码付和pos付。支付后，点击【确定】按钮，打印凭条，收费成功\n\n3.3 门诊退费入口：【收费系统】-【收费工作】-【当日退药退费】&#x2F;【隔日退药退费】\n注：退费需要医生先做退费申请，才能退费\n通过卡号、病历号等定位需要缴费的患者。加载已结算记录\n\n核对退药数量。可退记录为蓝色字体显示，不可退记录为黑色字体显示。点击【退费处理】或快捷键F9退费\n\n3.4 门诊收费查询\n\n3.5 门诊处方查询入口：【收费系统】-【查询】-【门诊处方查询】\n可按流水号、患者、时间、收费员、发票号、科室等多种维度查询门诊处方数据\n\n3.6 门诊划价入口：【收费系统】-【收费工作】-【门诊收费】\n注：划价患者必须要有当日挂号记录\n通过卡号、病历号等定位需要缴费的患者。添加项目-点击划价-打印划价单\n\n4.7 结账\n\n4 门诊医生站\n\n\n\n5 药房(门急诊药房、住院药房)药房、药库补充部分参照：https://vegetabhl.netlify.app/post/%E8%8D%AF%E6%88%BF%E3%80%81%E8%8D%AF%E5%BA%93%E7%B3%BB%E7%BB%9F\n首先设置发药窗口，同收费窗口设置一样，不再赘述。\n药房发药，分中西药房，登录不同药房账号发药。\n5.1 门诊药房5.1.1 门诊药房发药、追溯码流程从门诊药房系统主界面选择菜单项中“日常工作”—&gt;“发药工作”。进入发药工作窗口\n\n选择接受本窗口处方或者接受本药房处方。患者到达窗口后操作员获取处方信息，人工核对无误后进行发药处理。\n从右侧患者列表选择处方时，可以通过单处方发药进行发药操作。确认发药可以将患者多张待发处方一次处理完成。\n点击确认发药后，弹出追溯码界面，将发送给患者的药品的追溯码放在高拍仪下扫码，所有的药品都扫码完成后，点击下方完成按钮，完成绑定追溯码工作，同时完成发药工作。\n\n5.1.2 门诊药房退药流程从门诊药房系统主界面选择菜单项中“日常工作”—&gt;“病人退药”。进入病人退药窗口（图1-1-4）。\n\n医生站申请退费，审核员审核后，药房在退药界面读卡获取到患者待退药处方，选择待退药明细输入退药原因之后，点击确认退药，弹出追溯码界面，将需退药品的追溯码放在高拍仪下扫码，所有的药品都扫码完成后，点击下方确定按钮，完成绑定追溯码工作，同时完成退药操作。如果需要撤销已退药操作，点击取消退药进行撤销操作。\n5.2 急诊药房发药、退药流程急诊药房的发药&#x2F;退药流程与门诊西药房一致，参考门诊药房发药&#x2F;退药流程。\n5.3 住院药房住院开的所有药，均要登录中心药房进行发药。\n5.3.1 住院药房发药、追溯码流程从中心药房系统主界面选择菜单项中“日常管理”—&gt;“住院发药”。进入住院发药窗口（图1-1-1）。\n护士在执行医嘱成功之后，药房就可以刷新显示出对应病区的领药单信息\n\n系统默认根据医嘱执行时间过滤出一段时间内的领药单信息，也可以修改查询时间或是通过“显示更多”按钮中的查询条件来过滤病区领药信息。\n在病区单据列表中可以选择单个领药单节点进行发药，使用发药确认功能；也可以选择单个病区节点，对病区节点下面所有的领药单进行发药处理，使用节点全部发药功能。\n发药前核对医嘱有误时，使用药品作废和单据药品作废对医嘱进行打回处理。\n发药后可以自动打印发药单，也可以手工进行发药单补打，并且允许不同领药类型的药品进行汇总打印及明细打印。\n点击发药单补打，点击左下角，追溯码按钮\n\n5.3.2 住院药房退药流程从中心药房系统主界面选择菜单项中“日常管理”—&gt;“病人退药”。进入住院病人退药窗口（图1-1-3）。\n病人退药流程由病区护士发起申请，药房首先选择退药申请病区，右侧显示该病区的退药单列表，勾选其中需要操作的退药单及退药明细，与实物核对无误后点击确认即可完成病人退药操作。\n\n5.4 注意事项\n药房药库的库存、盘点、调拨、台账这些没加，以后有时间了再了解，感觉也不属于信息科需要了解的范畴。\n门诊药房集成了一个住院发药，另外库存、药品的查询、字体大小的设置留意下在哪就行。\n注意药房药库，每月月底必需进行对账，步骤1 2 3 有报错，立马联系工程师。\n\n\n6 门诊输液室\n6.1 如需要皮试首先在皮试审方内登记皮试结果\n\n\n皮试结果如果登记错了可以修改，确定无误后再将结果登记录入。\n登记完后才能依次再去收费（前提阴性），然后药房发完药后依次导入输液处方、核对通过\n\n核对通过后，在已审核， 审核以后就不予许取消审核。\n\n6.2 如不需要皮试直接导入输液处方，核对，输液执行就可以。\n7 出入院管理系统7.1 入院7.1.1 门诊医生开入院单，分配病区和科室\n7.1.2 入院登记入口：【出入院系统】-【入院工作】-【入院登记】-【入院单】\n通过录入门诊住院号、卡号检索患者信息\n搜索到患者入院单，双击患者，将患者信息自动带入入院登记界面，填写患者其他信息，点击保存，入院登记成功。\n也可以手动录入患者基本信息，例如转院患者，点击保存，进行入院操作。\n\n7.1.3 预交金管理(交预交金、退预交金)（退预交金也在这个界面，输入退费金额，点红冲即可。【预计金一般很少退，不常用】）\n\n7.1.4 入院取消入口：【出入院系统】-【入院工作】-【入院取消】\n左侧列表选中患者，或右侧通过卡号、病历号等位患者后，点击【确定】，取消入院\n有预交金-直接跳转预交金界面-红冲退费后-取消成功\n无预交金-无预交金-取消成功\n\n7.1.5 病人基本信息维护入口：【出入院系统】-【入院工作】-【病人信息维护】\n通过卡号、病历号检索患者，或在列表处定位患者后，修改信息后点击【修改】按钮\n\n7.1.6 医保凭证修改入口：【出入院系统】-【入院工作】-【医保凭证修改】\n操作员进入医保凭证修改页面，进行读卡，查找出患者信息后，如果需要卡号不变，则只进行修改费别即可，如果卡号变的话，则重新进行读卡，点击保存后进行修改。\n\n7.1.8  取消结算入口：【出入院系统】-【出院管理】-【取消结账】\n通过住院号、卡号检索患者信息后加载已结算记录，选中需要取消结算的记录后，点击【取消结算】\n7.2 出院7.2.1 首先参照9.57.2.2 病人结账(办理出院)入口：【出入院系统】-【出院管理】-【病人结账】\n病人结算方式共有三种：出院结算，单项结算\n正常出区患者，在结算界面输入病历号定位患者，预结算，根据预交金余额和医保返回金额，给患者应退现金或补收现金，执行结算\n\n7.2.3 取消结算入口：【出入院系统】-【出院管理】-【取消结账】\n通过住院号、卡号检索患者信息后加载已结算记录，选中需要取消结算的记录后，点击【取消结算】\n\n7.3 出院财务结账7.3.1 收费员结账入口：【出入院系统】-【财务】-【收费员结账】\n点击【统计】按钮，数据核对无误后，点击【结账】按钮。结账后点击【打印】按钮打印结账单\n\n7.3.2 结账单统计入口：【出入院系统】-【财务】-【住院结账单统计】\n选择过滤条件后，点击【查询】按钮查询数据，可按照操作员、项目、大项等维护统计结账信息\n\n8 护士工作站8.1 入区参照7.1办理入院，根据入院单上分配的病区和科室，登录该病区护士账号拉病人入区，分配责任护士和住院医生等。\n护理文书相关操作文档之后另写。\n\n8.2 转区8.2.1 住院医生先开转区医嘱，参照9.18.2.2 当前病区护士核对、发送\n8.2.3 然后患者流转，登记转入病区相关信息\n8.2.4 转入病区护士接收并重新分配责任护士，医生等等。此处不再赘述，参照8.1。8.3 住院退药8.3.1 首先护士站先退药\n8.3.2 然后药房退药这里需要说明下，住院病人退药，不论是中药还是西药，全部在中心药房进行退。中药也要在中心药房登录门诊中药房操作员账号退。\n此处药房执行步骤不再赘述。\n8.3.3 医生DC医嘱，参照9.38.4 补记账\n可以在记账模块进行多病人补记账\n\n医嘱工作台记账只能记材料\n\n记账模块的补记账不仅仅可以记材料，还有其他项目。\n\n\n9 住院医生站9.1 转区分配的住院医生登录住院医生工作站，开转区医嘱\n\n之后参照8.2\n9.2 住院医生开医嘱\n之后责任护士核对执行即可，对于需要皮试的项目，在过敏管理里面登记皮试结果即可\n\n相关单据在医嘱工作台右侧\n\n之后护士站核对执行，然后对应执行科室执行即可，此处不再赘述。\n9.3 住院退药9.3.1 首先参照8.39.3.2 住院医生DC医嘱\n9.4 住院退医技相关不需要经过护士站，如果项目做过了，医技科室先退，然后医生作废医嘱。项目没做的话医生直接作废即可。\n9.5 出院9.5.1 住院医生开出院医嘱9.5.2 护士核对发送9.5.3 住院处办理出院详细参照7.2\n10 医技相关10.1 检验系统10.1.1 采集1.门诊采集\n在门诊采集模块，输入病员号进行查询，如果查不到注意看下是不是右上角时间范围没选对。\n确定无误后，选中要采集的医嘱，点打印条码。\n\n10.1.2 标本查询在标本查询模块，输入相应检索信息查询标本。点击下图条形码可以进行样本跟踪。此外还有一个单独的样本跟踪模块也可以进行样本跟踪。\n注意下方有个标本条码140000000072，标本签收时使用。\n\n\n10.1.2 签收\n签收模块，输入对应条码号，进行标本签收。\n\n撤销：撤销后标本回退到待签收状态，当前标本依然可以重新签收\n\n补打：条码补打。\n\n回执单：没太搞懂什么场景下需要，是不是让病人自己去自助设备打印报告？记一下回头问下杨老师。\n\n退回：退回一般是标本有问题。和撤销不同，一旦退回，需要重新采集绑定条码，重新签收。\n\n\n–\n另外签收时，可以勾选显示样本医嘱参考仪器，在下方查看可选做仪器。这里需要注意下，如果没有对应仪器，那可能该项目没有维护对应收费项目，在收费项目下需要添加对应仪器。最好还是联系检验科让他们自己来维护。\n\n样本视图：一个标本跟踪的全过程记录。这里采样时间间隔一般是说的住院，比如当晚打印条码，隔日采样这种。因为门诊一般绑定后就采样了。\n\n10.1.3 报告管理(入库)报告管理模块是核心模块，主要使用在这个模块。\n10.1.3.1 标本入库样本号为自定义，一般从1开始就行。\n右侧选择仪器，可以在签收模块查看要选择的仪器。然后输入条形码进行标本入库。\n\n10.1.3.2 审核发布仪器结果出来后就可以进行审核、发布了。\n审核、发布之后：1医生站那边才能看到报告，2才能打印报告\n\n\n–\n也可以在右边这里进行批量的审核发布，包括查看标本全流程，更改表格字段顺序之类等等。\n\n10.1.3.3 危急值处理右下角选中危急选项，针对某个仪器筛选所有标本的危急值，确认无误后进行网络发布。\n如果发布后发现错误，也可以进行网络召回，但是危急值最好是确认好后再发送。\n\n发送后医生那边确认处理，然后状态变为已确认\n\n10.1.4仪器配置10.1.4.1 仪器项目新增项目、编辑项目之类。\n\n10.1.4.2 项目设置\n–\n其余的像什么审核后直接打印之类的，一些使用习惯上的功能，自己有时间看看吧。\n10.1.5 检验项目现在检验项目模块维护相关项目，然后添加到仪器上。\n10.1.6 收费项目(成套)his新增相关收费项目后，在下图导入。\n注：his中的检验检查成套收费项目  在护士站的临床项目下维护。\n\n10.1.7 微生物微生物标本入库有单独的模块，和报告管理相似，需要注意下。\n包括单独的微生物配置模块\n10.1.8 退费没什么说的，回收报告-取消审核-撤回签收-取消条码绑定，然后就可以退费了。\n10.2 输血系统待补充…\n10.3 影像(彩超、放射、内镜)10.3.1 登记扫病员号登记。\n10.3.2报告书写医技的分诊叫号可以通过请求分诊，也可以通过双击报告书写，都可以进行呼叫。\n10.3.3 注意事项\n报告发布后如果需要部分退费，比如胶片。需要先回收报告，再点击相关退费项目的撤，然后重新发布。\n查询和全院联网\n\n11 门诊输液系统11.111.2 打印机设置\n勾选打印设计，重启\n\n\n重启后\n\n\n\n\n勾选完毕后，在卫宁健康科技——配置参数——用户级设置——打印设计勾选掉\n重启\n12 手术室管理系统待补充…(不怎么会，需要学习)\n13 物资申领待补充…\n14 临床路径待补充…\n15 医务流程待补充…\n16 病历16.1 门诊病历待补充…\n16.2 住院病历待补充…\n16.3 护理文书待补充…\n17 分诊叫号17.1 安装(医生站)注意下图中圈中的部分就行\n\n17.2 后台维护(医生站)分诊室管理和诊区管理的概念。\n17.2.1 诊区管理其中诊区管理的(科室对应)控制的就是登录的医生站是否是当前诊区医生的，最新问的添加小科室就可以。\n\n17.2.2 诊室管理其中诊室管理(诊室名称)控制的就是门屏显示及呼叫的名称。\n\n17.2.3 核心规则其他一些核心规则基本都在下图两个模块。包括一些个性化定制，常用的召回规则等等。\n\n17.3 后台维护(医技)\n安卓机器后台维护\n\nhttp://172.16.156.11:9423/#/TriageScreen\n\nwindows后台维护程序\n\n\n\n18 自助机1.装WinningHealthChrome\n2.把。Exe双击，然后发送到桌面，开机自启动\n\n3.装Techsvr\n4.设置分组(必须有这一步)\n\n19 医保–重点–\n20 报表–重点–\n","slug":"Winning Health","date":"2024-10-14T13:05:41.951Z","categories_index":"工作","tags_index":"工作","author_index":"Vegetabhl"},{"id":"e0678d96ea5517903ec41e8e23a94999","title":"sql server共享目录等相关路径无法更改","content":"注意：什么路径不可改就搜索该路径进行删除注册表记录，然后重启电脑\n按 win 键盘 + R 输入 regedit 进去注册表，点击计算机按 “编辑”–》查找下一个\n\n需要等一些时间\n\n结果出来后把搜到的结果的项删除\n\n删除之后  按 F3 继续查找下一个进行删除，删除直到搜索完毕\n\n然后把原来安装的注册表记录查找出来删除：\n\n把含有 Microsoft SQL Server 字样的都删除\n\n删除完这个再按 F3 查找下一个删除\n\n删除直到按 F3 显示搜索完毕\n\n接着再搜索删除记录  MSSQL\n\n直按 F3 删除到显示搜索完毕\n\n最后重启电脑重新安装\n\n32 位的不可改是因为没搜索 C:\\Program Files (x86)\\Microsoft SQL Server\\  进行删除，可自行搜索删除\n\n\n","slug":"sql server共享目录等相关路径无法更改","date":"2024-07-25T13:08:45.761Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"fd29a6255ba6815d7a29c88dd74c9f39","title":"ubuntu日常使用","content":"ubuntu日常使用网上下载安装的程序统一放在~&#x2F;soft目录下\n本文所有操作全部基于ubuntu20.04版本\n[TOC]\n0 常用命令和快捷键1234567891011121314151617快捷键：pwd 查看当前目录alt+a 打开程序菜单ctrl+l 清屏命令：which 命令    （查询安装位置）echo $PATH     (查询path路径都包含哪些)chmod +x ./Anaconda3-2019.03-Linux-x86 64.sh   （给anaconda安装程序添加执行权限）sudo ln -s /usr/bin/python3 /home/i/conda/bin/python （新建软连接，前面为放到path的目录，后面为实际目录）tar -zxvf cudnn-11.0-linux-x64-v8.0.5.39.tgz   (解压缩)rm -rf *.gz (-r递归，-f强制删除文件或目录)cp aaa/buhuili.tar.gz /bbb/bhl.tar.gz （复制目录aaa下bhl.tar.gz到/bbb目录下，并改名为bhl.tar.gz）mv ~/buhuili.tar.gz  ~/Documents bhl.tar.gz  （移动原始文件到目标路径下,并改名为bhl.tar.gz）\n\n\n\n1 常见问题1.1 缺少有线连接大部分的新硬件对系统内核有较高的要求，如果发现电脑缺少相关驱动，比如缺少有先网络连接，可以尝试升级内核\n内核查看\n1uname -r\n\n选择升级内核尽量选择当前大版本下的最新版本，不要跨大版本。实在不行再考虑换大版本。\n比如查询内核版本为5.4.0。升级的时候尽量选择5开头的最新版本。\n内核升级文件下载地址\nhttps://kernel.ubuntu.com/mainline/\n\n在ubuntu下安装这四个文件\n\n\n之后重启。\n1.2 缺少无线网1.2.1 ubuntu18.04安装方法Intel 官网 (英特尔 ® 无线适配器的 Linux* 支持) 给出了在 Linux 下 AX210 所需要的最低环境：linux 内核 5.10+，而 Ubuntu18.04 最新内核版本为 5.4，不符合要求。可以通过升级内核的方式安装，但存在较大的风险。因此选择不升级内核的方法进行驱动的安装。\n安装步骤：\n更新软件列表\n1sudo apt update\n\n安装必须的包\n1sudo apt install flex bison\n\n克隆 backport 仓库\n12git clone https://github.com/intel/backport-iwlwifi.gitcd backport-iwlwifi\n\n进入 iwlwifi-stack-dev 文件并编译\n1234cd iwlwifi-stack-devsudo make defconfig-iwlwifi-publicsudo makesudo make install\n\n下载驱动文件，或者可以从 Intel 官网下载\n123git clone git://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.gitcd linux-firmware/sudo cp iwlwifi-* /lib/firmware\n\n或者从 intel 官网下载，解压后将 ucode 文件放入/lib/firmware即可\n1.2.2 ubuntu20.04安装方法要在 Ubuntu 20.04 上安装 AX210 无线适配器，您需要执行以下步骤：\n\n确认您的 Ubuntu 20.04 系统已经安装了最新的内核和固件更新。您可以使用以下命令检查：\n12sudo apt updatesudo apt upgrade\n\n安装 iw 和 wireless-tools 软件包，这些软件包提供了管理无线网络的工具：\n1sudo apt install iw wireless-tools\n\n下载 AX210 的固件文件。您可以在 Intel 的官方网站(英特尔 ® 无线适配器的 Linux* 支持) 上找到最新的固件文件。下载后，解压缩文件并将其中的 iwlwifi-ty-a0-gf-a0-XX.ucode 文件复制到 &#x2F; lib&#x2F;firmware 目录下。\n\n更新系统的 initramfs，以使新的固件文件生效：\n1sudo update-initramfs -u\n\n重新启动您的系统以应用所有更改：\n1sudo reboot\n\n现在，您应该能够使用 AX210 无线适配器连接到无线网络了。您可以使用以下命令检查无线适配器的状态：\n1iwconfig\n\n如果您看到一个类似于 wlan0 的接口，并且该接口的状态是 “UP”，则表示无线适配器已经连接到无线网络。\n\n\n2 基础软件安装系统安装后需要做的操作\n1 更改包管理器镜像源\n\n2 安装显卡驱动\n\n2.1 anaconda安装（前期环境准备）注意：cuda和cudnn的版本对应关系去我的另一篇博客查看\n检查显卡驱动有无安装成功\n1nvidia-smi\n\n检查cuda本身（编译器）有无安装\n1nvcc -V \n\n\n如果提示如上图所示未找到nvcc命令，有以下两种情况\n2.1.1 cuda安装了，但是没添加到环境变量1which nvcc 能查到说明安装了\n\n则需要添加下环境变量。\n12345vi  ~/.bashrcexport PATH=“/usr/local/cuda-11.0/bin:&#123;PATH&#125;”   （路径是which查询的结果）source ~/.bashrc   (使添加的环境变量生效)\n\n2.1.2  cuda未安装，则需要安装cuda1 如果之前安装了旧版本的cuda和cudnn的话，需要先卸载后再安装：\n1sudo apt-get remove --purge nvidia*\n\n然后再通过系统的软件与更新来安装重新安装显卡驱动\n\n选择第一个安装Nvidia官方驱动（第二个是开源驱动）即可，根据网络情况稍等大概十分钟，安装完重启服务器。\n重启完之后更新一下软件：\n12sudo apt updatesudo apt upgrade\n\n这里会连带Nvidia的驱动一起升级一遍，更新到最新的驱动；更新完可能会出现nvidia-smi命令报错，再重启一下就解决了。\n2 安装CUDA\n2.1 去官网下载cuda安装包：CUDA Toolkit 11.0 Download | NVIDIA Developer，相关选项如下（根据实际情况选择）：\n\n运行下面的命令进行安装：\n12chmod +x cuda_11.0.2_450.51.05_linux.runsudo sh ./cuda_11.0.2_450.51.05_linux.run\n\n可能会报一个警告：\n\n前面已经卸载过旧版本了直接Continue就好。然后根据提示选择安装选项，注意不要勾选第一个安装显卡驱动的，因为之前已经安装过了。 安装完成后提示\n\n2.2  参照2.1.1配置环境变量\n2.3 可以使用命令nvcc -V查看安装的版本信息：\n\n2.1.3  cudnn安装进入到CUDNN的下载官网：cuDNN Download | NVIDIA Developer，然点击Download开始选择下载版本，当然在下载之前还有登录，选择版本界面如下：\n\n我们选择和之前cuda版本对应的cudnn版本：\n\n下载之后是一个压缩包，对它进行解压，命令如下：\n1tar -xzvf cudnn-11.0-linux-x64-v8.0.5.39.tgz\n\n使用以下两条命令复制这些文件到CUDA目录下：\n12sudo cp cuda/lib64/* /usr/local/cuda-11.0/lib64/sudo cp cuda/include/* /usr/local/cuda-11.0/include/\n\n拷贝完成之后，可以使用以下命令查看CUDNN的版本信息：\n1cat /usr/local/cuda/include/cudnn_version.h | grep CUDNN_MAJOR -A 2\n\n可以看到版本信息如下，为8.0.5：\n\n2.2 anaconda安装（正式安装）123456chmod +x ./Anaconda3-2019.03-Linux-x86 64.sh   （给anaconda安装程序添加执行权限）./Anaconda3-2019.03-Linux-x8664.sh             （执行anaconda安装程序）q  （弹出合同查看按q确认）yes （接收协议）/home/i/conda (输入安装路径，这里是安装在home/i目录下的conda文件夹内)yes（将conda添加到环境变量）\n\n最后新打开一个终端依次输入如下命令验证\n\n尤其是python，由于ubuntu自带python，而我们需要使用的是conda下的python。需要注意路径是否正确。如果不对，可以尝试做个软连接，然后放到path路径下面的任意一个目录下。比如（&#x2F;usr&#x2F;local&#x2F;bin）\n新建一个软连接\n1sudo ln -s /usr/bin/python3 /home/i/conda/bin/python\n\n使用python3命名是为了避免和系统python命名冲突，当然也可以直接删掉系统自带的python软连接，这样再使用python命名也行，但是我总感觉不太好，看个人把。\n2.3 docker安装2.3.1 卸载旧版本Docker 的旧版本被称为 docker，docker.io 或 docker-engine 。如果已安装，请卸载它们：\n1$ sudo apt-get remove docker docker-engine docker.io containerd runc\n\n当前称为 Docker Engine-Community 软件包 docker-ce 。\n2.3.2 设置仓库在新主机上首次安装 Docker Engine-Community 之前，需要设置 Docker 仓库。之后，您可以从仓库安装和更新 Docker 。\n更新 apt 包索引。\n1$ sudo apt update\n\n安装依赖包:\n1sudo apt install apt-transport-https ca-certificates curl gnupg2 software-properties-common\n\n添加 GPG 密钥\n添加 Docker 的官方 GPG 密钥：\n1$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n\n如果你在阿里云上部署，可能使用阿里云的镜像源（在下面），添加阿里云的证书会更好一些。添加阿里云证书:\n1$ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -\n\n添加软件源\n对于 amd64 架构的计算机，添加清华大学 TUNA 软件仓库:\n1sudo add-apt-repository \\   &quot;deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu \\   $(lsb_release -cs) \\   stable&quot;\n\n你也可以使用阿里云的软件仓库:\n1sudo add-apt-repository \\    &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\    $(lsb_release -cs) \\    stable&quot;\n\n如果你对你的网络比较有信心，也可以使用官方的软件仓库:\n1sudo add-apt-repository \\   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\  $(lsb_release -cs) \\  stable&quot;\n\n如果你是 ARM 架构，请运行:\n1echo &quot;deb [arch=armhf] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu \\     $(lsb_release -cs) stable&quot; | \\    sudo tee /etc/apt/sources.list.d/docker.list\n\n2.3.3 安装 Docker Engine-Community更新 apt 包索引。\n$ sudo apt update\n安装最新版本的 Docker Engine-Community\n1$ sudo apt install docker-ce\n\n2.3.4 测试\n\n\n\n\n\n\n\n\n注意：如果你的网络和我一样不好使，请先行进行镜像加速再测试。\n输入:\n1$ sudo docker run hello-world\n\n如果 docker 和你问好——或者说出现类似以下输出:\n1Unable to find image &#x27;hello-world:latest&#x27; locallylatest: Pulling from library/hello-worldb8dfde127a29: Already exists Digest: sha256:7d91b69e04a9029b99f3585aaaccae2baa80bcf318f4a5d2165a9898cd2dc0a1Status: Downloaded newer image for hello-world:latest Hello from Docker!This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.    (amd64) 3. The Docker daemon created a new container from that image which runs the    executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it    to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/\n\n就说明安装完事了。\n2.3.5 免 sudo 运行 &amp; 镜像加速免 sudo\n参考如下方法将用户添加到 docke 组\n1$ sudo usermod -aG docker [你的用户名]\n\n重启 docker\n1$ sudo systemctl restart docker\n\n(然而我的机器上发生了很诡异的事——我重启 docker 服务后依然不能以普通用户启动 docker。重启机器后才能免 sudo 运行。)\ndocker 镜像加速\n我用了阿里云的免费加速（镜像加速是针对官方仓库进行访问加速，不是阿里仓库，如果镜像源是使用的阿里仓库，则不需要进行镜像加速）\n\n\n\n\n\n\n\n\n\nhttps://cr.console.aliyun.com/cn-hangzhou/instances/mirrors\n后续设置按照阿里云网页内提示即可，不再赘述。\n2.4 clash安装（linux版本）地址 ：https://v2rayse.com/client\n由于clash删库了，可以使用clash-verge替代\n2.4.1 安装clash-verge方法和2.4.2一样\n打开clash-verge后需要将下面两个模式打开。\n\n2.4.2 安装clash for linux解压安装clash for linux后，执行图上cfw程序即可打开clash for linux\n\n到此就可以使用了\n由于每次使用都需要进入到clash目录下面执行cfw程序，比较麻烦。所以考虑将其设置为一个应用。\n将可执行程序路径添加到应用程序菜单栏并创建图标的方法\n\n\n3 桌面环境美化更改终端窗口大小，颜色，透明度等等\n\n3.1 美化前准备Ubuntu 20.04 的美化是一个比较繁琐的过程，不过只要掌握了方法，就能将 Ubuntu 20.04 打造成你最喜欢的样子。下面列出一些美化前的准备。\n3.1.1 安装必要软件打开 Terminal 软件，一次执行如下命令。\n1234sudo apt updatesudo apt install gnome-tweaks chrome-gnome-shellsudo apt install gtk2-engines-murrine gtk2-engines-pixbuf sudo apt install sassc optipng inkscape libcanberra-gtk-module libglib2.0-dev libxml2-utils\n\n3.1.2 安装一些必要的插件Ubuntu 20.04 默认使用的是 gnome 的桌面环境，本文的美化也是基于 gnome 桌面环境，美化 gnome 桌面环境少不了安装 gnome 插件，gnome 插件的网址是：https://extensions.gnome.org\n打开 Firefox 浏览器，在地址栏输入 gnome 插件的网址，如下图：\n\n如上图我红色框出的地方，提示要在 Firefox 浏览器中安装 gnome extensions 的扩展包，点击安装，安装浏览器弹出的提示依次确认即可。安装好扩展包后刷新以下浏览器页面就可以开始安装 gnome 插件了。我们需要预先安装的插件有如下几个，分别搜索出来安装就可以了。\n\nuser themes\ndash to dock\nnetspeed\n\n这里我只演示 netspeed 的安装，其他两个安装方法一样。如果你需要安装其他 gnome 插件，也可以按照这个方法安装。\n搜索打开 netspeed 插件主页，如下图：\n\n点击图中红色方框框住的按钮开关，打到 On，按照提示依次操作即可安装成功。注意对比桌面安装这些插件后的差异。\n3.1.3 下载必要的美化包所有的美化包都可以从 https://www.gnome-look.org 这个网站下载的，我列出本次美化需要下载的美化包的详细下载地址。这个网站在国内访问非常的慢，如果你下载不下来，可以私信我获取。\n\n主题包：WhiteSur Gtk Theme\n\nhttps://www.gnome-look.org/p/1403328/\n\nIcons 图标：WhiteSur icon theme\n\nhttps://www.pling.com/p/1405756/\n\n鼠标图标：McMojave cursors\n\nhttps://www.pling.com/p/1355701/\n\n壁纸：WhiteSur Wallpaper\n\nhttps://www.pling.com/p/1398833/\n\nFirefox 浏览器美化：\n\n参考：https://github.com/vinceliuice/WhiteSur-gtk-theme/tree/master/src/other/firefox\n\n\n我下载的文件全部存在 Download 目录下面，如下图：\n\n3.2、开始美化根据自己的美化需求下载好相应的美化软件包后，就可以开始美化了。\n3.2.1 安装主题包Ubuntu 20.04 为所有用户提供的默认存放主题的文件夹分别如下：\n\n主题包：&#x2F;usr&#x2F;share&#x2F;themes&#x2F;\n\n将下载好的主题包解压到这个目录，或者解压后拷贝到这个目录。\n\nIcons 图标：&#x2F;usr&#x2F;share&#x2F;icons\n\n将下载好的 Icons 图标解压到这个目录，或者解压后拷贝到这个目录。\n\n鼠标图标：&#x2F;usr&#x2F;share&#x2F;icons\n\n将下载好的鼠标图标解压到这个目录，或者解压后拷贝到这个目录。\n\n选择下载的壁纸图片，右键设置为壁纸即可。\n\n上面的操作一定要保证正确无误，接下来就可以选择这些主题包，并让其生效了。\n打开 gnome-tweaks 工具，如下图：\n\n上图红色方框中选中的就是刚刚安装的主题，选中后桌面和图标、鼠标图标，shell 主题等都相应的变化了，注意对比。\n3.2.2 安装 plank dock 工具打开 terminal ，输入如下命令安装 plank。\n\nsudo apt install plank\n\n安装好后打开 gnome-tweaks 工具，设置 plank 为开机启动，如下图：\n\n还记得之前在浏览器安装的 dash to dock 吗？现在有了 plank，我们就不再需要它了，现在在浏览器上打开 gnome 插件的网站，在已安装的插件中找到 dash to dock。删除它之前我们还要用它做一些配置，点击像扳手一样的图标进行设置。\n\n选择 dock 在底部显示\n\n\n\n去掉一些不需要的效果，如下图，把所有选择都去掉。\n\n\n\n删除 dash to dock，如下图，点击 X 图标即可删除\n\n\n是时候重启电脑了，现在就重启电脑看看效果吧。如下图：\n\n3.3 最后的配置这个效果已经不错了，但是我还是不满意，继续做一些设置，让它更符合我心中的样子。\n3.3.1 plank 设置plank 默认没有动画效果，将鼠标放在 plank 边缘，然后右键出现如下菜单，选择 Preference 进行设置。\n\n我主要做了如下两个修改：\n\n将主题改成 Transparent\nIcon Zoom 打开，这样鼠标划过 plank 上的软件图标的时候就会有放大的效果。\n\n\n\n将常用的软件固定到 plank 上\n\n首先点击左上角的 apple 图标就可以搜索或者选择打开软件，在 plank 上找到打开的软件图标右键就可以看到 keep in Dook 的选项，勾选上即可，不想在 plank 上显示的图标把勾去掉即可。\n\n3.3.2 gnome-tweaks 设置\n关闭桌面显示的图标\n\n桌面有个家目录和回收站的图标，居然删除不了，别担心，打开 gnome-tweaks 软件，如下图，点击 Desktop icons 插件后面的设置图标，弹出右边的设置菜单。\n\n将设置菜单中的两个开关关闭即可，如下图：\n\n\n顶部状态栏显示设置\n\n如下图，选中 Top Bar 选项，将后边的开关都打开，注意顶部状态栏的变化。\n\n3.3.3 Firefox 浏览器美化设置\n打开 Firefox 浏览器，在地址栏输入：about:support\n在打开的界面一次选择：Application Basics &gt; Profile Directory &gt; Open Directory.\n\n\n点击 Open Directory 后会打开一个文件夹，将我们下载好的 WhiteSur-gtk-theme-master.zip 解压，然后将解压后的目录中：WhiteSur-gtk-theme-master&#x2F;src&#x2F;other&#x2F;firefox&#x2F; 目录下的 chrome 目录拷贝到刚打开的目录中。\n重启 Firefox 浏览器，在地址栏输入：about:config，回车，在打开的页面点击接受，接着在打开的页面中搜索：\ntoolkit.legacyUserProfileCustomizations.stylesheets 双击把它的值改为 true\nlayers.acceleration.force-enabled 双击把它的值改为 true\n重启浏览器看效果吧。\n重启后点击浏览器右上角的设置按钮，如下图：\n\n点击 Customize，进行设置。去掉下图红色方框所示的勾。再次重启查看效果吧。\n\n3.4 总结Ubuntu 20.04 的美化到这里就结束了，其实还有很多想说的，由于篇幅的问题，还有文字描述真的太难了。\n","slug":"ubuntu日常使用","date":"2024-06-11T14:30:45.836Z","categories_index":"操作系统,网络,常用工具,项目,环境配置,docker","tags_index":"操作系统,网络,常用工具,项目,环境配置,docker","author_index":"Vegetabhl"},{"id":"5a30a74d412d8315491a167b8e238a38","title":"华为IA-IE","content":"华为IA-IE","slug":"华为IA-IE","date":"2024-06-06T14:12:13.456Z","categories_index":"工作,网络,项目","tags_index":"网络,常用工具,项目","author_index":"Vegetabhl"},{"id":"77f66672ba9a793de02312a2e6c233c6","title":"Excel数据位置匹配","content":"Excel数据位置匹配1.1 原始数据处理\n数据列先移动到单元格最上面位置不要动.\n复制对应标签。\n复制对应标签。\n\n注意步骤先后顺序。\n1.2 Excel数据位置匹配（重点）举例：如下图，希望将M列的数据匹配到和K列相同数据 行号位置一样的单元格处 ，方便比对\nK列为企业微信原始登记数据\nM列为待匹配数据（比如杀毒软件导出的离线ip）\nN列为匹配的行号（在N列第一个空白单元格处使用公式1）\nO列是M列数据根据N列对应行号移动位置后的数据（在O列第一个空白单元格处使用公式2）\n在O列第一个单元格使用公式后，按住鼠标左键并向下拖动填充柄，一直拖动到K列最后一个数据所在的行号处\n12公式1：匹配行号=IF(ISBLANK(M1), &quot;&quot;, MATCH(M1, K:K, 0))\n\n123公式2：移动位置=IF(ISNUMBER(MATCH(ROW(), $N$1:$N$75, 0)), INDEX($M$1:$M$75, MATCH(ROW(), $N$1:$N$75, 0)), &quot;&quot;)75为M列最后一个数据的行号\n\n\n\n\n\n\n","slug":"Excel数据位置匹配","date":"2024-06-03T17:17:36.289Z","categories_index":"工作,常用工具","tags_index":"工作,常用工具","author_index":"Vegetabhl"},{"id":"3fe1ee3f3830128bf539e5f4ed9fbbe9","title":"Linux","content":"Linux\n1234567891011121314151617181920/（根目录）：文件系统的根目录，所有其他目录和文件都位于此目录下。/bin（Binary）：存放系统必需的二进制执行文件，这些文件对所有用户都是可用的。/home：用户的家目录，每个用户在该目录下都有自己的子目录，用于存放个人文件。/usr（User）：存放用户使用的程序和文件，这是一个非常大的目录，包含许多子目录。/opt（Optional）：用于存放第三方软件包和附加应用程序。/etc（Etcetera）：存放系统的配置文件和子目录。/dev（Devices）：包含设备文件的目录，这些文件代表系统中的硬件设备。/proc（Processes）：虚拟文件系统，包含系统进程的信息和内核参数。/var（Variable）：存放经常变化的文件，如日志文件、打印队列、邮件缓冲文件等。/tmp（Temporary）：用于存放临时文件，系统重启时可能会清空此目录。/root：根用户（超级管理员）的家目录。/boot：存放启动Linux时使用的一些文件，如内核映像和启动加载器配置文件。/lib（Library）：存放系统库文件，这些文件是二进制执行文件运行时所需的。/mnt（Mount）：临时挂载文件系统的目录，通常用于挂载USB驱动器或CD/DVD。/media：自动挂载可移动媒体（如USB驱动器、CD-ROM）的目录。/srv（Service）：存放服务数据的服务器目录。/sbin（System Binary）：存放系统管理的二进制执行文件，通常只有管理员（root）才能执行。/lost+found：每个分区都有一个lost+found目录，用于存放系统崩溃时未正常关闭的文件。\n\n1 各个分支及其发行版介绍1 Debian系列\n12345包管理器：dpkg + APT（Advanced Package Tool）安装命令(APT)：sudo apt-get install package_name安装命令(dpkg)：dpkg -i package.deb 卸载包的命令：sudo apt remove package_name\n\n\nDebian：以其稳定性和安全性而闻名，Debian使用dpkg包管理系统和APT（Advanced Package Tool）来处理软件包的安装和更新。它有稳定版（Stable）、测试版（Testing）和不稳定版（Unstable）三个主要分支。Debian非常适合服务器和需要高度稳定性的环境。\n\nUbuntu：基于Debian，由Canonical Ltd.支持，Ubuntu专注于易用性和用户友好性。它有长期支持版（LTS）和六个月更新一次的标准版。Ubuntu默认使用Unity桌面环境（尽管也有其他桌面环境的版本），非常适合桌面用户和初学者。\n\nLinux Mint：基于Ubuntu，Linux Mint提供了Cinnamon、Mate和Xfce等桌面环境。它旨在提供一种开箱即用的用户体验，包括媒体编码和专有软件的驱动程序。Linux Mint非常适合希望从Windows轻松过渡到Linux的用户。\n\nelementary OS：也是基于Ubuntu，elementary OS以其优雅的界面和一致性而著称。它使用自己开发的Pantheon桌面环境，并提供了精心设计的应用程序。\n\n\n2 Red Hat系列\n123456包管理器：RPM + YUM（Yellowdog Updater, Modified）或DNF（Dandified Yum）安装命令（YUM）：sudo yum install package_name安装命令（DNF）：sudo dnf install package_name使用YUM的卸载命令：sudo yum remove package_name使用DNF的卸载命令：sudo dnf remove package_name\n\n\n**Red Hat Enterprise Linux (RHEL)**：这是一个商业发行版，主要面向企业用户，提供长期支持、稳定性和安全性。RHEL使用RPM包管理系统和YUM或DNF来进行包管理。它适合需要企业级支持和服务的环境。\nFedora：由Red Hat赞助，Fedora是一个社区驱动的项目，它包含了最新的开源技术。Fedora经常更新，适合开发者和爱好者，以及那些希望尝试最新软件的用户。\nCentOS：原本是一个基于RHEL的社区版，提供免费的、企业级的、稳定的和可扩展的操作系统平台。自从CentOS项目转变方向后，Rocky Linux和AlmaLinux成为了它的替代品。\n\n3 Arch Linux系列\n1234包管理器：Pacman安装命令：sudo pacman -S package_name卸载包的命令：sudo pacman -R package_name\n\n\nArch Linux：一个轻量级、简单化的发行版，采用滚动更新模式，允许用户从源代码编译他们的整个系统。Arch Linux适合有经验的用户，他们希望拥有高度自定义的系统。\nManjaro：基于Arch Linux，Manjaro提供了更加用户友好的安装过程和预配置的桌面环境，如XFCE、KDE和GNOME。它保留了Arch Linux的灵活性和最新软件，同时减少了安装和配置的复杂性。\n\n4 Gentoo系列\n1234包管理器：Portage安装命令：sudo emerge package_name卸载包的命令：sudo emerge --unmerge package_name\n\n\nGentoo：Gentoo是一个高度可定制的发行版，几乎所有软件都是从源代码编译的。它适合那些希望完全控制自己的系统，并且愿意投入时间来学习和配置系统的用户。\n\n\n2 国产操作系统3 主流发行版使用（ubuntu）1 常用快捷键 (终端内快捷键)\n123456ctrl+alt+t：打开新终端。ctrl+l：清除终端内容。ctrl+shift+c 复制ctrl+shift+v 粘贴\n\n\n\n2 常用命令\n\nvi&#x2F;vim (编辑文件)\n\n123esc进入命令模式:wq：保存退出:q!：不保存退出\n\n\napt show package-name（将显示软件包的详细信息，包括它的版本和描述。）\n\ncat (查看文件)\n\nmore（查看文件）\n\n\n12按 Space 键：显示文本的下一屏内容。(按q退出)按 Enter 键：只显示文本的下一行内容。\n\n\nfind（查找名称带filename的文件，模糊查询）\n\n1find / -name &quot;filename*&quot;\n\n- - ","slug":"Linux","date":"2024-05-26T12:13:16.439Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"ba3795bcaa1c4cf0d23951d6953d8fd5","title":"3-DQL查询语句、约束、多表关系、范式、数据库备份和还原","content":"3-DQL查询语句、约束、多表关系、范式、数据库备份和还原txt1. DQL:查询语句\n    1. 排序查询\n    2. 聚合函数\n    3. 分组查询\n    4. 分页查询\n\n2. 约束\n3. 多表之间的关系\n4. 范式\n5. 数据库的备份和还原DQL:查询语句txt1. 排序查询\n    * 语法：order by 子句\n        * order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...\n\n    * 排序方式：\n        * ASC：升序，默认的。\n        * DESC：降序。\n\n    * 注意：\n        * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。\n\n\n2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。\n    1. count：计算个数\n        1. 一般选择非空的列：主键\n        2. count(*)\n    2. max：计算最大值\n    3. min：计算最小值\n    4. sum：计算和\n    5. avg：计算平均值\n\n\n    * 注意：聚合函数的计算，排除null值。\n        解决方案：\n            1. 选择不包含非空的列进行计算\n            2. IFNULL函数\n\n3. 分组查询:\n    1. 语法：group by 分组字段；\n    2. 注意：\n        1. 分组之后查询的字段：分组字段、聚合函数\n        2. where 和 having 的区别？\n            1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来\n            2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。\n\n        -- 按照性别分组。分别查询男、女同学的平均分\n\n        SELECT sex , AVG(math) FROM student GROUP BY sex;\n        \n        -- 按照性别分组。分别查询男、女同学的平均分,人数\n        \n        SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;\n        \n        --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组\n        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;\n        \n        --  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人\n        SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;\n        \n        SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2;​\t\t\t​\t4. 分页查询​\t\t1. 语法：limit 开始的索引,每页查询的条数;​\t\t2. 公式：开始的索引 &#x3D; （当前的页码 - 1） * 每页显示的条数​\t\t\t– 每页显示3条记录​\t​\t\t\tSELECT * FROM student LIMIT 0,3; – 第1页​\t\t\t            SELECT * FROM student LIMIT 3,3; – 第2页\ntxt        SELECT * FROM student LIMIT 6,3; -- 第3页\n\n    3. limit 是一个MySQL&quot;方言&quot;约束txt* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。\t\n* 分类：\n    1. 主键约束：primary key\n    2. 非空约束：not null\n    3. 唯一约束：unique\n    4. 外键约束：foreign key\n\n* 非空约束：not null，值不能为null\n    1. 创建表时添加约束\n        CREATE TABLE stu(\n            id INT,\n            NAME VARCHAR(20) NOT NULL -- name为非空\n        );\n    2. 创建表完后，添加非空约束\n        ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;\n\n    3. 删除name的非空约束\n        ALTER TABLE stu MODIFY NAME VARCHAR(20);​\t​\t* 唯一约束：unique，值不能重复​\t\t1. 创建表时，添加唯一约束​\t\t\tCREATE TABLE stu(​\t\t\t\tid INT,​\t\t\t\tphone_number VARCHAR(20) UNIQUE – 添加了唯一约束​\t\t\t​\t\t\t);​\t\t\t* 注意mysql中，唯一约束限定的列的值可以有多个null\n​\t\t​\t\t2. 删除唯一约束​\t\t​\t\t\tALTER TABLE stu DROP INDEX phone_number;​\t\t        3. 在创建表后，添加唯一约束            ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;\ntxt* 主键约束：primary key。\n    1. 注意：\n        1. 含义：非空且唯一\n        2. 一张表只能有一个字段为主键\n        3. 主键就是表中记录的唯一标识\n\n    2. 在创建表时，添加主键约束\n        create table stu(\n            id int primary key,-- 给id添加主键约束\n            name varchar(20)\n        );\n\n    3. 删除主键\n        -- 错误 alter table stu modify id int ;\n        ALTER TABLE stu DROP PRIMARY KEY;\n\n    4. 创建完表后，添加主键\n        ALTER TABLE stu MODIFY id INT PRIMARY KEY;\n\n    5. 自动增长：\n        1.  概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长\n\n        2. 在创建表时，添加主键约束，并且完成主键自增长\n        create table stu(\n            id int primary key auto_increment,-- 给id添加主键约束\n            name varchar(20)\n        );​\t\t\t​\t\t\t3. 删除自动增长​\t\t\tALTER TABLE stu MODIFY id INT;​\t\t\t4. 添加自动增长​\t\t\tALTER TABLE stu MODIFY id INT AUTO_INCREMENT;\ntxt* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。\n    1. 在创建表时，可以添加外键\n        * 语法：\n            create table 表名(\n                ....\n                外键列\n                constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)\n            );\n\n    2. 删除外键\n        ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\n\n    3. 创建表之后，添加外键\n        ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);​\t\t​\t\t4. 级联操作​\t\t\t1. 添加级联操作​\t\t\t\t语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称​\t\t\t\t\t\tFOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;​\t\t\t2. 分类：​\t\t\t\t1. 级联更新：ON UPDATE CASCADE​\t\t\t\t2. 级联删除：ON DELETE CASCADE \n数据库的设计txt1. 多表之间的关系\n    1. 分类：\n        1. 一对一(了解)：\n            * 如：人和身份证\n            * 分析：一个人只有一个身份证，一个身份证只能对应一个人\n        2. 一对多(多对一)：\n            * 如：部门和员工\n            * 分析：一个部门有多个员工，一个员工只能对应一个部门\n        3. 多对多：\n            * 如：学生和课程\n            * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择\n    2. 实现关系：\n        1. 一对多(多对一)：\n            * 如：部门和员工\n            * 实现方式：在多的一方建立外键，指向一的一方的主键。\n        2. 多对多：\n            * 如：学生和课程\n            * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键\n        3. 一对一(了解)：\n            * 如：人和身份证\n            * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。\n\n    3. 案例\n        -- 创建旅游线路分类表 tab_category\n        -- cid 旅游线路分类主键，自动增长\n        -- cname 旅游线路分类名称非空，唯一，字符串 100\n        CREATE TABLE tab_category (\n            cid INT PRIMARY KEY AUTO_INCREMENT,\n            cname VARCHAR(100) NOT NULL UNIQUE\n        );\n        \n        -- 创建旅游线路表 tab_route\n        /*\n        rid 旅游线路主键，自动增长\n        rname 旅游线路名称非空，唯一，字符串 100\n        price 价格\n        rdate 上架时间，日期类型\n        cid 外键，所属分类\n        */\n        CREATE TABLE tab_route(\n            rid INT PRIMARY KEY AUTO_INCREMENT,\n            rname VARCHAR(100) NOT NULL UNIQUE,\n            price DOUBLE,\n            rdate DATE,\n            cid INT,\n            FOREIGN KEY (cid) REFERENCES tab_category(cid)\n        );\n        \n        /*创建用户表 tab_user\n        uid 用户主键，自增长\n        username 用户名长度 100，唯一，非空\n        password 密码长度 30，非空\n        name 真实姓名长度 100\n        birthday 生日\n        sex 性别，定长字符串 1\n        telephone 手机号，字符串 11\n        email 邮箱，字符串长度 100\n        */\n        CREATE TABLE tab_user (\n            uid INT PRIMARY KEY AUTO_INCREMENT,\n            username VARCHAR(100) UNIQUE NOT NULL,\n            PASSWORD VARCHAR(30) NOT NULL,\n            NAME VARCHAR(100),\n            birthday DATE,\n            sex CHAR(1) DEFAULT &#39;男&#39;,\n            telephone VARCHAR(11),\n            email VARCHAR(100)\n        );\n        \n        /*\n        创建收藏表 tab_favorite\n        rid 旅游线路 id，外键\n        date 收藏时间\n        uid 用户 id，外键\n        rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次\n        */\n        CREATE TABLE tab_favorite (\n            rid INT, -- 线路id\n            DATE DATETIME,\n            uid INT, -- 用户id\n            -- 创建复合主键\n            PRIMARY KEY(rid,uid), -- 联合主键\n            FOREIGN KEY (rid) REFERENCES tab_route(rid),\n            FOREIGN KEY(uid) REFERENCES tab_user(uid)\n        );​\t\t​\t2. 数据库设计的范式​\t\t* 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求​\t​\t\t\t设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。​\t\t\t目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。​\t        * 分类：            1. 第一范式（1NF）：每一列都是不可分割的原子数据项            2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）                * 几个概念：                    1. 函数依赖：A–&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A                        例如：学号–&gt;姓名。  （学号，课程名称） –&gt; 分数                    2. 完全函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。                        例如：（学号，课程名称） –&gt; 分数                    3. 部分函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。                        例如：（学号，课程名称） – &gt; 姓名                    4. 传递函数依赖：A–&gt;B, B – &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A                        例如：学号–&gt;系名，系名–&gt;系主任                    5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码                        例如：该表中码为：（学号，课程名称）                        * 主属性：码属性组中的所有属性                        * 非主属性：除过码属性组的属性\ntxt        3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）数据库的备份和还原txt1. 命令行：\n    * 语法：\n        * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径\n        * 还原：\n            1. 登录数据库\n            2. 创建数据库\n            3. 使用数据库\n            4. 执行文件。source 文件路径\n2. 图形化工具：","slug":"3-DQL查询语句、约束、多表关系、范式、数据库备份和还原","date":"2024-05-01T11:43:02.716Z","categories_index":"mysql","tags_index":"mysql","author_index":"Vegetabhl"},{"id":"9c31673e0471abc8c04ba8eee1f127f7","title":"2-DQL多表查询、事务、DCL(管理用户和授权)","content":"2-DQL多表查询、事务、DCL(管理用户和授权)txt1. 多表查询\n\n2. 事务\n\n3. DCL多表查询：txt* 查询语法：\n    select\n        列名列表\n    from\n        表名列表\n    where....\n* 准备sql\n    # 创建部门表\n    CREATE TABLE dept(\n        id INT PRIMARY KEY AUTO_INCREMENT,\n        NAME VARCHAR(20)\n    );\n    INSERT INTO dept (NAME) VALUES (&#39;开发部&#39;),(&#39;市场部&#39;),(&#39;财务部&#39;);\n    # 创建员工表\n    CREATE TABLE emp (\n        id INT PRIMARY KEY AUTO_INCREMENT,\n        NAME VARCHAR(10),\n        gender CHAR(1), -- 性别\n        salary DOUBLE, -- 工资\n        join_date DATE, -- 入职日期\n        dept_id INT,\n        FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键)\n    );\n    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;孙悟空&#39;,&#39;男&#39;,7200,&#39;2013-02-24&#39;,1);\n    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;猪八戒&#39;,&#39;男&#39;,3600,&#39;2010-12-02&#39;,2);\n    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;唐僧&#39;,&#39;男&#39;,9000,&#39;2008-08-08&#39;,2);\n    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;白骨精&#39;,&#39;女&#39;,5000,&#39;2015-10-07&#39;,3);\n    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#39;蜘蛛精&#39;,&#39;女&#39;,4500,&#39;2011-03-14&#39;,1);\n* 笛卡尔积：\n    * 有两个集合A,B .取这两个集合的所有组成情况。\n    * 要完成多表查询，需要消除无用的数据\n* 多表查询的分类：\n    1. 内连接查询：\n        1. 隐式内连接：使用where条件消除无用数据\n            * 例子：\n            -- 查询所有员工信息和对应的部门信息\n\n            SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;\n            \n            -- 查询员工表的名称，性别。部门表的名称\n            SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;\n            \n            SELECT \n                t1.name, -- 员工表的姓名\n                t1.gender,-- 员工表的性别\n                t2.name -- 部门表的名称\n            FROM\n                emp t1,\n                dept t2\n            WHERE \n                t1.`dept_id` = t2.`id`;​\t​\t\t\t2. 显式内连接：​\t\t\t\t* 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件​\t\t\t\t* 例如：​\t\t\t\t\t* SELECT * FROM emp INNER JOIN dept ON emp.dept_id &#x3D; dept.id;\t​\t\t\t\t\t* SELECT * FROM emp JOIN dept ON emp.dept_id &#x3D; dept.id;\t​\t​\t\t\t3. 内连接查询：​\t\t\t\t1. 从哪些表中查询数据​\t\t\t\t2. 条件是什么​\t\t\t\t3. 查询哪些字段​\t\t2. 外链接查询：​\t\t\t1. 左外连接：​\t\t\t\t* 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；​\t\t\t\t* 查询的是左表所有数据以及其交集部分。​\t\t\t\t* 例子：​\t\t\t\t\t– 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称​\t\t\t\t\tSELECT \tt1.*,t2.name FROM emp t1 LEFT JOIN dept t2 ON t1.dept_id &#x3D; t2.id;​\t\t\t2. 右外连接：​\t\t\t\t* 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；​\t\t\t\t* 查询的是右表所有数据以及其交集部分。​\t\t\t\t* 例子：​\t\t\t\t\tSELECT \t* FROM dept t2 RIGHT JOIN emp t1 ON t1.dept_id &#x3D; t2.id;​\t\t3. 子查询：​\t\t\t* 概念：查询中嵌套查询，称嵌套查询为子查询。​\t\t\t\t– 查询工资最高的员工信息​\t\t\t\t– 1 查询最高的工资是多少 9000​\t\t\t\tSELECT MAX(salary) FROM emp;​\t\t\t\t                – 2 查询员工信息，并且工资等于9000的                SELECT * FROM emp WHERE emp.salary &#x3D; 9000;\ntxt            -- 一条sql就完成这个操作。子查询\n            SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);\n\n        * 子查询不同情况\n            1. 子查询的结果是单行单列的：\n                * 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =\n                * \n                -- 查询员工工资小于平均工资的人\n                SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);\n            2. 子查询的结果是多行单列的：\n                * 子查询可以作为条件，使用运算符in来判断\n                -- 查询&#39;财务部&#39;和&#39;市场部&#39;所有的员工信息\n                SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;;\n                SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;\n                -- 子查询\n                SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;);\n\n            3. 子查询的结果是多行多列的：\n                * 子查询可以作为一张虚拟表参与查询\n                -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息\n                -- 子查询\n                SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &#39;2011-11-11&#39;) t2\n                WHERE t1.id = t2.dept_id;\n                \n                -- 普通内连接\n                SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt;  &#39;2011-11-11&#39;\n\n    * 多表查询练习\n\n            -- 部门表\n            CREATE TABLE dept (\n              id INT PRIMARY KEY PRIMARY KEY, -- 部门id\n              dname VARCHAR(50), -- 部门名称\n              loc VARCHAR(50) -- 部门所在地\n            );\n            \n            -- 添加4个部门\n            INSERT INTO dept(id,dname,loc) VALUES \n            (10,&#39;教研部&#39;,&#39;北京&#39;),\n            (20,&#39;学工部&#39;,&#39;上海&#39;),\n            (30,&#39;销售部&#39;,&#39;广州&#39;),\n            (40,&#39;财务部&#39;,&#39;深圳&#39;);​\t\t\t\t​\t\t\t\t​\t\t\t\t– 职务表，职务名称，职务描述​\t\t\t\tCREATE TABLE job (​\t\t\t\t  id INT PRIMARY KEY,​\t\t\t\t  jname VARCHAR(20),​\t\t\t\t  description VARCHAR(50)​\t\t\t\t);​\t\t\t\t​\t\t\t\t– 添加4个职务​\t\t\t\tINSERT INTO job (id, jname, description) VALUES​\t\t\t\t(1, ‘董事长’, ‘管理整个公司，接单’),​\t\t\t\t(2, ‘经理’, ‘管理部门员工’),​\t\t\t\t(3, ‘销售员’, ‘向客人推销产品’),​\t\t\t\t(4, ‘文员’, ‘使用办公软件’);\n​\t\t\t\t​\t\t\t\t​\t\t\t\t– 员工表​\t\t\t\tCREATE TABLE emp (​\t\t\t\t  id INT PRIMARY KEY, – 员工id​\t\t\t\t  ename VARCHAR(50), – 员工姓名​\t\t\t\t  job_id INT, – 职务id​\t\t\t\t  mgr INT , – 上级领导​\t\t\t\t  joindate DATE, – 入职日期​\t\t\t\t  salary DECIMAL(7,2), – 工资​\t\t\t\t  bonus DECIMAL(7,2), – 奖金​\t\t\t\t  dept_id INT, – 所在部门编号​\t\t\t\t  CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),​\t\t\t\t  CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)​\t\t\t\t);​\t\t\t\t​\t\t\t\t– 添加员工​\t\t\t\tINSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES​\t\t\t\t(1001,’孙悟空’,4,1004,’2000-12-17’,’8000.00’,NULL,20),​\t\t\t\t(1002,’卢俊义’,3,1006,’2001-02-20’,’16000.00’,’3000.00’,30),​\t\t\t\t(1003,’林冲’,3,1006,’2001-02-22’,’12500.00’,’5000.00’,30),​\t\t\t\t(1004,’唐僧’,2,1009,’2001-04-02’,’29750.00’,NULL,20),​\t\t\t\t(1005,’李逵’,4,1006,’2001-09-28’,’12500.00’,’14000.00’,30),​\t\t\t\t(1006,’宋江’,2,1009,’2001-05-01’,’28500.00’,NULL,30),​\t\t\t\t(1007,’刘备’,2,1009,’2001-09-01’,’24500.00’,NULL,10),​\t\t\t\t(1008,’猪八戒’,4,1004,’2007-04-19’,’30000.00’,NULL,20),​\t\t\t\t(1009,’罗贯中’,1,NULL,’2001-11-17’,’50000.00’,NULL,10),​\t\t\t\t(1010,’吴用’,3,1006,’2001-09-08’,’15000.00’,’0.00’,30),​\t\t\t\t(1011,’沙僧’,4,1004,’2007-05-23’,’11000.00’,NULL,20),​\t\t\t\t(1012,’李逵’,4,1006,’2001-12-03’,’9500.00’,NULL,30),​\t\t\t\t(1013,’小白龙’,4,1004,’2001-12-03’,’30000.00’,NULL,20),​\t\t\t\t(1014,’关羽’,4,1007,’2002-01-23’,’13000.00’,NULL,10);\n​\t\t\t\t​\t\t\t\t​\t\t\t\t– 工资等级表​\t\t\t\tCREATE TABLE salarygrade (​\t\t\t\t  grade INT PRIMARY KEY,   – 级别​\t\t\t\t  losalary INT,  – 最低工资​\t\t\t\t  hisalary INT – 最高工资​\t\t\t\t);​\t\t\t\t​\t\t\t\t– 添加5个工资等级​\t\t\t\tINSERT INTO salarygrade(grade,losalary,hisalary) VALUES​\t\t\t\t(1,7000,12000),​\t\t\t\t(2,12010,14000),​\t\t\t\t(3,14010,20000),​\t\t\t\t(4,20010,30000),​\t\t\t\t(5,30010,99990);​\t\t\t\t                – 需求：\ntxt            -- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述\n            /*\n                分析：\n                    1.员工编号，员工姓名，工资，需要查询emp表  职务名称，职务描述 需要查询job表\n                    2.查询条件 emp.job_id = job.id\n            \n            */\n            SELECT \n                t1.`id`, -- 员工编号\n                t1.`ename`, -- 员工姓名\n                t1.`salary`,-- 工资\n                t2.`jname`, -- 职务名称\n                t2.`description` -- 职务描述\n            FROM \n                emp t1, job t2\n            WHERE \n                t1.`job_id` = t2.`id`;​\t\t\t\t​\t\t\t\t​\t\t\t\t– 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置​\t\t\t\t&#x2F;*​\t\t\t\t\t分析：​\t\t\t\t\t\t1. 员工编号，员工姓名，工资 emp  职务名称，职务描述 job  部门名称，部门位置 dept​\t\t\t\t\t\t2. 条件： emp.job_id &#x3D; job.id and emp.dept_id &#x3D; dept.id​\t\t\t\t&#x2F;​\t\t\t\t​\t\t\t\tSELECT​\t\t\t\t\tt1.id, – 员工编号​\t\t\t\t\tt1.ename, – 员工姓名​\t\t\t\t\tt1.salary,– 工资​\t\t\t\t\tt2.jname, – 职务名称​\t\t\t\t\tt2.description, – 职务描述​\t\t\t\t\tt3.dname, – 部门名称​\t\t\t\t\tt3.loc – 部门位置​\t\t\t\tFROM​\t\t\t\t\temp t1, job t2,dept t3​\t\t\t\tWHERE​\t\t\t\t\tt1.job_id &#x3D; t2.id AND t1.dept_id &#x3D; t3.id;​\t\t\t\t                – 3.查询员工姓名，工资，工资等级                &#x2F;                    分析：                        1.员工姓名，工资 emp  工资等级 salarygrade                        2.条件 emp.salary &gt;&#x3D; salarygrade.losalary and emp.salary &lt;&#x3D; salarygrade.hisalary                            emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary                &#x2F;                SELECT                    t1.ename ,                    t1.salary,                    t2.                FROM emp t1, salarygrade t2                WHERE t1.salary BETWEEN t2.losalary AND t2.hisalary;\n​\t\t\t\t​\t\t\t\t​\t\t\t\t– 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级​\t\t\t\t&#x2F;*​\t\t\t\t\t分析：​\t\t\t\t\t\t1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept  工资等级 salarygrade​\t\t\t\t\t\t2. 条件： emp.job_id &#x3D; job.id and emp.dept_id &#x3D; dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary​\t\t\t\t\t\t\t​\t\t\t\t*&#x2F;​\t\t\t\tSELECT​\t\t\t\t\tt1.ename,​\t\t\t\t\tt1.salary,​\t\t\t\t\tt2.jname,​\t\t\t\t\tt2.description,​\t\t\t\t\tt3.dname,​\t\t\t\t\tt3.loc,​\t\t\t\t\tt4.grade​\t\t\t\tFROM​\t\t\t\t\temp t1,job t2,dept t3,salarygrade t4​\t\t\t\tWHERE​\t\t\t\t\tt1.job_id &#x3D; t2.id​\t\t\t\t\tAND t1.dept_id &#x3D; t3.id​\t\t\t\t\tAND t1.salary BETWEEN t4.losalary AND t4.hisalary;\n​\t\t\t\t​\t\t\t\t​\t\t\t\t– 5.查询出部门编号、部门名称、部门位置、部门人数​\t\t\t\t​\t\t\t\t&#x2F;*​\t\t\t\t\t分析：​\t\t\t\t\t\t1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表​\t\t\t\t\t\t2.使用分组查询。按照emp.dept_id完成分组，查询count(id)​\t\t\t\t\t\t3.使用子查询将第2步的查询结果和dept表进行关联查询​\t\t\t\t\t\t                *&#x2F;                SELECT                    t1.id,t1.dname,t1.loc , t2.total                FROM                    dept t1,                    (SELECT                        dept_id,COUNT(id) total                    FROM                        emp                    GROUP BY dept_id) t2                WHERE t1.id &#x3D; t2.dept_id;\n​\t\t\t\t​\t\t\t\t– 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询​\t\t\t\t​\t\t\t\t&#x2F;*​\t\t\t\t\t分析：​\t\t\t\t\t\t1.姓名 emp， 直接上级的姓名 emp​\t\t\t\t\t\t\t* emp表的id 和 mgr 是自关联​\t\t\t\t\t\t2.条件 emp.id &#x3D; emp.mgr​\t\t\t\t\t\t3.查询左表的所有数据，和 交集数据​\t\t\t\t\t\t\t* 使用左外连接查询​\t\t\t\t\t                &#x2F;                &#x2F;                select                    t1.ename,                    t1.mgr,                    t2.id,                    t2.ename                from emp t1, emp t2                where t1.mgr &#x3D; t2.id;\ntxt            */\n            \n            SELECT \n                t1.ename,\n                t1.mgr,\n                t2.`id`,\n                t2.`ename`\n            FROM emp t1\n            LEFT JOIN emp t2\n            ON t1.`mgr` = t2.`id`;事务txt1. 事务的基本介绍\n    1. 概念：\n        *  如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。\n        \n    2. 操作：\n        1. 开启事务： start transaction;\n        2. 回滚：rollback;\n        3. 提交：commit;\n    3. 例子：\n        CREATE TABLE account (\n            id INT PRIMARY KEY AUTO_INCREMENT,\n            NAME VARCHAR(10),\n            balance DOUBLE\n        );\n        -- 添加数据\n        INSERT INTO account (NAME, balance) VALUES (&#39;zhangsan&#39;, 1000), (&#39;lisi&#39;, 1000);​\t\t\t​\t\t\tSELECT * FROM account;​\t\t\tUPDATE account SET balance &#x3D; 1000;​\t\t\t– 张三给李四转账 500 元​\t\t\t​\t\t\t– 0. 开启事务​\t\t\tSTART TRANSACTION;​\t\t\t– 1. 张三账户 -500​\t\t\t            UPDATE account SET balance &#x3D; balance - 500 WHERE NAME &#x3D; ‘zhangsan’;            – 2. 李四账户 +500            – 出错了…            UPDATE account SET balance &#x3D; balance + 500 WHERE NAME &#x3D; ‘lisi’;\ntxt        -- 发现执行没有问题，提交事务\n        COMMIT;\n        \n        -- 发现出问题了，回滚事务\n        ROLLBACK;\n    4. MySQL数据库中事务默认自动提交\n        \n        * 事务提交的两种方式：\n            * 自动提交：\n                * mysql就是自动提交的\n                * 一条DML(增删改)语句会自动提交一次事务。\n            * 手动提交：\n                * Oracle 数据库默认是手动提交事务\n                * 需要先开启事务，再提交\n        * 修改事务的默认提交方式：\n            * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交\n            * 修改默认提交方式： set @@autocommit = 0;\n\n\n2. 事务的四大特征：\n    1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。\n    2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。\n    3. 隔离性：多个事务之间。相互独立。\n    4. 一致性：事务操作前后，数据总量不变\n3. 事务的隔离级别（了解）\n    * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。\n    * 存在问题：\n        1. 脏读：一个事务，读取到另一个事务中没有提交的数据\n        2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。\n        3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。\n    * 隔离级别：\n        1. read uncommitted：读未提交\n            * 产生的问题：脏读、不可重复读、幻读\n        2. read committed：读已提交 （Oracle）\n            * 产生的问题：不可重复读、幻读\n        3. repeatable read：可重复读 （MySQL默认）\n            * 产生的问题：幻读\n        4. serializable：串行化\n            * 可以解决所有的问题\n\n        * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低\n        * 数据库查询隔离级别：\n            * select @@tx_isolation;\n        * 数据库设置隔离级别：\n            * set global transaction isolation level  级别字符串;\n\n    * 演示：\n        set global transaction isolation level read uncommitted;\n        start transaction;\n        -- 转账操作\n        update account set balance = balance - 500 where id = 1;\n        update account set balance = balance + 500 where id = 2;DCL：txt* SQL分类：\n    1. DDL：操作数据库和表\n    2. DML：增删改表中数据\n    3. DQL：查询表中数据\n    4. DCL：管理用户，授权\n\n* DBA：数据库管理员\n\n* DCL：管理用户，授权\n    1. 管理用户\n        1. 添加用户：\n            * 语法：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;\n        2. 删除用户：\n            * 语法：DROP USER &#39;用户名&#39;@&#39;主机名&#39;;\n        3. 修改用户密码：\n            \n            UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;;\n            UPDATE USER SET PASSWORD = PASSWORD(&#39;abc&#39;) WHERE USER = &#39;lisi&#39;;\n            \n            SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD(&#39;新密码&#39;);\n            SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;123&#39;);\n\n            * mysql中忘记了root用户的密码？\n                1. cmd -- &gt; net stop mysql 停止mysql服务\n                    * 需要管理员运行该cmd\n\n                2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables\n                3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功\n                4. use mysql;\n                5. update user set password = password(&#39;你的新密码&#39;) where user = &#39;root&#39;;\n                6. 关闭两个窗口\n                7. 打开任务管理器，手动结束mysqld.exe 的进程\n                8. 启动mysql服务\n                9. 使用新密码登录。\n        4. 查询用户：\n            -- 1. 切换到mysql数据库\n            USE myql;\n            -- 2. 查询user表\n            SELECT * FROM USER;\n            \n            * 通配符： % 表示可以在任意主机使用用户登录数据库\n\n    2. 权限管理：\n        1. 查询权限：\n            -- 查询权限\n            SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;\n            SHOW GRANTS FOR &#39;lisi&#39;@&#39;%&#39;;\n\n        2. 授予权限：\n            -- 授予权限\n            grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;\n            -- 给张三用户授予所有权限，在任意数据库任意表上\n            \n            GRANT ALL ON *.* TO &#39;zhangsan&#39;@&#39;localhost&#39;;\n        3. 撤销权限：\n            -- 撤销权限：\n            revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;\n            REVOKE UPDATE ON db3.`account` FROM &#39;lisi&#39;@&#39;%&#39;;","slug":"2-DQL多表查询、事务、DCL(管理用户和授权)","date":"2024-05-01T11:43:02.714Z","categories_index":"mysql","tags_index":"mysql","author_index":"Vegetabhl"},{"id":"a9163eccc7214878855118492d210e14","title":"1-MySQL数据库软件配置、DDL、DML、DQL(部分)","content":"1-MySQL数据库软件配置、DDL、DML、DQL(部分)\n数据库的基本概念\n\nMySQL数据库软件\n\n安装\n卸载\n配置\n\n\nSQL\n\n\n数据库的基本概念txt1. 数据库的英文单词： DataBase 简称 ： DB\n2. 什么数据库？\n    * 用于存储和管理数据的仓库。\n\n3. 数据库的特点：\n    1. 持久化存储数据的。其实数据库就是一个文件系统\n    2. 方便存储和管理数据\n    3. 使用了统一的方式操作数据库 -- SQL​\t​\t4. 常见的数据库软件​\t\t* 参见《MySQL基础.pdf》\nMySQL数据库软件txt1. 安装\n    * 参见《MySQL基础.pdf》\n2. 卸载\n    1. 去mysql的安装目录找到my.ini文件\n        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;\n    2. 卸载MySQL\n    3. 删除C:/ProgramData目录下的MySQL文件夹。\n    \n3. 配置\n    * MySQL服务启动\n        1. 手动。\n        2. cmd--&gt; services.msc 打开服务的窗口\n        3. 使用管理员打开cmd\n            * net start mysql : 启动mysql的服务\n            * net stop mysql:关闭mysql服务\n    * MySQL登录\n        1. mysql -uroot -p密码\n        2. mysql -hip -uroot -p连接目标的密码\n        3. mysql --host=ip --user=root --password=连接目标的密码\n    * MySQL退出\n        1. exit\n        2. quit\n\n    * MySQL目录结构\n        1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;\n            * 配置文件 my.ini\n        2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;\n            * 几个概念\n                * 数据库：文件夹\n                * 表：文件\n                * 数据：数据SQLtxt1.什么是SQL？\n    Structured Query Language：结构化查询语言\n    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。\n    \n2.SQL通用语法\n    1. SQL 语句可以单行或多行书写，以分号结尾。\n    2. 可使用空格和缩进来增强语句的可读性。\n    3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。\n    4. 3 种注释\n        * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) \n        * 多行注释: /* 注释 */\n    \n3. SQL分类\n    1) DDL(Data Definition Language)数据定义语言\n        用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等\n    2) DML(Data Manipulation Language)数据操作语言\n        用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等\n    3) DQL(Data Query Language)数据查询语言\n        用来查询数据库中表的记录(数据)。关键字：select, where 等\n    4) DCL(Data Control Language)数据控制语言(了解)\n        用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等DDL:操作数据库、表txt1. 操作数据库：CRUD\n    1. C(Create):创建\n        * 创建数据库：\n            * create database 数据库名称;\n        * 创建数据库，判断不存在，再创建：\n            * create database if not exists 数据库名称;\n        * 创建数据库，并指定字符集\n            * create database 数据库名称 character set 字符集名;\n\n        * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk\n            * create database if not exists db4 character set gbk;\n    2. R(Retrieve)：查询\n        * 查询所有数据库的名称:\n            * show databases;\n        * 查询某个数据库的字符集:查询某个数据库的创建语句\n            * show create database 数据库名称;\n    3. U(Update):修改\n        * 修改数据库的字符集\n            * alter database 数据库名称 character set 字符集名称;\n    4. D(Delete):删除\n        * 删除数据库\n            * drop database 数据库名称;\n        * 判断数据库存在，存在再删除\n            * drop database if exists 数据库名称;\n    5. 使用数据库\n        * 查询当前正在使用的数据库名称\n            * select database();\n        * 使用数据库\n            * use 数据库名称;\n\n\n2. 操作表\n    1. C(Create):创建\n        1. 语法：\n            create table 表名(\n                列名1 数据类型1,\n                列名2 数据类型2,\n                ....\n                列名n 数据类型n\n            );\n            * 注意：最后一列，不需要加逗号（,）\n            * 数据库类型：\n                1. int：整数类型\n                    * age int,\n                2. double:小数类型\n                    * score double(5,2)\n                3. date:日期，只包含年月日，yyyy-MM-dd\n                4. datetime:日期，包含年月日时分秒\t yyyy-MM-dd HH:mm:ss\n                5. timestamp:时间错类型\t包含年月日时分秒\t yyyy-MM-dd HH:mm:ss\t\n                    * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值\n\n                6. varchar：字符串\n                    * name varchar(20):姓名最大20个字符\n                    * zhangsan 8个字符  张三 2个字符\n\n\n        * 创建表\n            create table student(\n                id int,\n                name varchar(32),\n                age int ,\n                score double(4,1),\n                birthday date,\n                insert_time timestamp\n            );\n        * 复制表：\n            * create table 表名 like 被复制的表名;\t  \t\n    2. R(Retrieve)：查询\n        * 查询某个数据库中所有的表名称\n            * show tables;\n        * 查询表结构\n            * desc 表名;\n    3. U(Update):修改\n        1. 修改表名\n            alter table 表名 rename to 新的表名;\n        2. 修改表的字符集\n            alter table 表名 character set 字符集名称;\n        3. 添加一列\n            alter table 表名 add 列名 数据类型;\n        4. 修改列名称 类型\n            alter table 表名 change 列名 新列别 新数据类型;\n            alter table 表名 modify 列名 新数据类型;\n        5. 删除列\n            alter table 表名 drop 列名;\n    4. D(Delete):删除\n        * drop table 表名;\n        * drop table  if exists 表名 ;\n客户端图形化工具：SQLYog\n\nDML：增删改表中数据txt1. 添加数据：\n    * 语法：\n        * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);\n    * 注意：\n        1. 列名和值要一一对应。\n        2. 如果表名后，不定义列名，则默认给所有列添加值\n            insert into 表名 values(值1,值2,...值n);\n        3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来\n2. 删除数据：\n    * 语法：\n        * delete from 表名 [where 条件]\n    * 注意：\n        1. 如果不加条件，则删除表中所有记录。\n        2. 如果要删除所有记录\n            1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作\n            2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。\n3. 修改数据：\n    * 语法：\n        * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];\n\n    * 注意：\n        1. 如果不加任何条件，则会将表中所有记录全部修改。DQL：查询表中的记录txt* select * from 表名;\n\n1. 语法：\n    select\n        字段列表\n    from\n        表名列表\n    where\n        条件列表\n    group by\n        分组字段\n    having\n        分组之后的条件\n    order by\n        排序\n    limit\n        分页限定\n\n\n2. 基础查询\n    1. 多个字段的查询\n        select 字段名1，字段名2... from 表名；\n        * 注意：\n            * 如果查询所有字段，则可以使用*来替代字段列表。\n    2. 去除重复：\n        * distinct\n    3. 计算列\n        * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）\n        * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null\n            * 表达式1：哪个字段需要判断是否为null\n            * 如果该字段为null后的替换值。\n    4. 起别名：\n        * as：as也可以省略\n\n\n3. 条件查询\n    1. where子句后跟条件\n    2. 运算符\n        * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;\n        * BETWEEN...AND  \n        * IN( 集合) \n        * LIKE：模糊查询\n            * 占位符：\n                * _:单个任意字符\n                * %：多个任意字符\n        * IS NULL  \n        * and  或 &amp;&amp;\n        * or  或 || \n        * not  或 !\n        \n            -- 查询年龄大于20岁\n\n            SELECT * FROM student WHERE age &gt; 20;\n            \n            SELECT * FROM student WHERE age &gt;= 20;\n            \n            -- 查询年龄等于20岁\n            SELECT * FROM student WHERE age = 20;\n            \n            -- 查询年龄不等于20岁\n            SELECT * FROM student WHERE age != 20;\n            SELECT * FROM student WHERE age &lt;&gt; 20;\n            \n            -- 查询年龄大于等于20 小于等于30\n            \n            SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;\n            SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;\n            SELECT * FROM student WHERE age BETWEEN 20 AND 30;\n            \n            -- 查询年龄22岁，18岁，25岁的信息\n            SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25\n            SELECT * FROM student WHERE age IN (22,18,25);\n            \n            -- 查询英语成绩为null\n            SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断\n            \n            SELECT * FROM student WHERE english IS NULL;\n            \n            -- 查询英语成绩不为null\n            SELECT * FROM student WHERE english  IS NOT NULL;\n\n\n\n            -- 查询姓马的有哪些？ like\n            SELECT * FROM student WHERE NAME LIKE &#39;马%&#39;;\n            -- 查询姓名第二个字是化的人\n            \n            SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;\n            \n            -- 查询姓名是3个字的人\n            SELECT * FROM student WHERE NAME LIKE &#39;___&#39;;​\t\t\t\t​\t\t\t\t– 查询姓名中包含德的人​\t\t\t\tSELECT * FROM student WHERE NAME LIKE ‘%德%’;\n","slug":"1-MySQL数据库软件配置、DDL、DML、DQL(部分)","date":"2024-05-01T11:43:02.713Z","categories_index":"mysql","tags_index":"mysql","author_index":"Vegetabhl"},{"id":"81579b6c641dedc829a2b0058112fc0c","title":"数据结构","content":"数据结构1 数据结构包含线性表和非线性表两部分，其中：1.1 线性表包含以下几种常见的数据结构：线性表（Linear List）是一种线性数据结构，它由一系列具有相同数据类型的元素组成，元素之间一对一地排列，形成一条直线。线性表中的元素可以通过位置（索引）来访问，而且元素的顺序是固定的。线性表的主要目的是提供一种方便的方式来存储和访问一系列元素。\n线性表包含以下几种常见的数据结构：\n\n数组（Array）：\n数组是一种固定大小的数据结构，它可以存储具有相同数据类型的元素。\n数组中的元素通过索引来访问，索引通常从0开始。\n数组的优点是访问元素的时间复杂度为O(1)，但它的缺点是大小固定，插入和删除操作可能需要移动其他元素。\n\n\n链表（Linked List）：\n链表是由一系列节点组成的动态数据结构，每个节点包含数据部分和指向下一个节点的指针。\n链表的优点是大小动态，插入和删除操作相对高效，但访问特定元素的时间复杂度为O(n)。\n链表有多种形式，如单向链表、双向链表和循环链表。\n\n\n栈（Stack）：\n栈是一种后进先出（LIFO）的数据结构，它允许在一端（栈顶）进行插入和删除操作。\n栈可以用于解决许多问题，如递归算法、括号匹配、逆序输出等。\n\n\n队列（Queue）：\n队列是一种先进先出（FIFO）的数据结构，它允许在一端（队尾）进行插入操作，在另一端（队首）进行删除操作。\n队列常用于任务调度、缓冲处理等场景。\n\n\n向量（Vector）：\n向量是数组的抽象，它是一种动态数组，可以根据需要自动调整大小。\n向量提供了比普通数组更多的功能，如自动扩容、插入和删除操作。\n\n\n列表（List）：\n列表是一种抽象数据类型，它可以看作是链表的另一种称呼，或者是一种更通用的线性表，不特指某一种具体实现。\n列表可以是数组的抽象，也可以是链表的抽象，具体实现取决于编程语言或库。\n\n\n\n这些数据结构都遵循线性表的特性，即元素之间是一对一的关系，并且可以通过位置来访问。不同类型的线性表适用于不同的应用场景，选择合适的数据结构可以提高程序的性能和效率。\n1.2 非线性表包含以下几种常见的数据结构：非线性表（Non-linear lists）是指数据元素之间存在多对多关系的数据结构，这与线性表（如数组、链表、栈和队列）形成对比，其中数据元素之间是一对一的关系。非线性表包括多种复杂的数据结构，用于存储和表示具有层次或网状关系的数据集合。以下是一些常见的非线性数据结构：\n\n树（Tree）：\n树是一种层次化的数据结构，由节点组成，其中一个节点被指定为根节点，其余节点分为若干个子树。\n每个节点可以有多个子节点，但只有一个父节点（根节点没有父节点）。\n树用于表示具有层次关系的数据，如文件系统的目录结构、组织的层级结构等。\n\n\n二叉树（Binary Tree）：\n二叉树是一种特殊的树，其中每个节点最多有两个子节点，分别为左子节点和右子节点。\n二叉树有多种特殊形式，如二叉搜索树（Binary Search Tree）、平衡二叉树（AVL Tree）、红黑树等。\n\n\n图（Graph）：\n图是由顶点（节点）集合和边集合组成的数据结构，用于表示顶点之间的多对多关系。\n图可以是无向的，也可以是有向的，边可以带有权重。\n图用于模拟网络结构、社交关系、地图等复杂系统的交互和连接。\n\n\n堆（Heap）：\n堆是一种特殊的完全二叉树，它满足堆属性，即父节点的键值总是大于或小于（取决于最大堆或最小堆）其子节点的键值。\n堆通常用于实现优先队列，以及排序算法如堆排序。\n\n\n散列表（Hash Table）：\n散列表是一种基于散列函数的数据结构，它支持快速的查找、插入和删除操作。\n散列表通过散列函数将键映射到数组的位置，以存储和检索数据元素。\n虽然散列表在逻辑上可以看作是线性表，但由于其内部结构的复杂性，通常被认为是非线性数据结构。\n\n\n多维数组（Multi-dimensional Array）：\n多维数组是数组的扩展，它可以看作是数组的数组，用于表示具有多个维度结构的数据。\n多维数组用于存储表格数据、图像像素等。\n\n\n\n这些非线性数据结构在计算机科学中有着广泛的应用，它们用于解决各种复杂问题，如图的遍历、最短路径算法、网络流问题、搜索算法等。非线性数据结构的选择和实现取决于特定应用场景的需求和性能要求。\n\n2 存储结构主要包含两种，顺序存储结构和链式存储结构线性表和非线性表的存储结构有所不同，主要表现在它们在内存中的布局和对数据的访问方式上。\n2.1 线性表的存储结构：\n顺序存储结构：\n顺序存储结构是使用连续的内存空间来存储数据元素。\n例如，数组就是一种顺序存储结构，元素在内存中连续存放，可以通过索引直接访问。\n顺序存储结构的优点是访问速度快，时间复杂度为O(1)，但插入和删除操作可能需要移动大量元素，时间复杂度为O(n)。\n\n\n链式存储结构：\n链式存储结构使用节点来存储数据元素，每个节点包含数据部分和指向下一个节点的指针。\n例如，链表就是一种链式存储结构，元素可以分散存储在内存中，通过指针连接。\n链式存储结构的优点是插入和删除操作效率高，只需改变指针的指向，时间复杂度为O(1)，但访问特定元素需要从头节点开始遍历，时间复杂度为O(n)。\n\n\n\n2.2 非线性表的存储结构：\n链式存储结构：\n树和图等非线性结构通常使用链式存储结构，每个节点包含数据部分和指向其子节点或相邻节点的指针。\n例如，二叉树中的每个节点可能包含数据、左子节点指针和右子节点指针。\n图的存储结构可能更加复杂，可以使用邻接矩阵或邻接表来实现。\n\n\n多重链式存储结构：\n对于一些复杂的非线性结构，如多维数组、广义表等，可能需要使用多重链式存储结构。\n这种结构中的节点可能包含多个指针，指向不同的相关节点。\n\n\n索引存储结构：\n索引存储结构是在链式存储结构的基础上增加索引表，用于提高访问效率。\n索引表存储了节点地址或位置信息，可以快速定位到特定节点。\n\n\n散列存储结构：\n散列存储结构使用散列函数将数据元素映射到存储地址。\n散列表（哈希表）是一种常见的散列存储结构，它通过散列函数处理键值，将数据存储在数组中的特定位置。\n\n\n\n非线性表的存储结构通常比线性表更加复杂，因为它们需要能够表示数据元素之间的多对多关系。选择合适的存储结构对于非线性数据结构的性能和效率至关重要。\n\n3 线性表和非线性表的不同存储结构，时间复杂度分别是多少？3.1 线性表的不同存储结构主要影响数据的插入、删除和访问操作的时间复杂度。以下是几种常见的线性表存储结构及其时间复杂度：\n数组（Array） - 顺序存储结构：\n插入操作：平均情况为O(n)，因为可能需要移动其他元素来为新元素腾出空间。\n删除操作：平均情况为O(n)，同样可能需要移动元素来填充被删除元素的位置。\n访问操作：O(1)，通过索引直接访问。\n\n\n链表（Linked List） - 链式存储结构：\n单链表：\n插入操作：O(1)，只需改变指针的指向。\n删除操作：O(1)，只需改变指针的指向。\n访问操作：O(n)，需要从头节点开始遍历。\n\n\n双向链表：\n插入操作：O(1)，需要改变两个指针的指向。\n删除操作：O(1)，需要改变两个指针的指向。\n访问操作：O(n)，需要从头节点或尾节点开始遍历。\n\n\n\n\n栈（Stack） - 顺序或链式存储结构：\n插入（push）操作：O(1)，无论是数组还是链表实现。\n删除（pop）操作：O(1)，无论是数组还是链表实现。\n访问（peek）操作：O(1)，无论是数组还是链表实现。\n\n\n队列（Queue） - 顺序或链式存储结构：\n插入（enqueue）操作：O(1)，无论是数组还是链表实现。\n删除（dequeue）操作：O(1)，无论是数组还是链表实现。\n访问操作：O(1)，对于双端队列（Deque），无论是数组还是链表实现。\n\n\n向量（Vector） - 动态数组：\n插入操作：平均情况为O(n)，因为可能需要扩容和移动元素。\n删除操作：平均情况为O(n)，因为可能需要移动元素来填充被删除元素的位置。\n访问操作：O(1)，通过索引直接访问。\n\n\n列表（List） - 抽象数据类型：\n插入、删除和访问操作的时间复杂度取决于具体的实现方式。例如，如果列表是基于数组的，则与数组的复杂度相同；如果基于链表，则与链表的复杂度相同。\n\n\n\n3.2 非线性表的存储结构通常比线性表更为复杂，因为它们需要能够表示数据元素之间的多对多关系。以下是一些常见的非线性表及其存储结构的时间复杂度：\n树（Tree）：\n存储结构：通常使用链式存储结构，每个节点包含数据部分和指向其子节点的指针。\n搜索操作：平均情况下，二叉搜索树（BST）的搜索、插入和删除操作的时间复杂度为O(log n)，但在最坏情况下（树高度不平衡）可能退化为O(n)。\n平衡树（如AVL树、红黑树）可以保证操作的最坏情况时间复杂度为O(log n)。\n\n\n图（Graph）：\n存储结构：可以使用邻接矩阵或邻接表。\n邻接矩阵：空间复杂度为O(V^2)，其中V是顶点数。访问任意两个顶点的关系时间复杂度为O(1)，但空间复杂度较高，不适合存储稀疏图。\n邻接表：空间复杂度为O(V+E)，其中E是边数。访问相邻顶点的时间复杂度为O(1)，但访问所有顶点的时间复杂度为O(V)。\n\n\n堆（Heap）：\n存储结构：通常使用数组来实现，可以看作是一种特殊的完全二叉树。\n插入操作：O(log n)\n删除操作：O(log n)\n构建堆操作：O(n)\n查找最大或最小元素操作：O(1)\n\n\n散列表（Hash Table）：\n存储结构：使用数组加上散列函数。\n插入、删除和查找操作的平均时间复杂度为O(1)，但在最坏情况下可能退化为O(n)，这通常发生在发生大量散列冲突时。\n\n\n多维数组（Multi-dimensional Array）：\n存储结构：可以使用顺序存储结构，元素在内存中连续存放。\n访问操作：O(1)，通过多维索引直接访问。\n插入和删除操作可能需要移动其他元素，时间复杂度为O(m)，其中m是受影响的元素数量。\n\n\n\n非线性表的存储结构的选择和实现取决于特定应用场景的需求和性能要求。例如，如果需要频繁的搜索操作，可能会选择平衡树；如果需要表示复杂的关系网络，可能会选择图结构。\n","slug":"数据结构","date":"2024-05-01T11:43:02.711Z","categories_index":"数据结构","tags_index":"数据结构","author_index":"Vegetabhl"},{"id":"aa9f0512d6daaaffe3d2e865e38ea95e","title":"如果让我来设计网络","content":"你是****一台电脑，你的名字叫 A  \n很久很久之前，你不与任何其他电脑相连接，孤苦伶仃。\n\n直到有一天，你希望与另一台电脑 B 建立通信，于是你们各开了一个网口，用一根网线连接了起来。  \n\n用一根网线连接起来怎么就能 “通信” 了呢？我可以给你讲 IO、讲中断、讲缓冲区，但这不是研究网络时该关心的问题。\n如果你纠结，要么去研究一下操作系统是如何处理网络 IO 的，要么去研究一下包是如何被网卡转换成电信号发送出去的，要么就仅仅把它当做电脑里有个小人在开枪吧~  \n\n反正，你们就是连起来了，并且可以通信。\n第一层\n有一天，一个新伙伴 C 加入了，但聪明的你们很快发现，可以每个人开两个网口，用一共三根网线，彼此相连。  \n\n随着越来越多的人加入，你发现身上开的网口实在太多了，而且网线密密麻麻，混乱不堪。（而实际上一台电脑根本开不了这么多网口，所以这种连线只在理论上可行，所以连不上的我就用红色虚线表示了，就是这么严谨哈哈~）  \n\n于是你们发明了一个中间设备，你们将网线都插到这个设备上，由这个设备做转发，就可以彼此之间通信了，本质上和原来一样，只不过网口的数量和网线的数量减少了，不再那么混乱。  \n\n你给它取名叫集线器，它仅仅是无脑将电信号转发到所有出口（广播），不做任何处理，你觉得它是没有智商的，因此把人家定性在了物理层。  \n\n由于转发到了所有出口，那 BCDE 四台机器怎么知道数据包是不是发给自己的呢？  \n首先，你要给所有的连接到集线器的设备，都起个名字。原来你们叫 ABCD，但现在需要一个更专业的，全局唯一的名字作为标识，你把这个更高端的名字称为 MAC 地址。\n你的 MAC 地址是 aa-aa-aa-aa-aa-aa，你的伙伴 b 的 MAC 地址是 bb-bb-bb-bb-bb-bb，以此类推，不重复就好。\n这样，A 在发送数据包给 B 时，只要在头部拼接一个这样结构的数据，就可以了。  \n\nB 在收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包的确是发给自己的，于是便收下。  \n其他的 CDE 收到数据包后，根据头部的目标 MAC 地址信息，判断这个数据包并不是发给自己的，于是便丢弃。\n\n虽然集线器使整个布局干净不少，但原来我只要发给电脑 B 的消息，现在却要发给连接到集线器中的所有电脑，这样既不安全，又不节省网络资源。\n第二层\n如果把这个集线器弄得更智能一些，只发给目标 MAC 地址指向的那台电脑，就好了。  \n\n虽然只比集线器多了这一点点区别，但看起来似乎有智能了，你把这东西叫做交换机。也正因为这一点点智能，你把它放在了另一个层级，数据链路层。  \n\n如上图所示，你是这样设计的。\n交换机内部维护一张 MAC 地址表，记录着每一个 MAC 地址的设备，连接在其哪一个端口上。  \nMAC 地址端口bb-bb-bb-bb-bb-bb1cc-cc-cc-cc-cc-cc3aa-aa-aa-aa-aa-aa4dd-dd-dd-dd-dd-dd5\n\n假如你仍然要发给 B 一个数据包，构造了如下的数据结构从网口出去。\n\n到达交换机时，交换机内部通过自己维护的 MAC 地址表，发现目标机器 B 的 MAC 地址 bb-bb-bb-bb-bb-bb 映射到了端口 1 上，于是把数据从 1 号端口发给了 B，完事~  \n你给这个通过这样传输方式而组成的小范围的网络，叫做以太网。\n当然最开始的时候，MAC 地址表是空的，是怎么逐步建立起来的呢？  \n假如在 MAC 地址表为空是，你给 B 发送了如下数据  \n\n由于这个包从端口 4 进入的交换机，所以此时交换机就可以在 MAC 地址表记录第一条数据：  \nMAC：aa-aa-aa-aa-aa-aa-aa端口：4  \n交换机看目标 MAC 地址（bb-bb-bb-bb-bb-bb）在地址表中并没有映射关系，于是将此包发给了所有端口，也即发给了所有机器。  \n之后，只有机器 B 收到了确实是发给自己的包，于是做出了响应，响应数据从端口 1 进入交换机，于是交换机此时在地址表中更新了第二条数据：  \nMAC：bb-bb-bb-bb-bb-bb端口：1\n过程如下\n\n经过该网络中的机器不断地通信，交换机最终将 MAC 地址表建立完毕~\n\n随着机器数量越多，交换机的端口也不够了，但聪明的你发现，只要将多个交换机连接起来，这个问题就轻而易举搞定~  \n\n你完全不需要设计额外的东西，只需要按照之前的设计和规矩来，按照上述的接线方式即可完成所有电脑的互联，所以交换机设计的这种规则，真的很巧妙。你想想看为什么（比如 A 要发数据给 F）。  \n但是你要注意，上面那根红色的线，最终在 MAC 地址表中可不是一条记录呀，而是要把 EFGH 这四台机器与该端口（端口 6）的映射全部记录在表中。  \n最终，两个交换机将分别记录 A ~ H 所有机器的映射记录。\n左边的交换机  \nMAC 地址端口bb-bb-bb-bb-bb-bb1cc-cc-cc-cc-cc-cc3aa-aa-aa-aa-aa-aa4dd-dd-dd-dd-dd-dd5ee-ee-ee-ee-ee-ee6ff-ff-ff-ff-ff-ff6gg-gg-gg-gg-gg-gg6hh-hh-hh-hh-hh-hh6\n\n右边的交换机  \nMAC 地址端口bb-bb-bb-bb-bb-bb1cc-cc-cc-cc-cc-cc1aa-aa-aa-aa-aa-aa1dd-dd-dd-dd-dd-dd1ee-ee-ee-ee-ee-ee2ff-ff-ff-ff-ff-ff3gg-gg-gg-gg-gg-gg4hh-hh-hh-hh-hh-hh6\n\n这在只有 8 台电脑的时候还好，甚至在只有几百台电脑的时候，都还好，所以这种交换机的设计方式，已经足足支撑一阵子了。  \n但很遗憾，人是贪婪的动物，很快，电脑的数量就发展到几千、几万、几十万。\n第三层\n交换机已经无法记录如此庞大的映射关系了。  \n此时你动了歪脑筋，你发现了问题的根本在于，连出去的那根红色的网线，后面不知道有多少个设备不断地连接进来，从而使得地址表越来越大。\n那我可不可以让那根红色的网线，接入一个新的设备，这个设备就跟电脑一样有自己独立的 MAC 地址，而且同时还能帮我把数据包做一次转发呢？\n这个设备就是路由器，它的功能就是，作为一台独立的拥有 MAC 地址的设备，并且可以帮我把数据包做一次转发，你把它定在了网络层。  \n\n注意，路由器的每一个端口，都有独立的 MAC 地址  \n好了，现在交换机的 MAC 地址表中，只需要多出一条 MAC 地址 ABAB 与其端口的映射关系，就可以成功把数据包转交给路由器了，这条搞定。\n那如何做到，把发送给 C 和 D，甚至是把发送给 DEFGH…. 的数据包，统统先发送给路由器呢？  \n不难想到这样一个点子，假如电脑 C 和 D 的 MAC 地址拥有共同的前缀，比如分别是  \n**C 的 MAC 地址：FFFF-FFFF-CCCC**\nD 的 MAC 地址：FFFF-FFFF-DDDD\n那我们就可以说，将目标 MAC 地址为 FFFF-FFFF-？开头的，统统先发送给路由器。  \n这样是否可行呢？答案是否定的。  \n我们先从现实中 MAC 地址的结构入手，MAC 地址也叫物理地址、硬件地址，长度为 48 位，一般这样来表示\n00-16-EA-AE-3C-40\n它是由网络设备制造商生产时烧录在网卡的 EPROM（一种闪存芯片，通常可以通过程序擦写）。其中前 24 位（00-16-EA）代表网络硬件制造商的编号****，后 24 位（AE-3C-40）是该厂家自己分配的，一般表示系列号。只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。形象地说，MAC 地址就如同身份证上的身份证号码，具有唯一性。\n那如果你希望向上面那样表示将目标 MAC 地址为 FFFF-FFFF-？开头的，统一从路由器出去发给某一群设备（后面会提到这其实是子网的概念），那你就需要要求某一子网下统统买一个厂商制造的设备，要么你就需要要求厂商在生产网络设备烧录 MAC 地址时，提前按照你规划好的子网结构来定 MAC 地址，并且日后这个网络的结构都不能轻易改变。\n这显然是不现实的。\n于是你发明了一个新的地址，给每一台机器一个 32 位的编号，如：  \n11000000101010000000000000000001\n你觉得有些不清晰，于是把它分成四个部分，中间用点相连。  \n11000000.10101000.00000000.00000001\n你还觉得不清晰，于是把它转换成 10 进制。  \n192.168.0.1\n最后你给了这个地址一个响亮的名字，IP 地址。现在每一台电脑，同时有自己的 MAC 地址，又有自己的 IP 地址，只不过 IP 地址是软件层面上的，可以随时修改，MAC 地址一般是无法修改的。\n这样一个可以随时修改的 IP 地址，就可以根据你规划的网络拓扑结构，来调整了。\n\n如上图所示，假如我想要发送数据包给 ABCD 其中一台设备，不论哪一台，我都可以这样描述，**”将 IP 地址为 192.168.0 开头的全部发送给到路由器，之后再怎么转发，交给它！”**，巧妙吧。\n那交给路由器之后，路由器又是怎么把数据包准确转发给指定设备的呢？\n别急我们慢慢来。  \n我们先给上面的组网方式中的每一台设备，加上自己的 IP 地址\n\n现在两个设备之间传输，除了加上数据链路层的头部之外，还要再增加一个网络层的头部。  \n假如 A 给 B 发送数据，由于它们直接连着交换机，所以 A 直接发出如下数据包即可，其实网络层没有体现出作用。\n\n但假如 A 给 C 发送数据，A 就需要先转交给路由器，然后再由路由器转交给 C。由于最底层的传输仍然需要依赖以太网，所以数据包是分成两段的。  \nA ~ 路由器这段的包如下：  \n\n路由器到 C 这段的包如下：  \n\n好了，上面说的两种情况（A-&gt;B，A-&gt;C），相信细心的读者应该会有不少疑问，下面我们一个个来展开。  \nA 给 C 发数据包，怎么知道是否要通过路由器转发呢？\n\n答案：子网  \n如果源 IP 与目的 IP 处于一个子网，直接将包通过交换机发出去。  \n如果源 IP 与目的 IP 不处于一个子网，就交给路由器去处理。\n好，那现在只需要解决，什么叫处于一个子网就好了。  \n\n192.168.0.1 和 192.168.0.2 处于同一个子网\n\n192.168.0.1 和 192.168.1.1 处于不同子网\n\n\n这两个是我们人为规定的，即我们想表示，对于 192.168.0.1 来说：\n192.168.0.xxx 开头的，就算是在一个子网，否则就是在不同的子网。\n那对于计算机来说，怎么表达这个意思呢？于是人们发明了子网掩码的概念  \n假如某台机器的子网掩码定为 255.255.255.0  \n这表示，将源 IP 与目的 IP 分别同这个子网掩码进行与运算****，相等则是在一个子网，不相等就是在不同子网，就这么简单。  \n比如  \n\nA 电脑：192.168.0.1 &amp; 255.255.255.0 &#x3D; 192.168.0.0  \n\nB 电脑：192.168.0.2 &amp; 255.255.255.0 &#x3D; 192.168.0.0\n\nC 电脑：192.168.1.1 &amp; 255.255.255.0 &#x3D; 192.168.1.0\n\nD 电脑：192.168.1.2 &amp; 255.255.255.0 &#x3D; 192.168.1.0\n\n\n那么 A 与 B 在同一个子网，C 与 D 在同一个子网，但是 A 与 C 就不在同一个子网，与 D 也不在同一个子网，以此类推。\n\n所以如果 A 给 C 发消息，A 和 C 的 IP 地址分别 &amp; A 机器配置的子网掩码，发现不相等，则 A 认为 C 和自己不在同一个子网，于是把包发给路由器，就不管了，之后怎么转发，A 不关心。\nA 如何知道，哪个设备是路由器？\n\n答案：在 A 上要设置默认网关  \n上一步 A 通过是否与 C 在同一个子网内，判断出自己应该把包发给路由器，那路由器的 IP 是多少呢？  \n其实说发给路由器不准确，应该说 A 会把包发给默认网关。\n对 A 来说，A 只能直接把包发给同处于一个子网下的某个 IP 上，所以发给路由器还是发给某个电脑，对 A 来说也不关心，只要这个设备有个 IP 地址就行。\n所以默认网关，就是 A 在自己电脑里配置的一个 IP 地址，以便在发给不同子网的机器时，发给这个 IP 地址。\n\n仅此而已！\n路由器如何知道 C 在哪里？\n\n答案：路由表  \n现在 A 要给 C 发数据包，已经可以成功发到路由器这里了，最后一个问题就是，路由器怎么知道，收到的这个数据包，该从自己的哪个端口出去，才能直接（或间接）地最终到达目的地 C 呢。\n路由器收到的数据包有目的 IP 也就是 C 的 IP 地址，需要转化成从自己的哪个端口出去，很容易想到，应该有个表，就像 MAC 地址表一样。  \n这个表就叫路由表。\n至于这个路由表是怎么出来的，有很多路由算法，本文不展开，因为我也不会哈哈~\n不同于 MAC 地址表的是，路由表并不是一对一这种明确关系，我们下面看一个路由表的结构。  \n目的地址子网掩码下一跳端口192.168.0.0255.255.255.00192.168.0.254255.255.255.2550192.168.1.0255.255.255.01192.168.1.254255.255.255.2551\n\n我们学习一种新的表示方法，由于子网掩码其实就表示前多少位表示子网的网段，所以如 192.168.0.0（255.255.255.0） 也可以简写为 192.168.0.0&#x2F;24\n目的地址下一跳端口192.168.0.0/240192.168.0.254/320192.168.1.0/241192.168.1.254/321\n\n这就很好理解了，路由表就表示，192.168.0.xxx 这个子网下的，都转发到 0 号端口，192.168.1.xxx 这个子网下的，都转发到 1 号端口。下一跳列还没有值，我们先不管\n配合着结构图来看（这里把子网掩码和默认网关都补齐了）图中 &amp; 笔误，结果应该是 .0\n\n刚才说的都是 IP 层，但发送数据包的数据链路层需要知道 MAC 地址，可是我只知道 IP 地址该怎么办呢？\n\n答案：arp\n假如你（A）此时不知道你同伴 B 的 MAC 地址（现实中就是不知道的，刚刚我们只是假设已知），你只知道它的 IP 地址，你该怎么把数据包准确传给 B 呢？\n答案很简单，在网络层，我需要把 IP 地址对应的 MAC 地址找到，也就是通过某种方式，找到 192.168.0.2 对应的 MAC 地址 BBBB。\n这种方式就是 arp 协议，同时电脑 A 和 B 里面也会有一张 arp 缓存表，表中记录着 IP 与 MAC 地址的对应关系。  \nIP 地址MAC 地址192.168.0.2BBBB\n\n一开始的时候这个表是空的，电脑 A 为了知道电脑 B（192.168.0.2）的 MAC 地址，将会广播一条 arp 请求，B 收到请求后，带上自己的 MAC 地址给 A 一个响应。此时 A 便更新了自己的 arp 表。\n这样通过大家不断广播 arp 请求，最终所有电脑里面都将 arp 缓存表更新完整。\n总结一下\n好了，总结一下，到目前为止就几条规则\n从各个节点的视角来看  \n电脑视角****：\n\n首先我要知道我的 IP 以及对方的 IP\n\n通过子网掩码判断我们是否在同一个子网\n\n在同一个子网就通过 arp 获取对方 mac 地址直接扔出去\n\n不在同一个子网就通过 arp 获取默认网关的 mac 地址直接扔出去\n\n\n交换机视角：  \n\n我收到的数据包必须有目标 MAC 地址\n\n通过 MAC 地址表查映射关系\n\n查到了就按照映射关系从我的指定端口发出去\n\n查不到就所有端口都发出去\n\n\n路由器视角：\n\n我收到的数据包必须有目标 IP 地址\n\n通过路由表查映射关系\n\n查到了就按照映射关系从我的指定端口发出去（不在任何一个子网范围，走其路由器的默认网关也是查到了）\n\n查不到则返回一个路由不可达的数据包\n\n\n如果你嗅觉足够敏锐，你应该可以感受到下面这句话：\n网络层（IP 协议）本身没有传输包的功能，包的实际传输是委托给数据链路层（以太网中的交换机）来实现的。\n涉及到的三张表分别是\n\n交换机中有 MAC 地址表用于映射 MAC 地址和它的端口  \n\n路由器中有路由表用于映射 IP 地址 (段) 和它的端口  \n\n电脑和路由器中都有 arp 缓存表用于缓存 IP 和 MAC 地址的映射关系\n\n\n这三张表是怎么来的\n\nMAC 地址表是通过以太网内各节点之间不断通过交换机通信，不断完善起来的。  \n\n路由表是各种路由算法 + 人工配置逐步完善起来的。\n\narp 缓存表是不断通过 arp 协议的请求逐步完善起来的。\n\n\n知道了以上这些，目前网络上两个节点是如何发送数据包的这个过程，就完全可以解释通了！\n\n那接下来我们就放上本章 最后一个 网络拓扑图吧，请做好 战斗 准备！\n\n这时路由器 1 连接了路由器 2，所以其路由表有了下一条地址这一个概念，所以它的路由表就变成了这个样子。如果匹配到了有下一跳地址的一项，则需要再次匹配，找到其端口，并找到下一跳 IP 的 MAC 地址。\n也就是说找来找去，最终必须能映射到一个端口号，然后从这个端口号把数据包发出去。\n目的地址下一跳端口192.168.0.0/240192.168.0.254/320192.168.1.0/241192.168.1.254/321192.168.2.0/24192.168.100.5192.168.100.0/242192.168.100.4/322\n\n这时如果 A 给 F 发送一个数据包，能不能通呢？如果通的话整个过程是怎样的呢？\n\n思考一分钟…\n详细过程动画描述：\n\n详细过程文字描述：\n1. 首先 A（192.168.0.1）通过子网掩码（255.255.255.0）计算出自己与 F（192.168.2.2）并不在同一个子网内，于是决定发送给默认网关（192.168.0.254）\n2. A 通过 ARP 找到 默认网关 192.168.0.254 的 MAC 地址。\n3. A 将源 MAC 地址（AAAA）与网关 MAC 地址（ABAB）封装在数据链路层头部，又将源 IP 地址（192.168.0.1）和目的 IP 地址（192.168.2.2）（注意这里千万不要以为填写的是默认网关的 IP 地址，从始至终这个数据包的两个 IP 地址都是不变的，只有 MAC 地址在不断变化）封装在网络层头部，然后发包\n\n4. 交换机 1 收到数据包后，发现目标 MAC 地址是 ABAB，转发给路由器 1  \n5. 数据包来到了路由器 1，发现其目标 IP 地址是 192.168.2.2，查看其路由表，发现了下一跳的地址是 192.168.100.5\n6. 所以此时路由器 1 需要做两件事，第一件是再次匹配路由表，发现匹配到了端口为 2，于是将其封装到数据链路层，最后把包从 2 号口发出去。\n7. 此时路由器 2 收到了数据包，看到其目的地址是 192.168.2.2，查询其路由表，匹配到端口号为 1，准备从 1 号口把数据包送出去。\n8. 但此时路由器 2 需要知道 192.168.2.2 的 MAC 地址了，于是查看其 arp 缓存，找到其 MAC 地址为 FFFF，将其封装在数据链路层头部，并从 1 号端口把包发出去。\n9. 交换机 3 收到了数据包，发现目的 MAC 地址为 FFFF，查询其 MAC 地址表，发现应该从其 6 号端口出去，于是从 6 号端口把数据包发出去。\n10. F 最终收到了数据包！并且发现目的 MAC 地址就是自己，于是收下了这个包\n更详细且精准的过程：\n后记\n至此，经过物理层、数据链路层、网络层这前三层的协议，以及根据这些协议设计的各种网络设备（网线、集线器、交换机、路由器），理论上只要拥有对方的 IP 地址，就已经将地球上任意位置的两个节点连通了。\n\n本文经过了很多次的修改，删减了不少影响主流程的内容，就是为了让读者能抓住网络传输前三层的真正核心思想。同时网络相关的知识也是多且杂，我也还有很多搞不清楚的地方，非常欢迎大家与我交流，共同进步。\n完\n","slug":"如果让你来设计网络","date":"2024-02-01T16:03:42.191Z","categories_index":"工作,网络","tags_index":"工作,网络","author_index":"Vegetabhl"},{"id":"a9400e785c9bf8e2b92b99bfd432526c","title":"系统安装备份","content":"1 Win安装:U盘启动快捷键：\n\n1.1 Pe安装：1进pe，在diskgenius中对硬盘进行分区，右键选择快速分区\n\n\n1注意以下几点\n\n\n划分完成后，打开进行系统还原\n\n1等待加载完成即可\n\n\n1.2 官方系统直装U盘提前格式化\n在微软官网下载win官方u盘处理工具制作启动盘，以win10为例，下载安装完成后打开\nhttps://www.microsoft.com/zh-cn/software-download/windows10ISO\n1执行以下步骤\n\n\n\n1进bios更改启动项后进行系统安装：\n\n\n2 双系统安装：电脑开机自检，bios加载，根据引导模式到对应的磁盘分区找对应的引导文件，根据引导文件加载对应系统。\nUefi+gpt的模式还可以多个系统共享一个引导分区。\n注：这里默认均为引导模式uefi，磁盘分区gpt。Legacy+MBR的模式弊端太多了，不做赘述\n1Ubuntu安装步骤：\n\n\n1这里语言可以设置为中文，但最好使用英文，避免未知bug\n\n\n1如果出现了以下页面，关闭RST(自行检索)后重新安装。\n\n\n1取消下载更新\n\n\n\n12可以根据磁盘大小判断压缩的空闲分区，进行划分。这里只划分一个 / 挂载点启动引导器选择**引导分区\n\n\n3 系统备份还原：3.1 Diskgenius备份:打开Diskgenius，右键系统分区选择备份分区到镜像文件\n\n1234备份文件不能保存在系统分区。可在备份选项中进行相关设置，默认不变。第一次备份选择完整备份。增量备份需要在一份完整备份文件基础上备份。\n\n\n3.2 Diskgenius还原:1打开Diskgenius，右键系统分区选择从镜像文件还原分区\n\n\n123选择相应还原文件检查选择目标分区为系统分区确认完成即可开始还原\n\n\n3.3 Dism++备份\n1同样备份文件不能保存在系统分区\n\n\n3.4 Dism++还原\n12选择还原文件 确认系统分区\n\n\n","slug":"系统安装备份","date":"2024-01-01T15:42:00.526Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"8f633709df2a96abfb63904439830c12","title":"gitalk和Waline","content":"[TOC]\n1 设置评论区gitalkGiTalk 基于 GitHub Issues ，并且GitTalk基于GitHub登录的无后台评论系统。\nSee: https://github.com/gitalk/gitalk#options\n使用gitalk其实很简单的，因为各大hexo主题都内置了gitalk的配置，包括aurora主题，因此简单地配置一下主题文件就能使用gitalk。主题的 _config.aurora.yml 里面我的评论配置情况如下：\n\n\n\n\n属性\n描述\n\n\n\nenable\n使用true开启, 使用false关闭\n\n\nautoExpand\n如果设置为true, Github 评论将会自动展开。否者默认会收起。\n\n\nclientID\nclientID 是你 GitHub 的 Oauth APP 中提供的。\n\n\nclientSecret\nclientSecret 是你 GitHub 的 Oauth APP 中提供的。\n\n\nrepo\n仓库名, 比如: https://github.com/auroral-ui/**hexo-theme-aurora-docs**, 名字就是 hexo-theme-Aurora-docs\n\n\nowner\n仓库拥有者的用户名. 比如: auroral-ui\n\n\nadmin\n仓库管理员的用户名，这里可以填写多个管理员。(也用于标记那个评论是博主的)\n\n\nid\n确保唯一性和长度小于 50，如果您使用pathname，请确保长度小于 50 个字符或使用uid代替，这个有更好的兼容性 (如果您之前使用其他主题，谁用 uid 将可能无法显示您之前的评论)\n\n\nlanguage\n使用 en 设置为英文，使用 cn 设置为中文.\n\n\ndistractionFreeMode\n与 Facebook 一样的专注模式，点击评论输入框时会让背景变暗。true 来开启 false 来关闭\n\n\nrecentComment\n是否开启最近评论功能。\n\n\nproxy\nGitHub 授权请求的反向代理\n\n\nGitHub创建新的应用和仓库在GitHub中申请一个应用的演示如下：\n\n点击new oauth app创建一个新的授权应用。点击此处注册\n\n1234567891.Application name 应用名字随便写，自己分清就行。2.homepage url 是你仓库的链接，记住是链接，待会儿演示如何创建仓库并初始化issue。3.Application description 应用描述也是随便填，反正都是写给你自己看的。4.Authorization callback URL，这个授权回调url就是你自己的博客地址。填完之后，点击注册应用，你会得到clientID和clientSecret，这个填到配置文件即可。接下来演示创建仓库：\n\n\n点击绿色按钮创建新的仓库\n然后重点来了，在创建仓库时，一定要选择public，不能是private，这个配置会影响gitalk的使用。然后在仓库的 settings 中点击 issue 的 set up templates ，再去issue下面发表一条评论即可\n\n2 设置评论区Waline\n\n\n\n\n\n\n\n\n欢迎使用 Waline，只需几个步骤，你就可以在你的网站中启用 Waline 提供评论与浏览量服务。\n官网地址：https://waline.js.org/guide/deploy/netlify.html\n\nWaline\nGuide\n快速上手\n\n欢迎使用 Waline，只需几个步骤，你就可以在你的网站中启用 Waline 提供评论与浏览量服务。\n以下为aurora主题中我的waline配置，需要指出serverurl需要去掉https前缀，否则会有主题的最近评论板块不显示这个小bug\n\n\n\n\n属性\n描述\n\n\n\nenable\n使用true开启, 使用false关闭.\n\n\napp_id\n从 LeanCloud 的应用中得到的 app_id.\n\n\napp_key\n从 LeanCloud 的应用中得到的 appKey.\n\n\navatar\nGravatar 头像展示方式。\n\n\nplaceholder\n评论框占位提示符。\n\n\nvisitor\n文章访问量统计。\n\n\nlang\n如需自定义语言，请参考 i18n。\n\n\nmeta\n评论者相关属性。 [&#39;nick&#39;,&#39;mail&#39;,&#39;link&#39;]\n\n\nadmin\n用于标记那个评论是博主的\n\n\nrecentComment\n是否开启最近评论功能。\n\n\n2.1 LeanCloud 设置 (数据库设置)\n登录 open in new window 或 注册 open in new window LeanCloud 国际版 并进入 控制台 open in new window\n\n点击左上角 创建应用 open in new window 并起一个你喜欢的名字 (请选择免费的开发版):\n创建应用\n\n进入应用，选择左下角的 设置 &gt; 应用 Key。你可以看到你的 APP ID,APP Key 和 Master Key。请记录它们，以便后续使用。\nID 和 Key\n\n\n2.2 Netlify部署(服务端部署设置)目前是部署在netlify上了\n点击 Fork 按钮创建 netlify 启动脚手架。\nnetlify\nhttps://app.netlify.com 登录 Netlify 控制台，选择 Add new site - Import an exist project 添加网站。选择 GitHub 认证读取我们的 GitHub 项目列表。在列表中搜索我们刚才 Fork 生成的仓库名，点击该项目开始基于该仓库创建我们的 Netlify 网站。\n\n创建 Netlify 网站之前，需要我们填入一些配置信息。除了环境变量，其它信息我们使用默认的即可。以 LeanCloud 部署服务为例，我们在这里增加上 Waline 需要的数据库服务环境变量。点击底部的 Deploy site 开始部署网站。\nnetlify\n稍待片刻后我们的 Netlify 网站就部署成功了。我们可以点击顶部的 Functions 导航栏切换到云函数列表，其中 comment 则是我们部署好的 Waline 服务。点击它进入该云函数的详情页。\nnetlify\n在详情页中，Endpoint 列出来的地址即为我们的 Waline 服务的部署地址。点击右边的复制按钮，在新标签页中打开它，测试下评论发布，一切成功~ 接下来就将这个域名配置在客户端中就可以愉快的评论了！\n\n如何更新进入到 GitHub 仓库中，修改 package.json 文件中的 @waline/vercel 版本号为最新版本即可。\n如何修改环境变量点击顶部的 Site settings 导航栏，选择 Environments variables 侧边栏，进入环境变量管理页。点击 Add a variable 按钮我们可以添加环境变量。\n编辑完环境变量后，我们需要进入 Deploys 页面，选择 Trigger deploy - Deploy site 对网站进行重新部署才能使环境变量生效。\n\n2.3 Vercel 部署 (服务端部署设置)目前是部署在netlify上了，vercel上也部署了但是未启用，如需要启用，在_config.aurora.yml中修改下serverurl地址即可（已注释好）\nopen in new windowVercel\n\n点击上方按钮，跳转至 Vercel 进行 Server 端部署。\n注\n如果你未登录的话，Vercel 会让你注册或登录，请使用 GitHub 账户进行快捷登录。\n\n输入一个你喜欢的 Vercel 项目名称并点击 Create 继续:\n创建项目\n\n此时 Vercel 会基于 Waline 模板帮助你新建并初始化仓库，仓库名为你之前输入的项目名。\ndeploy\n一两分钟后，满屏的烟花会庆祝你部署成功。此时点击 Go to Dashboard 可以跳转到应用的控制台。\n)deploy\n\n点击顶部的 Settings - Environment Variables 进入环境变量配置页，并配置三个环境变量 LEAN_ID, LEAN_KEY 和 LEAN_MASTER_KEY 。它们的值分别对应上一步在 LeanCloud 中获得的 APP ID, APP KEY, Master Key。\n设置环境变量\n注：如果使用的是国际版，则步骤5不需要做了。如果你使用 LeanCloud 国内版，请参考步骤5，额外配置 LEAN_SERVER 环境变量，值为你绑定好的域名。\n\n环境变量配置完成之后点击顶部的 Deployments 点击顶部最新的一次部署右侧的 Redeploy 按钮进行重新部署。该步骤是为了让刚才设置的环境变量生效。\nredeploy\n\n此时会跳转到 Overview 界面开始部署，等待片刻后 STATUS 会变成 Ready。此时请点击 Visit ，即可跳转到部署好的网站地址，此地址即为你的服务端地址。\nredeploy success\n\n\n2.4 评论管理 (后台)\n部署完成后，请访问 &lt;serverURL&gt;/ui/ 进行注册。首个注册的人会被设定成管理员。\n管理员登陆后绑定个人的主页地址。即：https://vegetabhl.github.io/，也可在LeanCloud 数据库端设置\n管理员登陆后，即可看到评论管理界面。在这里可以修改、标记或删除评论。\n用户也可通过评论框注册账号，登陆后会跳转到自己的档案页。\n\n2.5 视频教程以下是热心用户制作的视频教程，以上操作不清楚的也可以参考一二。\n1  Waline 部署教程（快速上手）\n\n\n\n\n\n\n\n\n\nUP 主：rickroll 摇 open in new window\n2  使用 Vercel 简单地部署 Waline 评论系统\n\n\n\n\n\n\n\n\n\nUP 主：岚天呀 open in new window\n","slug":"gitalk和Waline设置","date":"2023-12-30T12:03:58.497Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"4221a34b979b72d1889277d8691d3068","title":"Front-Meta","content":"Front-Meta测试专属页面\n","slug":"1_Front-Meta","date":"2023-12-29T18:59:23.846Z","categories_index":"工作,Python,Java,deep learning,操作系统,网络,常用工具,项目,环境配置,docker,object detection","tags_index":"工作,Python,Java,deep learning,操作系统,网络,常用工具,项目,环境配置,docker,object detection","author_index":"Vegetabhl"},{"id":"893286c4ab60c9b5cb8fdf5059c70532","title":"PS使用文档","content":"注：ps任何操作先选中图层再进行操作1 基础操作双击背景图层变为普通图层\n可以直接移动当前窗口下某一图层到另一个窗口的某一图层下实现复制效果\n选区后如果是裁剪任务，裁剪完背景色如果变了，可以新创建一个图层填充为纯白色或想要的颜色放在最下面当背景色。填充在编辑里面\n1234567891011121314151617181920212223常用快捷键：ctrl+shift+N 新建图层delete删除图层#2选区按住 Shift 键并单击不同的区域，可以将多个独立的区域合并到同一个选区中。按住 Alt/Option 键再单击不需要的区域即可从当前选区中减去已经选择的部分。ctrl+d:取消选中状态 ctrl+x 裁剪完剪切出来形成新的图层，需要ctrl+v再粘贴下ctrl+j 将选中的区域拷贝出来形成新的图层。（有些老版本的ps快捷键是ctrl+alt+j）alt按住 移动选中的区域或者当前窗口下某一图层到另一个窗口的某一图层下实现复制效果，不按就是剪切效果alt按住 放大缩小ALT+CTRL+C 修改画布大小ctrl+t 旋转图层ctrl+z 撤退回上一步骤(要选中图层)tab:进入或退出全屏\n\n\n\n2 常用工具2.1抓手工具\n1可以对视图进行旋转,复位视图\n\n2.2 矩形选择框(选区工具)没啥好讲的，最基础的选区工具，适用于一些简单的选区任务。\n2.2 套索工具(选区工具)\n123相比矩形选择框，套索工具会更灵活一些。多边形套索工具：点击画面的关键点直线连接（可以通过backspace或delete键删除刚才的点，esc取消整个当前路径或选区）磁性套索工具：通过移动鼠标来实现选中区域（可以通过backspace或delete键删除刚才的点）\n\n\n\n2.3 魔棒和快速选择工具(选区工具)普通的选区裁切通过矩形选择框或者索套工具即可实现，复杂一些的选区靠魔棒工具和快速选择工具完成。\n\n123魔棒工具可以快速的将颜色相近的区域变成选区。魔棒工具在遇到一些边缘不清楚的情况下仍然存在局限性，需要用快速选择工具。按住 Shift 键并单击不同的区域，可以将多个独立的区域合并到同一个选区中。按住 Alt/Option 键再单击不需要的区域即可从当前选区中减去减去已经选择的部分。\n\n快速选择工具是非常重要的抠图工具，注意使用快速选择工具的时候选中对应的图层\n2.4 橡皮擦工具（了解）2.5 字体工具(很基础，但也比较重要，使用频率较高)\n12如果需要对字体进行修改，点击“切换字符和段落面板”。例如加粗，点击第一个T，就是仿粗体，字体就加粗了。过于放大图片再进行文字添加容易模糊，建议直接原始或放大比例较小的情况下进行文字添加，然后选择滤镜下面的智能锐化进一步修剪。\n\n\n\n2.6 画笔工具（）\n123按住shift键画出直线，或按住shift键连接两个点成一条直线改变画笔硬度：Shift+“[”“]”,AIt+鼠标右键垂直移动\n\n\n\n2.72.83 举例理论上，通过（画笔，通道蒙版，快速选择工具，钢笔路径）可以抠出任意的无损图像\n注：PS功能非常强大，以上笔记仅举了个例，实际使用自己去摸索。只适用于非专业需求人士日常使用，有专业功能需求的请参考其余更详细资料。\n","slug":"PS","date":"2023-12-29T18:27:55.780Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"cfd2cd132e9325fb8f58af0dd3a1be45","title":"工作","content":"1 基础软件安装1.1 安装进入 18 ftp服务器\n找到zlsoft安装包复制到本地\n\n12341.先安装0简易客户端2.依次安装1-8，全部一站式安装3.安装完成后进9.10.35.130.0013文件夹按照系统位数对应注册4.进入C:\\Oracle\\network\\admin，找到tnsnames文件编辑\n\n修改为如下图所示\n\n2.2 部件更新1 ZLNJ放C盘根目录\n(路径：国家两定医保(整理好)&#x2F; )\n2 动态库和江苏华大里面的文件 注册表文件(医护版\\收费端)都放APPSOFT文件夹下\n3 更新部件\n12345678910113.1    zlPlugIn        APPLY            医生 收款(路径：国家两定医保(整理好)/zlPlugIn/云影像不加身份证限制/)   3.2   zl9I_GJLDYB      PUBLIC            护士(路径：国家两定医保(整理好)/字段调整/)3.3 zlExternalCheck    APPLY            院感 手麻3.4  SSCardDriver     异地刷卡动态库部件 APPSOFT  收款\n\n备注: (双击无法激活的情况下下载dll修复工具试下，还不行的话管理员模式下输入命令：regsvr32 C:\\xx\\xx\\zl9I_GJLDYB.dll 激活)\n4 以管理员身份运行注册.bat(添加pause),查看是否有明显报错.\n院感安装\n备注：安装院感需要先安装浏览器，安装后\n右键设置科室****\n设置完成后重启程序\n重启后分别点击立即获取数据、立即获取参数\n2 打印机常用的打印机分为三种：激光打印机，喷墨打印机，针式打印机，激光打印机: 用的是硒鼓或者粉盒，又分为鼓粉分离和鼓粉一体。 墨盒式喷墨打印机: 只能换墨盒使用成本较高,直接加墨水使用成本更低。\n2.1 Win7 win10之间共享打印机报错 (护理部)错误代码：0x00000011b\n解决方案1：\n打印机共享提示错异常0x00000011b报11b错误（远端操作&#x2F;已安装打印机并共享的电脑）\n在注册表编辑器中，打开HKEY_LOCAL_MACHINE&#x2F;System&#x2F;CurrentControlSet&#x2F;Control&#x2F;Print键。\n创建一个新的DWORD-32位值，将其命名为 “RpcAuthnLevelPrivacyEnabled”，将该键值设置为0。（PS：64位的系统也要新建32位DWORD值）\n保存更改并关闭编辑器。服务器端(打印机端电脑)和客户端都要完成以上设置后重启电脑，然后再连就正常了。\n解决方案2：\n打开设置&gt;应用和功能&gt;程序和功能&gt;查看已安装的更新&gt;看到最新的系统补丁为编号KB5005565（根据不同的系统版本，名称可能为KB50055XX），控制面板里面卸载掉。\n2.2 条码打印机端口报错\\打印纸张间隔出纸\\打印纸张不完整重置端口，并在在打印机首选项里面进行校正。\n2.3 网页打印乱码页边距设置为默认值。\n2.4 门诊单子打不出来看医保号，如果是那种短号，说明调用的老医保记录，重新挂免号。\n2.5 胃镜室打印检查报告单格式不对驱动问题，联想打印机容易出现这个问题\n2.6 共享主机关闭密码保护后客户机还是要输账号密码(5病区护士站)关闭密码保护\n三种办法\n1 共享主机添加一个用户，如下设置，然后就可以连接了。（记得保存凭据）\n\n2 将禁用guest用户解开\n输入gpedit.msc 打开本地组策略编辑器，更改如下\n\n如果提示权限不足，如下图将guest删除\n\n 3 用计算机名共享，不要用ip(解决)\n2.7 打印机打印短黑线（消毒供应室）重启\n2.8 打印机校正1 得实218黑色打印机：\n123开关在最下方左侧.校正：关机状态下，按住进纸键，开启打印机待哔哔响两声后松开.热敏护士站选中病人报表病人不干胶(AA)预览打印当前页.\n\n2 GK888:\n123456789101112131415打印机属性高级设置校正大小5.003.00打印份数：1打印速度：5打印浓度：14间距大小：0.3热敏不要打钩\n\n\n\n2.9 得实218打印歪了\n勾选上下面的自定义纸张通过打印服务器的格式来设置\n\n2.10 放射科自助打印条码设置1 注册表修改\n\n2 参数设置修改\n\n3 右键已报到的病人\n\n4、把勾去掉\n\n3 导航台1 将注册表内以下路径下账号信息清空(ctrl+f直接查找私有模块)\n123456789HKEY_USERS HKEY_USERS\\S-1-5-21-2943916697-3715673809-1218642869-1001 Software  VB and VBA Program Settings    私有模块\n\n2 步骤1不行的情况下重启电脑\n3.1 无法开单子像下面这种情况医保卡号是短号的就是调用的老医保信息，重新挂免号\n\n3.2 输入法无法输入中文(针灸科)重启\n3.3 打印医嘱报错强行中断(四病区医生办公室)医嘱内容字数太多超限制，删减\n3.4 预结失败，医保读卡失败（四病区医生办公室)）\n将医保插件放到appsoft目录下重新注册\n3.5 彩超室无法采图影像采集工作站 -&gt; 文件 -&gt; 视频设置\n\n采集参数设置 -&gt; 视频设置 -&gt; 视频源设置\n\n\n选择视频源选择  s -&gt; 视频 -&gt; 应用 -&gt; 确定\n\n4 其他4.1 系统卡顿清理基础流程12341.\t卸载垃圾应用2.\t继续磁盘清理，主要为本地缓存文件、休眠文件和虚拟内存（如果有的话）3.\tDism++空间回收4.\t关闭一些无用的启动项\n\n注：C盘如果占满了，可能是微信等社交软件的文件默认保存位置放在了C盘，这时需要修改下默认路径到其他盘符。另外系统稳定性大于一切，任何危险操作都需要做好备份和还原。\n系统激活：优先kms，kms无法激活的情况下采用oem激活\n以上都做完还卡的话，emmm先凑合用吧。。。。\n4.2 火狐浏览器网页显示不全，缩放无效（消毒供应室）解决：重启\n4.3 水晶头：橙白，橙，绿白，蓝，蓝白，绿，棕白，棕\n4.4 IE11报错（财务科）解决：使用edge浏览器，向下全面兼容IE\n4.5 蓝屏解决：有可能是插了外接设备，如无线网卡\n4.6 无法进系统(彩超室)解决：插了u盘导致启动项加载错了，拔掉u盘\n","slug":"工作","date":"2023-12-29T12:50:49.000Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"8a3f8d0914356b9d2ad47f5df42835fc","title":"上线系统资料","content":"1 门诊叫号机1.1 叫号设置1  医生端软件安装说明：\n12345通过ftp拷贝软件到本地地址：ftp:192.168.0.165:2206用户名：test ，密码：test\n\n拷贝“ftp”文件夹\n2  首次点击pftp.exe ，等待pcallclient.exe下载完成\n3  给Pftp.exe右键添加桌面快捷方式\n4  在桌面快捷方式，右键更改图片，右击属性-》修改图标\n\n\n选择此图标\n5 修改快捷方式名称“呼叫器”\n注：查看下防护墙是否关闭，在防火墙高级设置中，\n\n\n下一步，然后随便取个名字，完成即可。\n2  后台诊室信息维护说明\n在xxx服务器桌面上，打开“综合设置”，密码：xxx\n\n在设置中选择，诊室设置-》诊室综合设置\n\n选择对应诊区\n修改信息操作:\n\n123456789101、在左侧列表选择对应要修改诊室2、右侧会出现对应信息，一般可以修改项只有两个：诊室IP 、诊室名称修改后，点击左侧下方“保存”按钮即可\t添加诊室信息这个一般可以联系工程师添加，因为要对应门屏信息。3\t后台医生设置说明在设置-》医生设置因为已修改为定时同步his中医生的简介和职称，所以，一般来说这里只修改照片修改方法，在左侧列表中找到对应医生工号，可以输入医生姓名首字母或医生姓名点击回车查找\n\n\n点击“加载照片”，选择对应的照片替换，注意：照片格式为JPG格式，不要大于400看，\n加载完成后，点击下面“修改”就可以了。\n2 自助机院外自助机开机流程：\n12345第一步：按自助机后面左侧红色开机按钮，按一次等10秒左右，看屏幕是否亮起。不开重复一次。再不开进行第二步第二步：打开打印机前门，按ups上按钮，听见“哔~~”声松开。第三步：按自助机后面左侧红色开机按钮，按一次等10秒左右，看屏幕是否亮起。不开重复第三步几次。再不开重复按ups和后边红色按钮（即重复步骤二、三）\n\n\n3 心电系统4 瑞美输血系统","slug":"上线系统资料","date":"2023-12-29T07:50:50.000Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"b97b67ba25f1a6aa8ccadb4743429614","title":"win下文件快速定位","content":"win下文件快速定位1 递归查找某一路径下文件夹命令：\n1dir /s aaa*\n\n首先进入指定目录D:\\Git，递归查询当前目录及其子目录下以首字母是aaa命名的文件夹\n\n2  递归查找某一路径下文件命令：\n1where /r F:\\ aa*\n\n\n不需要提前进入指定目录，在命令中输入对应目录，递归查找当前输入目录及其子目录下首字母是aa命名的文件。\n","slug":"win下文件快速定位","date":"2023-12-29T07:50:49.000Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"d3cc89cbc0f534f6a7b251c718e7bb86","title":"hexo推送异常处理","content":"title: Error Spawned:Hexo 部署到 Github 问题解决 date: 2024-01-31 15:49:51 tags: Hexo typora-root-url: Error-Spawned-Hexo 部署到 Github 问题解决\n将 Hexo 博客部署到 Github 上常常会遇到报错：\n123&gt; FATAL Something&#x27;s wrong. Maybe you can find the solution here: [https://hexo.io/docs/troubleshooting.html](https://hexo.io/docs/troubleshooting.html) Error: Spawn failed at ChildProcess. (E:\\Blog\\node_modules\\hexo-deployer-git\\node_modules\\hexo-util\\lib\\spawn.js:51:21) at ChildProcess.emit (node:events:514:28) at cp.emit (E:\\Blog\\node_modules\\cross-spawn\\lib\\enoent.js:34:29) at ChildProcess._handle.onexit (node:internal/child_process:294:12)网络上的一些解决办法时常失效，且治标不治本.\n\n解决方法是 SSH 密钥出现问题.\n\n\n\n\n\n\n\n\n\n$ ssh -T &#x67;&#105;&#116;&#x40;&#x67;&#105;&#x74;&#104;&#117;&#x62;&#46;&#99;&#111;&#109; ssh: connect to host http://github.com port 22: Connection timed out\nStackoverflow 中最高赞方法实测可行.\n\n其中，~/.ssh路径为C:\\Users\\username\\.ssh，于其中新建文件config即可. 我采用的是 CSDN 中给出的文件内容，即下方给出的方法\n1.进入~&#x2F;.ssh下\n1cd ~/.ssh\n\n2.创建一个config文件\n1vim config\n\n3.编辑文件内容：\n12345678910111213Host github.comUser gitHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443Host gitlab.comHostname altssh.gitlab.comUser gitPort 443PreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa\n\n\n4.保存退出\n5.检查是否成功\n1ssh -T git@github.com\n\n这里要根据它的提示操作，有个地方要输入yes\n大功告成.\n","slug":"hexo推送异常处理","date":"2023-12-29T07:40:20.000Z","categories_index":"项目","tags_index":"项目","author_index":"Vegetabhl"},{"id":"743be9d6ef5e192ad79e8bd119795962","title":"Hexo迁移版本升级 + nvm 管理 nodejs 版本配置","content":"Hexo 迁移版本升级 + nvm 管理 nodejs 版本配置\n[TOC]\n\n前言已经好久没有更新 github 主页上 hexo 推送的博客了 (虽然没人看苦笑😂😂)，作为耕宏男孩强身健体的同时，咋们也要做博客男孩，平时多记录下开发经验和学习知识，遇到问题就不需要慌忙打开百度搜索，直接打开博客浏览复习一遍效果更好。俗话说好记性不如烂笔头，看千万次不如写一次，妙手前提是练好本手，不然写出代码就是俗手（蹭高考作文热点😃😃）\n我的 github 主页地址 https://vegetabhl.github.io/\n一、Hexo 是什么？Hexo 是快速、简洁且高效的博客框架，具有以下特点\n\n极速生成\n支持 GitHub Flavored Markdown 和大多数 Octopress 插件\n一键部署到 GitHub Pages、Heroku 等。\n强大的 API，可无限扩展\n数百个主题和插件\n\n二、安装开发环境因为工作电脑上（windows10 系统）现有的 nodejs 版本项目不敢随意升级，发现可以用 nvm 版本管理器来控制管理 nodejs 和 npm 版本。磨刀不误砍柴功，工欲善其事，必先利其器，工具用的顺，每天早下班。nvm 安装百度了一大堆但安装却遇到了问题不太一样，最后自己还是凭经验解决了，希望自己走过的坑 (我已躺好) 对大家有帮助就好🤣🤣。\n1.nvm 安装下载地址：https://github.com/coreybutler/nvm-windows                  Releases 中下载 nvm-setup.exe\n关键步骤安装会出现俩个目录，一个是的 NVM 目录，另一个是 Symlink 目录，NVM 目录装的是 NVM 相关包和配置，Symlink 目录用于建立相应版本的 nodejs 文件夹的符号链接（还好看过一点 linux shell 指令大全🤣🤣）这俩个目录要保证目录内部是空的. 之前 nodejs 的 Symlink 的安装目录非空导致出现以下问题：\n1exit code 145:文件目录非空；\n\n新建文件为空目录\n比如我是H:&#x2F;Nodejs&#x2F;mvnH:&#x2F;Nodejs&#x2F;nodejs\n环境变量是自动添加的很贴心~~\n1exit code 1:没有权限；\n\nCMD 或者 git bash 右键以管理员模式运行\n2.nodejs 安装安装完 nvm 以下命令依次执行，先查看 nvm 版本，再下载安装 nodejs 版本，最后选择使用 nodejs 版本\n123456789nvm -v  查看nvm版本nvm ls  查看当前nodejs版本nvm ls available 查看可获得的nodejs版本 可选LTS稳定版本nvm install/nvm unisntall &lt;version&gt;  安装卸载版本nvm use &lt;version&gt;  使用版本node -v  nodejs版本npm-v    npm版本npm config set prefix &quot;H:\\Nodejs\\node_global&quot;  设置全局路径npm config set cache &quot;H:\\Nodejs\\node_cache&quot; 设置全局缓存\n\n安装全部正常完成如下图所示\n3.hexo 安装安装完 hexo 后，新建 Blog 空文件夹作为博客主文件夹，Blog 文件夹中初始化 hexo，下载 next 主题存放于.&#x2F;themes&#x2F;next 文件夹\n12345npm install -g hexo 安装hexo  hexo -v    查看hexo版本  hexo init Blog  Blog文件夹中初始化hexo  cd Blog   进入Blog 文件夹  git clone https://github.com/theme-next/hexo-theme-next themes/next git下载next主题\n\n三. hexo 配置发布和 next 主题配置1.hexo 文章发布hexo 支持 markdown 文件的渲染并以 html 格式在 &#x2F; Blog&#x2F;public 文件夹内生成相应文件markdown 文件编辑器推荐 Typora写完博客后只要将文件后缀为. md 文件复制到 &#x2F; Blog&#x2F;source&#x2F; _posts 中即可hexo 配置发布主要以下命令\n命令描述hexo generate 或 hexo g生成静态文件hexo server 或者 hexo s启动 hexo 服务，默认情况下，访问网址为： http://localhost:4000/hexo deploy 或者 hexo d部署静态文件hexo clean清除缓存文件 (db.json) 和已生成的静态文件 (public) 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令\n\n2.hexo 主题配置参考官网： https://hexo.io/zh-cn/docs/\nSite\n1234567title:  主标题subtitle:  副标题description:  描述keywords: 关键字author:  作者language: 语言timezone:  时区\n\nExtensions\n1theme: next\n\n3.next 主题配置参考 github：https://github.com/iissnan/hexo-theme-next                      https://github.com/theme-next/hexo-theme-next\n主题配置\n1234scheme: Muse #scheme: Mist #scheme: Pisces #scheme: Gemini\n\n我用的 Muse 主题，因为左侧导栏可以随屏幕自动调节，并且可以展开隐藏，原来是 Gemini 主题突然发现 Muse 也很 nice✌✌\n菜单栏配置\n123456789menu:  home: / || fa fa-home  archives: /archives/ || fa fa-archive  tags: /tags/ || fa fa-tags  categories: /categories/ || fa fa-th  sitemap: /sitemap.xml || fa fa-sitemap  schedule: /schedule/ || fa fa-calendar  commonweal: /404/ || fa fa-heartbeat  about: /about/ || fa fa-user\n\n这个和我原配置稍许不同，研究半天才发现原来配置不显示菜单图标，后来看了下备注低版本配置没有 fa fa - 前缀😅😅\n侧栏头像\n1234avatar:  url:  /images/favicon.jpeg    自定义头像文件放置在主题的\\next\\source\\images文件夹中  rounded: false  rotated: false\n\n社交\n123456789social:  GitHub: xxxx ||  fab fa-github  E-Mail:xxxx || fa fa-envelope  Weibo:xxxx || fab fa-weibo  Twitter:xxxx || fab fa-twitter  social_icons:  enable: true  icons_only: false  transition: false\n\n打赏\n1234567reward_settings:  enable: true  animation: truereward:  wechatpay: /images/wechatpay.png            微信支付文件放置在主题的\\next\\source\\images文件夹中  alipay: /images/alipay.jpg                  支付宝支付文件放置在主题的\\next\\source\\images文件夹中\n\n4.hexo 迁移迁移只要用原来的以下 hexo 文件覆盖 hexo init Blog 下的相应文件即可\n配置文件描述_config.ymlhexo 的配置文件theme/博客主题文件source/博客文章源文件. mdscaffold/博客模板文件package.jsonnpm 依赖包.gitignoreGit 提交忽略文件\n\n四. next 主题自定义配置参考 github： https://github.com/theme-next/hexo-theme-next                      github 登上小手一动先点个⭐哎，很舒服！ 点击 more example here                       根据自己喜好添加相应的插件\n1 添加日历📆 theme-next-calendar: 一个简洁的 hexo-next 日历云插件\n首先安装 hexo 插件\n1npm install theme-next/theme-next-calendar\n\n在 next 主题配置文件_config.yml 配置\n12345678CloudCalendar:  enable: true  language: zh-CN  single: true  root: /calendar/  calendarCdn: //cdn.jsdelivr.net/gh/theme-next/theme-next-calendar/calendar.min.js  langCdn: //cdn.jsdelivr.net/gh/theme-next/theme-next-calendar/languages.min.js  #disableSidebar: false\n\n备注：按照作者配置发现网页报错，错误信息：\n12calendar.min.js:1 Uncaught ReferenceError: jQuery is not defined     at calendar.min.js:1\n\n由于缺少 jquery 文件，页面无法显示，这个简单，直接补上！进入 \\Blog\\themes\\next\\layout_scripts 中 vendors.swig 添加\n1&#123;%- set js_vendors = js_vendors | attr(&#x27;jquery&#x27;, &#x27;jquery-3.2.1.min.js&#x27;) %&#125;\n\n进入 H:\\Github\\Blog\\themes\\next\\source\\lib 添加下载的\n1jquery-3.2.1.min.js\n\n2 添加共享服务🎁 hexo-next-share: NexT 的内容共享服务我用的 sharejs 的分享，因为比较好看😄😄\n首先安装 hexo 插件\n1npm install theme-next/hexo-next-share\n\n在 next 主题配置文件_config.yml 配置\n123456789sharejs:  enable: true  cdn:    js: //cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js    css: //cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css  networks: weibo,wechat,qzone,facebook,twitter,google  wechat_qrcode:    title: 请打开微信扫一扫    prompt:\n\n备注： 配置 QQ 分享的话页面会报二维码的长度过长 js 错误，百度修改下 js 参数就行了，因为老了不用 QQ 算了不改了~~\n3 添加 valine 用户评论系统原来用的 gtalk 需要登录 github 才能评论现换成 valine 评论系统，具体操作详见以下作者文章Hexo 集成 Valine 评论系统 https://www.jianshu.com/p/b9e73c881729备注：原来的 Leancloud 长时间不用需要激活，激活了 N 天没反应算了直接删除应用直接创建个新的应用，反正也没数据😅😅\n4 添加透明泡泡漂浮动态背景背景白色的太枯燥了，动态背景中发现了透明泡泡浮动背景很不错立马就借鉴下修改下博客的 css 背景样式✌✌\\next\\layout_layout.swig 文件中新增标签\n123456789101112&lt;ul class=&quot;bg-bubbles&quot;&gt;          &lt;li&gt;&lt;/li&gt;          &lt;li&gt;&lt;/li&gt;          &lt;li&gt;&lt;/li&gt;          &lt;li&gt;&lt;/li&gt;          &lt;li&gt;&lt;/li&gt;          &lt;li&gt;&lt;/li&gt;          &lt;li&gt;&lt;/li&gt;          &lt;li&gt;&lt;/li&gt;          &lt;li&gt;&lt;/li&gt;          &lt;li&gt;&lt;/li&gt;        &lt;/ul&gt;\n\n\\next\\source\\css\\main.styl 中新增背景布局\n123// Background Layer   // ------------------------------------------------- @import &quot;_background.styl&quot;;\n\n\\next\\source\\css 文件夹中新增 _background.styl 布局样式\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125.container&#123;  background: #ffffff;        background: -webkit-linear-gradient(to left, #becdd3 0%, #ffffff 30%,#ffffff 50%, #becdd3 100%);  background: linear-gradient(to left, #becdd3 0%, #ffffff 33%,#ffffff 67%, #becdd3 100%);  opacity: 0.8;   &#125;.sidebar &#123;  background: rgba(0,0,0,0.902);&#125;.bg-bubbles &#123;  position: absolute;  top: 0;  left: 0;  width: 100%;  height: 100%;  z-index: -1;&#125;.bg-bubbles li &#123;  position: fixed;  list-style: none;  display: block;  width: 40px;  height: 40px;  background-color: rgba(255, 255, 255, 0.15);  bottom: 15%;  -webkit-animation: square 25s infinite;  animation: square 25s infinite;  -webkit-transition-timing-function: linear;  transition-timing-function: linear;&#125;.bg-bubbles li:nth-child(1) &#123;  left: 2%;  width: 150px;  height: 150px;  -webkit-animation-duration: 40s;  animation-duration: 40s;&#125;.bg-bubbles li:nth-child(2) &#123;  left: 5%;  -webkit-animation-delay: 10s;          animation-delay: 10s;  -webkit-animation-duration: 40s;          animation-duration: 40s;  background-color: rgba(255, 255, 255, 0.3);&#125;.bg-bubbles li:nth-child(3) &#123;  left: 13%;  width: 100px;  height: 100px;  -webkit-animation-delay: 10s;          animation-delay: 10s;  -webkit-animation-duration: 30s;          animation-duration: 30s;&#125;.bg-bubbles li:nth-child(4) &#123;  left: 18%;  width: 20px;  height: 20px;  background-color: rgba(255, 255, 255, 0.25);&#125;.bg-bubbles li:nth-child(5) &#123;  left: 20%;  -webkit-animation-delay: 15s;          animation-delay: 15s;&#125;.bg-bubbles li:nth-child(6) &#123;  right: 2%;  width: 150px;  height: 150px;  -webkit-animation-delay: 2s;          animation-delay: 2s;  -webkit-animation-duration: 50s;          animation-duration: 50s;  background-color: rgba(255, 255, 255, 0.2);&#125;.bg-bubbles li:nth-child(7) &#123;  right: 15%;  -webkit-animation-delay: 5s;          animation-delay: 5s;&#125;.bg-bubbles li:nth-child(8) &#123;  right: 12%;  width: 20px;  height: 20px;  -webkit-animation-duration: 20s;          animation-duration: 20s;&#125;.bg-bubbles li:nth-child(9) &#123;  right: 20%;  -webkit-animation-delay: 2s;          animation-delay: 2s;  -webkit-animation-duration: 60s;          animation-duration: 60s;  background-color: rgba(255, 255, 255, 0.3);&#125;.bg-bubbles li:nth-child(10) &#123;  right: 20%;  width: 160px;  height: 160px;  -webkit-animation-delay: 2s;          animation-delay: 2s;&#125;@-webkit-keyframes square &#123;  0% &#123;    -webkit-transform: translateY(0);            transform: translateY(0);  &#125;  100% &#123;    -webkit-transform: translateY(-700px) rotate(600deg);            transform: translateY(-700px) rotate(600deg);  &#125;&#125;@keyframes square &#123;  0% &#123;    -webkit-transform: translateY(0);            transform: translateY(0);  &#125;  100% &#123;    -webkit-transform: translateY(-700px) rotate(600deg);            transform: translateY(-700px) rotate(600deg);  &#125;&#125;\n\n备注：虽然以前调过 html css 样式不过都是老的 css 样式，新的 css3 真没调过只能依葫芦画瓢调整按照页面版面调整下位置速度和延时😅😅\n5 添加 git 远程部署首先安装 hexo 插件\n1npm install hexo-deployer-git --save\n\n\\Blog_config,yml 配置 github 主页地址\n1234deploy:  type: git  repo: https://token@github.com/xdj68/xdj68.github.io.git  branch: master\n\n备注：git 远程部署文档 https://hexo.io/docs/one-command-deployment部署您的站点 hexo clean &amp;&amp; hexo deploy。除非您使用令牌或 ssh 密钥进行身份验证，否则系统将提示您输入目标存储库的用户名和密码。hexo-deployer-git 不存储您的用户名和密码。使用 git-credential-cache 临时存储它们。\nAPI 可见 github 三种验证方式：用户名密码，token，SSH，SSH SSH 需要 git 生成公钥 token 需要 github 生成 token。因为原配置用户名密码的配置不跳用户名密码输入，按照文档 git-credential-cache 命令应该可以，正好用 github 新 token 验证方式部署。具体参考一下作者https://zhuanlan.zhihu.com/p/465182461(友情提醒：token 只能第一次看见，赶紧生成保存下，图上 repo 参数中 token 填 github 上生成的 ghp_xxxxxxxxxxxxxxxxxx 开头的鉴权码就可以了😄😄)\n五. hexo 版本升级Hexo 升级比较简单，老方法 npm-check、npm-upgrade、npm-update 一键三连。按以下顺序逐步执行完成后，Hexo 版本及系统插件均会升级到最新。\n123456789101112131415161718192021222324252627282930//以下指令均在Hexo目录下操作，先定位到Hexo目录//查看当前版本，判断是否需要升级&gt; hexo version//全局升级hexo-cli&gt; npm i hexo-cli -g//再次查看版本，看hexo-cli是否升级成功&gt; hexo version//安装npm-check，若已安装可以跳过&gt; npm install -g npm-check//检查系统插件是否需要升级&gt; npm-check//安装npm-upgrade，若已安装可以跳过&gt; npm install -g npm-upgrade//更新package.json&gt; npm-upgrade//更新全局插件&gt; npm update -g//更新系统插件&gt; npm update --save//再次查看版本，判断是否升级成功&gt; hexo version\n\n也可以用可以用 ncu -u 一把梭\n123456789101112131415161718$ npm install npm-check-updates -g$ ncuChecking /Users/tommy/blog/package.json[====================] 16/16 100% hexo                    ^4.2.0  →  ^5.0.0 hexo-generator-sitemap  ^2.0.0  →  ^2.1.0Run ncu -u to upgrade package.json$ ncu -uUpgrading /Users/tommy/blog/package.json[====================] 16/16 100% hexo                    ^4.2.0  →  ^5.0.0 hexo-generator-sitemap  ^2.0.0  →  ^2.1.0Run npm install to install new versions.\n\n简单如此，就把 package.json 文件给更新了，果然是一把梭啊，爽～～～\n对于强迫症的我，习惯性删除重来是必须的\n12$ rm -fr node_modules/$ npm install --save\n\n以我多年来瞎折腾的经验看，肯定还有坑。\n运行 hexo server 验证一下我的想法，果不其然：\n12INFO  Validating configWARN  Deprecated config detected: &quot;external_link&quot; with a Boolean value is deprecated. See https://hexo.io/docs/configuration for more details.\n\n嗯……「deprecated」啊……查一下官方的 Release Note。\n果然有个叫「Breaking change」的东东，里面就有说到配置文件的变化。\n对比以后，发现主要有如下变化，大家根据自己的需要调整修改就好了：\n123456789101112131415161718192021222324252627pretty_urls:  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinksexternal_link:  enable: true # Open external links in new tab  field: site # Apply to the whole site  exclude: &#x27;&#x27;prismjs:  enable: false  preprocess: true  line_number: true  tab_replace: &#x27;&#x27;# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true# updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;updated_option: &#x27;mtime&#x27;# Include / Exclude file(s)## include:/exclude: options only apply to the &#x27;source/&#x27; folderinclude:exclude:ignore:\n\n","slug":"Hexo 迁移版本升级 + nvm 管理 nodejs 版本配置","date":"2023-12-26T17:07:54.967Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"d187c6cbbf234b66485a2866be10bdca","title":"Hexo+GitHub 搭建个人博客并发布文章（附常见问题解决方法）","content":"简介本教程使用 GitHub 自带的 GitHub pages 来生成静态个人博客，而 Hexo 可以更换各种好看的主题，而且都是免费的，花一点时间就可以打造出自己独有的个人博客。\nHexo 这个有力的工具可以让我们专注于写出一篇博客而不需要关心如何编写 html 和 CSS，再如何形成一个网站，它可以根据 markdown 文档和指定的主题直接生成一个静态网站，对于新手朋友或者不是专门搞前端开发的人们非常友好。\n还有一个优点就是 GitHub pages 生成的网站很稳定，就算自己的本地站点被删除，也完全不影响已经发布到 GitHub 仓库的文章，依旧可以访问查看。\n接下来我们就开始动手搭建吧！\n部署环境在最最开始，肯定要准备一个属于自己的 GitHub 账号。因篇幅有限，这里就不再赘述如何注册账号了，如果你还没有 GitHub 账号，可以自行搜索如何注册。不过记得要使用邮箱注册。\n1. 安装 git 和 node.js要使用 GitHub 和 Hexo，首先我们需要在本地安装 git 和 node.js，因为 Hexo 基于 node.js，再生成一个 ssh 密钥用于连接 GitHub 仓库以及本地文件夹。\n\n\n\n\n\n\n\n\n\ngit 下载链接：Git - Downloading Packagnode.js 下载链接：Download | Node.js\n安装时可以直接一路点下一步，按默认设置安装即可。如果想搞清楚细节，可以看 Git 详细安装教程。\n想要验证安装是否成功，可以 win+r 输入 cmd 进入终端，输入 node -v、npm -v 和 git –version，如果出现版本号说明安装成功。在文件资源管理器中右键，出现 Open Git Bash here 和 Open Git GUI here。\n2. 连接 GitHub 和本地在文件资源管理器中右键 - Open Git Bash here，打开 git 终端，输入以下两条命令，设置用户名和邮箱：\n12$ git config --global user.name &quot;GitHub用户名&quot;       $ git config --global user.email &quot;GitHub邮箱&quot;\n\n创建 ssh 密钥文件：\n1$ ssh-keygen -t rsa -C &quot;GitHub邮箱&quot;\n\n一路回车即可。\n最后返回密钥结果和图片说明创建完成。\n123456789101112131415161718192021Generating public/private rsa key pair.    Enter file in which to save the key (/c/Users/Jingrong/.ssh/id_rsa):    Created directory &#x27;/c/Users/Jingrong/.ssh&#x27;.    Enter passphrase (empty for no passphrase):    Enter same passphrase again:    Your identification has been saved in /c/Users/Jingrong/.ssh/id_rsa    Your public key has been saved in /c/Users/Jingrong/.ssh/id_rsa.pub    The key fingerprint is:    SHA256:xxxx    The key&#x27;s randomart image is:    +---[RSA 3072]----+    |                 |    |       .         |    |        + * .. + |    |       . + = .  o|    |      . S   . . .|    |     . .     . . |    |  .   = .  ...o  |    |   +.= o +.++o   |    |                 |    +----[SHA256]-----+\n\n找到路径 Your public key has been saved in &#x2F;c&#x2F;Users&#x2F;Jingrong&#x2F;.ssh&#x2F;id_rsa.pub，用记事本打开。ctrl+a 将所有内容复制到剪切板。\n登录 GitHub，点击右上角自己的头像 - setting，找到 SSH and GPG keys，点击 add SSH key：\n\n将剪贴板中复制的密钥粘贴过来：\n\n检测是否连接成功：\n1$ ssh git@github.com\n\n如果出现 Hi xxx! You’ve successfully authenticated… 的提示，就说明连接成功。\n3. 安装 Hexo 以及 Fluid 主题使用 npm 安装 Hexo：\n1$ npm install -g hexo-cli\n\n输入 hexo -v 即可查看是否安装成功。\n新建一个 hexo 站点根目录，在站点右键 - Open Git Bash here，执行以下命令：\n12$ hexo init    $ npm install\n\n执行完成之后，指定文件夹的目录如下：\n12345678.├── _config.yml     ---&gt;  网站配置信息├── package.json    ---&gt;  应用程序的信息├── scaffolds       ---&gt;  模板文件夹├── source          ---&gt;  放置资源文件。|   ├── _drafts|   └── _posts      ---&gt;  .md文件└── themes\n\n\n\n\n\n\n\n\n\n\n除 _posts 文件夹之外，开头命名为 _ (下划线) 的文件 &#x2F; 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。来自 Hexo 官方文档\n完成后再执行以下命令：\n12$ hexo g    $ hexo s\n\n访问 http://localhost:4000，即可浏览生成的 hexo 页面。\n接下来就可以在 Themes | Hexo 里开始挑选一个喜欢的主题啦！\n以 fluid 主题为例，先找到 fluid 官方文档和 GitHub 仓库。\nHexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令：\n1npm install --save hexo-theme-fluid\n\n然后在博客目录下创建 _config.fluid.yml，将主题的 _config.yml 内容复制过去。\n指定主题\n如下修改 Hexo 博客目录中的 _config.yml：\n12theme: fluid  # 指定主题    language: zh-CN  # 指定语言，会影响主题显示的语言，按需修改\n\n创建「关于页」\n首次使用主题的「关于页」需要手动创建：\n1hexo new page about\n\n创建成功后修改 &#x2F;source&#x2F;about&#x2F;index.md，添加 layout 属性。\n修改后的文件示例如下：\n12345---    title: 标题    layout: about    ---​    这里写关于页的正文，支持 Markdown, HTML\n\n主题配置\n关于主题配置的详细步骤可以查看 fluid 的主题使用文档。\n编写文章使用 hexo 的好处就在于不需要自己手写 html，而只需要写 md 文档。\n在 resource&#x2F;_post 文件夹中新建 md 文档。\nmd 文档的开头需要添加以下内容：\n1234567---    title: 标题    tags: [标签1,标签2]    categories: [分类]    index_img: 主页封面图的相对路径    date: 2023-8-25 18:03:07    ---\n\n写好之后输入命令\n12$ hexo g   #将md编译成html保存到public文件夹中    $ hexo s   #开启本地服务器查看网站\n\n即可看到自己新添加的文章。\n发布到 GitHub Pages创建 GitHub 仓库点击右上角加号，选择 new repository。\n\n仓库名称按照用户名.http://github.io 的格式填写。选择 public，勾选 add a README file。\n\n最后点击创建仓库即可。\n配置_config.yml 文档打开 hexo 站点的根目录，找到_config.yml 文件，使用记事本打开。文档的最后将\n1234# Deployment    ## Docs: One-Command Deployment    deploy:       type: &#x27;&#x27;\n\n修改为\n123456# Deployment    ## Docs: One-Command Deployment    deploy:       type: git      repository: git@github.com:用户名/用户名.github.io.git      branch: master\n\n保存。\n到这里就可以进入 git 终端，输入命令 hexo d 将 public 文件夹提交到仓库中。不一会就能看见仓库中出现了一个新的 master 分支，里面有上传的 public 文件夹的内容。\n生成 GitHub Pages进入刚刚生成的仓库。\n\nsource 选择 Deploye from a branch，Branch 选择 master 分支，选择好之后点 save 保存设置。稍等一分钟，就可以看到 “Your site is alive at xxxx” 的提示，点击 visit 就可以在自己的网站上看到刚刚配置好的博客了。\n\n附：\nhexo 常用命令如下：\n1234567891011121314npm install hexo -g #安装Hexo    npm update hexo -g #升级    hexo init #初始化博客    ​    hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章    hexo g == hexo generate #生成    hexo s == hexo server #启动服务预览    hexo d == hexo deploy #部署    ​    hexo server #Hexo会监视文件变动并自动更新，无须重启服务器    hexo server -s #静态模式    hexo server -p 5000 #更改端口    hexo server -i 192.168.1.1 #自定义 IP    hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令\n\n更改域名我的域名是在 namesilo 上购买的，非常便宜（xyz 后缀的一年 17r）。\n在主页搜索自己想要的域名，添加到购物车。\n\n点击 checkout 跳转到结算界面。可以选择添加 1 美元的优惠码。我买的时候不知道为什么没有用，这里就不再介绍。确认之后点 checkout，之后选择支付宝扫码付款即可。\n\n这里着重介绍购买之后如何进行域名的更改。\n这里是 My Account 界面，点击 manage 进入域名管理页。\n\n找到刚刚购买的域名，点击蓝色地球图标。\n\n首先将默认的所有配置删除，再点击 CNAME 添加一条配置。TTL 默认改为 3600 即可。\n\n还需要添加 4 条 A 记录，指向以下 4 个 ip 地址：\n1234185.199.108.153    185.199.109.153    185.199.110.153    185.199.111.153\n\n回到 GitHub，将购买的域名也添加到 GitHub Pages 的设置上。\n\n等待 3-4 个小时，就可以在全球使用这个域名访问你的 GitHub Pages 博客啦！\n常见问题解决方法重装系统之后，原本的环境都无法找回复制好原本的文章，重新完成 markdown 格式的文档。重新安装 git 和 node.js，生成 ssh 密钥，建立连接后重新建立 hexo 站点并上传到原来仓库。原本仓库的 master 分支里内容可以删除掉，防止新旧主题冲突。\nhexo d 时报错12345678910111213ssh: Could not resolve hostname github.com: Name or service not known    fatal: Could not read from remote repository.    ​    Please make sure you have the correct access rights    and the repository exists.    FATAL Something&#x27;s wrong. Maybe you can find the solution here: Page Not Found    ocs/troubleshooting.html    Error: Spawn failed        at ChildProcess.&lt;anonymous&gt; (E:\\MyBlog\\node_modules\\hexo-util\\lib\\spawn.js:5    1:21)        at ChildProcess.emit (node:events:514:28)        at cp.emit (E:\\MyBlog\\node_modules\\cross-spawn\\lib\\enoent.js:34:29)        at ChildProcess._handle.onexit (node:internal/child_process:291:12)\n\n报以上错误，一般是网络连接出现问题了，无法上传到 github 对应仓库，可以尝试检查网络设置，或者查看是否是域名绑定不对出现的问题。\n图片无法显示在写本文的过程中，我想插入一些图片，但是发现图片只能在 typora 上显示，hexo g 后无法在网页上显示，遂去查看各种教程，发现大部分都是让下载一个插件，然而还是不成功，据说是因为 hexo 版本更新了但是插件还没有更新。\n那么我只能开始自己找解决办法。\n首先在 hexo clean、hexo g 之后找到 public 文件夹，找到 md 文档生成的 html 文件，查看显示图片的那一行源代码：\n12&lt;p&gt;&lt;img src=&quot;/1.jpg&quot; srcset=&quot;/img/loading.gif&quot; lazyload&gt;&lt;/p&gt;    &lt;p&gt;&lt;img src=&quot;/2.jpg&quot; srcset=&quot;/img/loading.gif&quot; lazyload&gt;&lt;/p&gt;\n\n而 typora 中我此时已经改成仅包含文件名，不包含路径。\n12![](1.jpg)    ![](2.jpg)\n\n于是我尝试把 public&#x2F;img 中的图片路径补充完整。怎么补充呢？首先要找到 html 的位置以及图片的位置。public 文件夹就是由 md 文档生成的。查找一番后发现 img 中才存在图片。\n由此继续发现开启 post_asset_folder 之后，只是在 hexo n xxx 新文章的时候同时创建一个同名的文件夹，图片放文件夹里，但是 hexo g 的时候这个同名文件夹里的图片并不会在 public 的 html 文件夹中生成相同图片，依旧只有 public&#x2F;img 中有图片：\n\n那么我们可以知道 public 和 resource 文件夹下的对应关系。\n\n搞清楚之后，我们的思路就是：html 中图片路径一定是相对路径而不能写绝对路径，因为最终发布到 GitHub 上去的只有 public 文件夹的内容，这个相对路径一定是基于 public 文件夹内的路径。\n因此我重新把文章配图复制到 img 下，新建一个本文的文件夹存放配图。以我的路径示例，在 typora 中补充完整图片路径：\n12![](/img/articles/hexo+github/1.jpg)    ![](/img/articles/hexo+github/2.jpg)\n\n再次 hexo clean、hexo g、hexo s 之后查看，果然图片出现了。发布到 GitHub Pages 同样没有问题。问题解决。\n使用此解决方法，需要注意：\n\n每次发布文章，图片需要放在 &#x2F; resource&#x2F;img 下，这样才能保证每次 hexo g 都能自动同步到 public 文件夹中。\ntypora 中写相对路径。\ntypora 中无法解析图片显示出来，但是在网页上可以显示出来。\n\n我的方法仅提供一个思路，每个人具体的问题可能有些不同，也不能盲从，还是需要结合实际来解决。\nhexo d 后进入页面显示 404绑定好新域名后，再次 hexo d 上传文章发现页面 404 了。后来查看仓库里的 CNAME 文件发现不见了，而且自定义域名失效。\n查了一下，发现需要手动在 resource 下添加一个不带后缀的文件 CNAME，全大写。里面写自定义的域名。再重新hexo g -d即可。\n\n–\n","slug":"Hexo+GitHub 搭建个人博客并发布文章（附常见问题解决方法）","date":"2023-12-05T11:43:09.954Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"81dd16a88c7b3bab33afb0177c60d050","title":"个人深度学习工作站配置","content":"1. 个人深度学习工作站详情从第二章开始\n2. 系统篇系统选择 DL 开发里面最常用的 Ubuntu，最新的稳定版本是 20.04，安装过程需要准备一个 U 盘作为系统启动盘。\n2.1 安装 Ubuntu 20.04 系统\n在官网下载 Ubuntu 镜像：Ubuntu 20.04.1 LTS (Focal Fossa)，选择 Desktop Image 版本，得到. iso 的镜像文件。\nWindows 下使用 UltraISO 工具打开. iso 镜像文件，并将其写入到一个 U 盘，得到系统启动盘：\n\n\n\n将 U 盘插到服务器上，开机按del键（具体什么键跟主板型号有关）选择启动项进入临时的 Ubuntu 系统，在图形界面中选择 Install Ubuntu，所有配置都可以使用默认的，改一下用户名和密码即可。 这里建议使用英文作为默认语言，省得给自己日后开发找麻烦哈。\n\n\n安装过程中会联网下载一些软件包更新，可以直接点 skip 掉，在安装好系统之后再手动更新也是一样的。\n\n进入系统后设置一下 root 账户密码：\n\n1sudo passwd root\n\n\n同时为了避免每次 sudo 都要输入密码，这里配置一下visudo：\n\n1sudo visudo\n\n在文件最后加上一句（改为自己的用户名）：\n1pengzhihui ALL=(ALL) NOPASSWD: ALL\n\n2.2 配置国内镜像软件源为了提升后续安装软件时的幸福感，第一步当然先要替换一下软件源。\n\n备份原来的源：\n\n1cp /etc/apt/sources.list /etc/apt/sources.list.bak\n\n\n将源的内容设置为阿里云镜像：\n\n1sudo vim /etc/apt/sources.list\n\n内容改为：\n12345678910deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse\n\n\n更新软件列表：\n\n12sudo apt updatesudo apt upgrade\n\n也可以去网上搜其他镜像，在我这边经测试阿里云是最快的。另外也可以在图形桌面环境下打开Software &amp; Updates软件，在里面也有网速测试并选择最佳源的功能。\n2.3 安装 Python 和 pip\nUbuntu 系统默认自带 python，有版本需求的话也可以自己安装一下（不安装也行因为后面会安装 conda 环境）：\n\n12sudo apt install python3sudo apt install python3-pip\n\n\n不管是不是自己安装的 python，替换 python 的 pip 源建议是一定操作一下的，pip 安装速度会快很多：\n\n12cd ~mkdir .pip\n\n直接新建并编辑 pip.conf：\n1sudo vim ~/.pip/pip.conf\n\n改为以下内容（这里用的清华源，也可以试一下阿里、豆瓣等源）：\n1234[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple/ [install]trusted-host = pypi.tuna.tsinghua.edu.cn\n\n\n更改默认 python 版本，python 目录默认链接的是 python2，而现在基本都是用 python3 开发了，每次都输入 python3 很麻烦所以这里直接更换默认的 python 命令链接。\n\n把原来的 python 软链接删掉：\n1sudo rm /usr/bin/python\n\n新建一个软链接：\n12sudo ln -s /usr/bin/python3 /usr/bin/pythonsudo ln -s /usr/bin/pip3 /usr/bin/pip\n\n现在输入 python 就会进入 python3 环境了。\n2.4 配置 SSH &amp; 远程桌面纯净安装的系统里面默认没有开启 SSH，我们手动安装一下。\n\n安装 ssh：\n\n1sudo apt install ssh\n\n会自动安装好很多依赖包并启动服务，完成之后用 XShell 等软件就可以 SSH 登录服务器了。\n\n安装 xrdp\n\nXrdp 是一个微软远程桌面协议（RDP）的开源实现，它允许我们通过图形界面控制远程系统。这里使用 RDP 而不是 VNC 作为远程桌面，是因为 Windows 自带的远程桌面连接软件就可以连接很方便，另外 RDP 在 Windows 下的体验非常好，包括速度很快（因为压缩方案做得比较好），可以直接在主机和远程桌面之间复制粘贴等等。\n\n\n\n\n\n\n\n\n\n\n有的 Xwindow 软件是不太兼容 xrdp 的（比如 ubuntu 18.04 的默认桌面），但是 ubuntu 20.04 使用的 Gnome 是完全 ok 的。\n安装过程如下：\n1sudo apt install xrdp\n\n安装完成 xrdp 服务将会自动启动，可以输入下面的命令验证它：\n1sudo systemctl status xrdp\n\n默认情况下，xrdp 使用/etc/ssl/private/ssl-cert-snakeoil.key，它仅仅对 ssl-cert 用户组成语可读，所以需要运行下面的命令，将 xrdp 用户添加到这个用户组：\n12sudo adduser xrdp ssl-cert  sudo systemctl restart xrdp\n\n然后使用 Windows 自带的远程桌面软件连接服务器 IP 地址或者域名就行了。\n2.5 安装 frp 进行内网穿透前面介绍的 SSH 和远程桌面都是需要在局域网下通过 IP 地址进行连接的，而我们配置一台服务器最重要的诉求，应该是可以随时随地去访问服务器。\n那在家里面，网络运营商提供的网络服务通过路由器路由到各个设备，此时路由器会同时具备内网地址（路由器之内，局域网，LAN，也就是 192.168.x.x）和外网地址（路由器之外，互联网，WAN）。但是其实这个 WAN 口的 IP 并不是真正的 “公网 IP”，而时经过了多层的 NAT 转换之后的地址，外网的设备是不能通过这个地址访问到路由器的。这个问题的原因是 ipv4 地址池紧张，如果运营商给每家的路由器都安排一个公网 ip 的话，那 ip 地址早就不够用了呀。\n因此为了能让外网访问到我们局域网内的设备，就需要跟中国电信等运营商申请公网 ip（现在能申请到的概率也已经不大了，而且即使申请到也不是所有端口都可以使用的），或者我们自己动手做一些操作来达到同样的目的。\n有几种方法:\n\n可以直接用类似花生壳这样的 DDNS 服务平台做转发实现内网穿透，优点是比较简单稳定，缺点是需要持续付费，而且速度和延迟效果一般，而且每加一个端口都要额外付费。\n也可以像我一样使用 frp 之类的软件做反向代理来实现内网穿透，这个方案也是需要你有一台带公网 IP 的云服务器的，优点就是完全可控，自己想配置多少个端口的穿透都可以，速度跟你的云服务器带宽有关。\n\n\n\n\n\n\n\n\n\n\n为什么需要多个端口？ 是因为不同应用占用的端口不同，比如我们的 SSH 走的是 22 号端口，而远程桌面的 rdp 走的是 3389 号端口，如果需要自建 Web 服务的话则是走 80&#x2F;443 端口、想把工作站作为上外网的代理服务器的话会需要 1080 端口等等… 所以用上面第二个方案显然会方便很多，而且云服务器也不贵，我在腾讯云上购买一年只要 200 左右。\n下面介绍如何安装配置 frp：\nfrp 分为 frps（server）和 frpc（client）两个包 ，其中前者安装到我们的云服务器上，后者安装在需要被外网访问到的各个设备上，这里就是指我们的深度学习工作站。\n云服务器端：\n去这里下载适合你服务器系统的 frp 软件，我这里是用的是腾讯云 64 位 Ubuntu16.04 所以选择 frp_0.34.3_linux_amd64.tar.gz，下好之后解压：\n1tar -zxvf frp_0.34.3_linux_amd64.tar.gz\n\n我们需要编辑的文件是 frps.ini :\n内容改为：\n1234567[common] bind_port = 7000 # frp服务的端口号，可以自己定 dashboard_port = 7500 # frp的web界面的端口号 dashboard_user = user # web界面的登陆账户，自己修改 dashboard_pwd = pass # web界面的登陆密码，自己修改 authentication_method = token token = xxxxx # frp客户端连接时的密码，自己修改\n\n保存配置后，使用该命令启动：\n1./frps -c ./frps.ini\n\n在浏览器输入 [云服务器的公网ip]:7500 即可访问到 frp 的 web 管理界面。\n\n\n\n\n\n\n\n\n\n注意，可能需要去云服务器控制台配置安全组规则 开放以上涉及到的端口，否则无法访问。\n本地的深度学习服务器端：\n\n下载相应版本的 frpc 软件包（跟刚刚一样的）：Releases · fatedier&#x2F;frp (github.com)，这里选 amd64 的，下好之后解压到一个临时文件夹。\n修改 frpc.ini 配置文件，内容如下：\n\n1234567891011121314151617[common] server_addr = xx.xx.xx.xx # 你的云服务器的公网ip authentication_method = token token = xxxxx # 刚刚配置的frp连接密码  server_port = 7000 # 刚刚配置的frp服务端口 ​ [Fusion-ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 20022 ​ [Fusion-rdp] type = tcp local_ip = 127.0.0.1 local_port = 3389 remote_port = 23389\n\n通过上面的脚本就可以把对于云服务器特定端口的访问给重定向到本地服务器的某个端口了，简单地讲就是：假如我用 SSH 客户端访问 [云服务器ip]:20022，就可以经过反向代理直接访问到[本地的训练服务器ip]:22；同理需要连接远程桌面的话，只需要访问[云服务器ip]:23389就可以了。\n当然你也可以修改脚本添加更多映射~\n\n添加开机自动启动的脚本，新建一个文件内容如下：\n\n文件名/etc/systemd/system/frpc.service，注意修改其中的路径：\n1234567891011121314151617[Fusion] Description=Frp Server Daemon After=syslog.target network.target Wants=network.target ​ [Service] Type=simple ExecStart=/usr/local/bin/frp/frpc -c /usr/local/bin/frp/frpc.ini # 修改为你的frp实际安装目录 ExecStop=/usr/bin/killall frpc #启动失败1分钟后再次启动 RestartSec=1min KillMode=control-group #重启控制：总是重启 Restart=always ​ [Install] WantedBy=multi-user.target\n\n然后执行以下命令启用脚本：\n12sudo systemctl enable frpc.servicesudo systemctl start frpc.service\n\n通过下面的命令查看服务状态，如果是 running 的话就说明可以了：\n1sudo systemctl status frpc.service\n\n\n\n\n\n\n\n\n\n\n这里顺便提一下，按照习惯一般把上面的 frp 软件解压防止在/usr/local/bin目录下。Linux 的软件安装目录是也是有讲究的，理解这一点，在对系统管理是有益的\n\n/usr：系统级的目录，可以理解为C:/Windows/\n/usr/lib：可以理解为C:/Windows/System32\n/usr/local：用户级的程序目录，可以理解为C:/Progrem Files/，用户自己编译的软件默认会安装到这个目录下\n/opt：用户级的程序目录，可以理解为D:/Software，opt 有可选的意思，这里可以用于放置第三方大型软件（或游戏），当你不需要时，直接rm -rf掉即可。在硬盘容量不够时，也可将/opt单独挂载到其他磁盘上使用\n\n\n\n\n\n\n\n\n\n\n源码放哪里？\n\n/usr/src：系统级的源码目录\n/usr/local/src：用户级的源码目录。\n\n2.6 安装 SAMBA 服务如果能把服务器上的磁盘直接挂载到我们使用的 Windows 个人 PC 上是不是很爽？\n如开头的视频里面演示的，可以通过建立局域网 SAMBA 服务来实现这个效果：\n\n安装samba 和samba-common-bin\n\n1sudo apt-get install samba samba-common-bin\n\n\n配置 &#x2F; etc&#x2F;samba&#x2F;smb.conf 文件\n\n1sudo nano /etc/samba/smb.conf\n\n在最后一行后面加入：\n12345678910111213141516# 共享文件夹显示的名称[home]# 说明信息comment = Fusion WorkStation Storage# 可以访问的用户valid users = pengzhihui,root# 共享文件的路径path = /home/pengzhihui/# 可被其他人看到资源名称（非内容）browseable = yes# 可写writable = yes# 新建文件的权限为 664create mask = 0664# 新建目录的权限为 775directory mask = 0775\n\n可以把配置文件中你不需要的分享名称删除，例如 [homes], [printers] 等。\n运行这个命令测试一下配置文件是否有错误，根据提示做相应修改：testparm\n\n添加登陆账户并创建密码\n\n必须是 linux 已存在的用户：\n1sudo smbpasswd -a pi\n\n然后重启服务即可：\n1sudo /etc/init.d/samba-ad-dc restart\n\n接下来可以在 Windows 的网络中发现设备了：\n\n但是可能会出现无法点开的情况，这里需要在 Windows 的凭据管理器中添加账户信息（开始菜单里搜索凭据管理器即可打开），点击添加 Windows 凭据，输入你的服务器名称和账户密码：\n\n接下来就可以点进去看到服务器上的文件了。 为了更加方便地进行文件交互，我们添加对应的磁盘到 Windows 资源管理器的此电脑中：\n\n选择刚刚服务器的网络路径即可添加：\n\n3. DL 开发环境配置篇配置这台服务器的主要作用就是做深度学习训练，所以 GPU 相关的驱动和环境时肯定要安排好的，网上资料很多很杂，这里梳理出了最便捷可靠的安装方法供大家参考~\n3.1 安装 Nvidia 显卡驱动最简单的方式是通过系统的软件与更新来安装：\n\n进入系统的图形桌面，打开Software &amp; Updates软件，可以看到标签栏有一个Additional Drivers：\n\n\n选择第一个安装 Nvidia 官方驱动（第二个是开源驱动）即可，根据网络情况稍等大概十分钟，安装完重启服务器。\n\n重启完之后更新一下软件：\n\n12sudo apt updatesudo apt upgrade\n\n这里会连带 Nvidia 的驱动一起升级一遍，更新到最新的驱动；更新完可能会出现 nvidia-smi 命令报错，再重启一下就解决了。\n3.2 安装 CUDA如果之前安装了旧版本的 cuda 和 cudnn 的话，需要先卸载后再安装：\n1sudo apt-get remove --purge nvidia*\n\n然后按照前面的方法重新安装显卡驱动，安装好了之后开始安装 CUDA：\n\n去官网下载 cuda 安装包：CUDA Toolkit 11.0 Download | NVIDIA Developer，相关选项如下（根据实际情况选择）：\n\n\n\n运行下面的命令进行安装：\n\n12chmod +x cuda_11.0.2_450.51.05_linux.runsudo sh ./cuda_11.0.2_450.51.05_linux.run\n\n可能会报一个警告：\n\n前面已经卸载过旧版本了直接 Continue 就好。然后根据提示选择安装选项，注意不要勾选第一个安装显卡驱动的，因为之前已经安装过了。 安装完成后提示\n\n\n根据上图提示需要配置环境变量：\n\n1nano  ~/.bashrc\n\n再文件最后加入以下语句：\n123export CUDA_HOME=/usr/local/cuda-11.0export LD_LIBRARY_PATH=$&#123;CUDA_HOME&#125;/lib64export PATH=$&#123;CUDA_HOME&#125;/bin:$&#123;PATH&#125;\n\n然后使其生效：\n1source ~/.bashrc\n\n\n可以使用命令nvcc -V查看安装的版本信息：\n\n\n也可以编译一个程序测试安装是否成功，执行以下几条命令：\n123cd ~/Softwares/cuda/NVIDIA_CUDA-11.0_Samples/1_Utilities/deviceQuery make./deviceQuery\n\n正常的话会有相应输出，打印显卡的信息。\n3.3 安装 CuDNN进入到 CUDNN 的下载官网：cuDNN Download | NVIDIA Developer，然点击 Download 开始选择下载版本，当然在下载之前还有登录，选择版本界面如下：\n\n我们选择和之前 cuda 版本对应的 cudnn 版本：\n\n下载之后是一个压缩包，对它进行解压，命令如下：\n1tar -xzvf cudnn-11.0-linux-x64-v8.0.5.39.tgz\n\n使用以下两条命令复制这些文件到 CUDA 目录下：\n12sudo cp cuda/lib64/* /usr/local/cuda-11.0/lib64/ sudo cp cuda/include/* /usr/local/cuda-11.0/include/\n\n拷贝完成之后，可以使用以下命令查看 CUDNN 的版本信息：\n1cat /usr/local/cuda/include/cudnn_version.h | grep CUDNN_MAJOR -A 2\n\n可以看到版本信息如下，为8.0.5：\n\n3.4 安装 Conda 环境不同的训练框架和版本可能会需要不同的 python 版本相对应，而且有的包比如 numpy 也对版本有要求，所以比较优雅的方法是给每个配置建立一个虚拟的 python 环境，在需要的时候可以随时切换，而不需要的时候也能删除不浪费磁盘资源，那在这方面 conda 是做得最好的。\n下面介绍怎么安装 conda：\n\n在 Anaconda 官网下载 Linux 安装包：Anaconda | Individual Edition\n运行下面的命令安装：\n\n123chmod +x Anaconda3-2020.11-Linux-x86_64.sh./Anaconda3-2020.11-Linux-x86_64.sh\n\n一路按 ENTER 确认，然后根据提示输入 yes，这里我为了目录整洁不安装在默认路径，设置为下面的路径：/home/pengzhihui/Softwares/anaconda\n然后会询问你是否要初始化 conda，输入 yes 确认，重开终端窗口之后，就可以看到 conda 环境可用了（base 代表默认环境）：\n\nconda 的使用方法网上搜一下有很多，这里就不赘述了。\n3.5 安装 Nvidia-DockerDocker 也是虚拟化环境的神器，前面说的 conda 虽然可以提供 python 的虚拟环境并方便地切换，但是有的时候我们的开发环境并不只是用到 python，比如有的 native 库需要对应 gcc 版本的编译环境，或者进行交叉编译时哟啊安装很多工具链等等。如果这些操作都在服务器本地上进行，那时间久了就会让服务器的文件系统非常杂乱，而且还会遇到各种软件版本冲突问题。\nDocker 就可以很好地解决这些问题，它其实可以理解为就是一个非常轻量化的虚拟机，我们可以在宿主服务器上新建很多个这种被称为容器的虚拟机，然后在里面配置我们的开发环境，且这些配置好的环境是可以打包成镜像的，方便随时做分享和重用；不需要的时候，我们直接删除容器就好了，其资源是和我们的服务器宿主机完全隔离的。\nDocker 的具体使用可以自己搜索一下很多教程，这里主要介绍如何把 GPU 暴露给 Docker 的容器（因为大家都知道像是 VMware 这种虚拟机里面都是无法共享宿主机的 GPU 的），是通过nvidia-docker实现的。\n\n\n\n\n\n\n\n\n\n以前为了配置 nvidia-docker，需要安装完 docker 之后再安装单独的 nvidia docker2，而现在只需要安装 nvidia container toolkit 即可，更加方便了。\n\ndocker 安装 官网上有详细的介绍：Install Docker Engine on Ubuntudocs.docker.com 或者运行下面的命令安装：\n\n1234sudo apt-get updatesudo apt-get install docker.iosystemctl start dockersystemctl enable docker\n\n可以运行这条命令检查是否安装成功：\n1docker version\n\n\n安装 NVIDIA Container Toolkit\n\n\n官网安装步骤：NVIDIA&#x2F;nvidia-docker: Build and run Docker containers leveraging NVIDIA GPUs (github.com) 或者直接运行下面的命令：\n123456789##首先要确保已经安装了nvidia driver # 2. 添加源 distribution=$(. /etc/os-release;echo $ID$VERSION_ID) curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add - curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list ​ # 2. 安装并重启 sudo apt-get update &amp;&amp; sudo apt-get install -y nvidia-container-toolkit sudo systemctl restart docker\n\n安装完成后可以新建一个容器测试一下：\n1sudo docker run -it --name test_nvidia_docker --gpus all nvidia/cuda:11.1-base\n\n其中最后的参数nvidia/cuda:11.1-base 是 Nvidia 官方的镜像，需要根据工作站主机中实际安装的 cuda 版本进行修改，版本可以用nvcc -V查看。\n进入容器之后可以跑一下nvidia-smi命令看看：\n\n现在可以在 docker 里面正常使用 GPU 啦~\n3.6 测试这里通过一个简单的 python 脚本测试一下 GPU 训练是否一切正常，跑一个 DL 里面的 Hello World 程序，通过两种方法测试：本地 conda 和 docker 虚拟机。\n\n\n\n\n\n\n\n\n\n以后的开发过程中一般还是使用 Docker 的方式来进行更为优雅。\n1. 本地 Conda 环境方式：先用 conda 新建一个 python3.8+pytorch1.7+cuda11.0 的虚拟环境：\n1conda create --name python_38-pytorch_1.7.0 python=3.8\n\n创建完成后进入环境：\n1conda activate python_38-pytorch_1.7.0\n\n检查一下是否切换到所需环境了：\n1which pip\n\n如果看到使用的确实是我们设置的环境目录中的 pip 的话说明就 ok。\n接下来在环境中安装 pytorch，可以参考官网的安装命令：Start Locally | PyTorch\n\n输入以下命令进行安装：\n1pip install torch==1.7.0+cu110 torchvision==0.8.1+cu110 torchaudio===0.7.0 -f https://download.pytorch.org/whl/torch_stable.html\n\n环境配置就完成了，下面新建一个简单的测试脚本验证功能，新建mnist_train.py，内容如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import torchimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optimimport torch.backends.cudnn as cudnnfrom torchvision import datasets, transformsclass Net(nn.Module):    def __init__(self):        super(Net, self).__init__()        self.conv1 = nn.Conv2d(1, 10, kernel_size=5)        self.conv2 = nn.Conv2d(10, 20, kernel_size=5)        self.conv2_drop = nn.Dropout2d()        self.fc1 = nn.Linear(320, 50)        self.fc2 = nn.Linear(50, 10)    def forward(self, x):        x = F.relu(F.max_pool2d(self.conv1(x), 2))        x = F.relu(F.max_pool2d(self.conv2_drop(self.conv2(x)), 2))        x = x.view(-1, 320)        x = F.relu(self.fc1(x))        x = F.dropout(x, training=self.training)        x = self.fc2(x)        return F.log_softmax(x, dim=1)def train(model, device, train_loader, optimizer, epoch):    model.train()    for batch_idx, (data, target) in enumerate(train_loader):        data, target = data.to(device), target.to(device)        optimizer.zero_grad()        output = model(data)        loss = F.nll_loss(output, target)        loss.backward()        optimizer.step()        if batch_idx % 10 == 0:            print(&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\\tLoss: &#123;:.6f&#125;&#x27;.format(                epoch, batch_idx * len(data), len(train_loader.dataset),                       100. * batch_idx / len(train_loader), loss.item()))def main():    cudnn.benchmark = True    torch.manual_seed(1)    device = torch.device(&quot;cuda&quot;) if torch.cuda.is_available() else torch.device(&quot;cpu&quot;)    print(&quot;Using device: &#123;&#125;&quot;.format(device))    kwargs = &#123;&#x27;num_workers&#x27;: 1, &#x27;pin_memory&#x27;: True&#125;    train_loader = torch.utils.data.DataLoader(        datasets.MNIST(&#x27;./data&#x27;, train=True, download=True,                       transform=transforms.Compose([                           transforms.ToTensor(),                           transforms.Normalize((0.1307,), (0.3081,))                       ])),        batch_size=64, shuffle=True, **kwargs)    model = Net().to(device)    optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.5)    for epoch in range(1, 11):        train(model, device, train_loader, optimizer, epoch)if __name__ == &#x27;__main__&#x27;:    main()\n\n运行脚本，正常的话就可以看到训练输出了：\n\n2. Docker 环境方式：首先还是新建一个 Docker 镜像，运行下面的命令：\n12345sudo docker run  -it  --name train_mnist \\ -v /etc/timezone:/etc/timezone \\ -v /etc/localtime:/etc/localtime \\ -v /home/pengzhihui/WorkSpace/_share:/home/workspace/_share  \\ --gpus all nvidia/cuda:11.1-base\n\n就进入到了带 gpu 的 ubuntu20.04 容器中，效果可以参考文章开头的视频。按照前面的配置方法同样配置好 pytorch 和其他软件包，然后运行同样的脚本，也可以得到上述输出，说明 gpu 在 docker 中正常工作。\n4. 工作站维护篇4.1 工作站系统备份还原\n备份\n\n由于 Linux 本身万物皆文件的设计理念，加上 root 用户对几乎全部的系统文件都有访问和更改的权限，因此 Linux 系统的备份和还原其实非常简单，我们直接打包整个根文件系统就可以了。\n我们可以使用 tar 命令来打包并压缩文件系统，不过这里在打包的过程中需要排除一些不需要文件，或者与新系统文件冲突的文件，包括/tmp、/proc、/lost+found 等目录。\n找一个你想保存备份文件的目录，运行下面的命令：\n1tar -cvpzf ubuntu_backup@`date +%Y-%m+%d`.tar.gz --exclude=/proc --exclude=/tmp --exclude=/boot  --exclude=/lost+found --exclude=/media --exclude=/mnt --exclude=/run /\n\n我们会得到一个名为backup.tgz的压缩文件，这个文件包含我们需要备份的系统的全部内容。\n2. 还原\n如果系统没有出问题可以正常启动的话，那直接在刚刚的压缩包找找到想还原的文件替换就好了。而如果系统无法启动了，或者说想换一块硬盘克隆一样的系统，那么可以按一下步骤操作：\n\n重装干净的 Ubuntu 系统。跟上面介绍的一样，使用 U 盘给目标磁盘重装一个干净的系统，这一步是为了省去自己分配存储空间和挂载的麻烦，如果你会自己配置的话那也可以不做这一步。\n再次使用 U 盘进入系统，这次选择try ubuntu without installing，然后可以看到挂载好的刚刚安装了干净系统的另一个盘，我们在这里对盘里的根文件系统进行一些文件的提取：\n\n12345678910111213141516171819202122sudo su# 在tryUbuntu根目录下有media文件夹，里面是U盘文件夹和新安装的系统文件夹，在在里分别用（U盘）和（UBUNTU）表示cd /media/（U盘）mount -o remount rw ./ ​# 将新系统根目录下/boot/grub/grub.cfg文件备份到U盘中sudo cp /media/(Ubuntu)/boot/grub/grub.cfg ./     ​# 将新系统根目录下/etc/fstab文件备份到U盘中，fstab是与系统开机挂载有关的文件，grub.cfg是与开机引导有关的文件，所以这一步至关重要sudo cp /media/(UBUNTU)/etc/fstab ./ ​# 这一步删除新装ubuntu全部的系统文件，有用的fstab及grub.cfg已经备份cd /media/(UBUNTU)sudo rm -rf ./* ​# 将U盘中backup.tgz复制到该目录下并解压缩cp /media/(U盘)/backup.tgz ./sudo tar xvpfz backup.tgz ./ ​# 创建打包系统时排除的文件sudo mkdir proc lost+found mnt sys media\n\n这一步完成后，在用我们在新系统中备份的fatab及grub.cfg 文件去替换压缩包中解压出来的同名文件，sudo reboot重启后就发现系统已经恢复到备份时的状态，包括各种框架，环境，系统设置~\n以上，后面有更新的话还会继续补充，希望对大家有帮助~","slug":"个人深度学习工作站配置","date":"2022-09-23T10:49:36.000Z","categories_index":"Python,deep learning,操作系统,环境配置,docker","tags_index":"Python,deep learning,操作系统,环境配置,docker","author_index":"Vegetabhl"},{"id":"b127aca37c275431a002f8f9388f3525","title":"Git使用","content":"注意：除非直接克隆，否则记得要先创建仓库，再进行后续的操作Git使用1 TortoiseGit下载和安装\n2 TortoiseGit使用1创建仓库先创建一个空文件夹，然后如下\n\n\n看到如下即创建成功\n\n2 克隆仓库(从远程仓库克隆一个)注意：克隆是会把这个仓库所有的分支都克隆下来，可以切换分支查看不同分支内容。而拉取（pull）可以选择只拉取某个分支的文件\n\n\n\n3 提交文件需要注意：\n1 如果需要远程推送到指定仓库，最好是先把这个仓库克隆下来，在这个仓库里面提交文件。因为这样相当于和远程仓库有了关联，在提交的时候远程仓库就默认是我们需要推送的仓库，不需要再指定推送到哪个仓库了。\n不克隆的话就需要手动指定要推送的仓库地址、\n2 提交不是推送，提交后远程仓库并不会出现提交的文件\n​              举例创建了两个要提交的文件index1.jsp、index2.jsp\n3.1 先添加到暂存区再提交（提交index1.jsp）选中要提交的文件index1.jsp，然后如下\n\n\n3.2 直接提交（提交index1.jps和index2.jsp）tortoisegit将添加到暂存区再提交文件这两步骤集成了一个步骤\n单击右键空白处选择如下\n\n4 推送本地仓库至远程仓库（push）4.1 在远程克隆下来的仓库里面进行提交，推送文件\n如果git没有配置密钥，第一次推送的时候会提示让输入github的账号密码进行一个认证。\n密钥绑定参照文章environment\n4.2 在本地仓库里面进行提交文件，推送文件到远程指定仓库本地仓库名可以和远程仓库名不同，但是不建议这样，最好是相同，养成遵循基本的规范好习惯。\n\n注意：如果远程仓库比本地新，即别人推送时间比我推送的早，则不会推送成功（除非强制推送，但实际多人开发中强烈不建议，这样做如果提交相同的文件，会覆盖掉别人提交的文件）。需要先把别人推送的拉取(pull)下来再推送。错误如下。\n\n5 拉取代码(pull)拉取并不会绑定远程仓库。在拉取远程仓库并修改后，提交推送到远程仓库时候需要指定远程仓库\n\n为什么要拉取：拉取的目的是为了保持数据一致性，避免出现5.2节注意事项提到的问题。\n注意：\n1 拉取不是创建仓库，拉取需要在已有的仓库里面进行。\n2 拉取（pull）可以选择只拉取某个分支的文件。而克隆是会把这个仓库所有的分支都克隆下来由用户来切换分支查看不同分支内容。\n6 创建分支注意：创建的是指的本地的分支\n\n7 切换分支\n8 合并分支\n","slug":"Git使用","date":"2022-05-18T03:39:36.000Z","categories_index":"网络,常用工具,项目,环境配置","tags_index":"网络,常用工具,项目,环境配置","author_index":"Vegetabhl"},{"id":"503c4c6e78f3754dcb43b085f6f6df4c","title":"gulimall","content":"谷粒商城1 环境配置(ubuntu20.04)1.1  安装jdk1.8https://blog.csdn.net/Deadly_97/article/details/111657908?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.essearch_pc_relevant&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.essearch_pc_relevant\n建议放在&#x2F;usr&#x2F;local 目录下面方便管理\n1.2  安装dockerhttps://www.cnblogs.com/songxi/p/12788249.html\n1.3  安装mysql(docker)dockerhub地址：\n1234567891011121314150 在docker hub搜索mysql镜像docker search mysql1 拉去mysql镜像sudo docker pull mysql:8.02 启动mysql容器# --name指定容器名字 -v目录挂载 -p指定端口映射  -e设置mysql参数 -d后台运行sudo docker run --name mysql -v /usr/local/mysql/data:/var/lib/mysql -v /usr/local/mysql:/etc/mysql/conf.d -v /usr/local/mysql/log:/var/log/mysql  -e MYSQL_ROOT_PASSWORD=root  -p 3306:3306 -d mysql:8.03 使用su - root（切换为root，这样就不用每次都sudo来赐予了）su - root4 进入mysql容器docker exec -it 容器名称|容器id bin/bash\n\n\n\n1.4 安装redis(docker)12345678910111213141516171819202122232425261 在docker hub搜索redis镜像docker search redis2 拉取redis镜像到本地docker pull redis:6.0.103 修改需要自定义的配置(docker-redis默认没有配置文件，自己在宿主机建立后挂载映射)sudo mkdir -p /usr/local/redis/confsudo mkdir /usr/local/redis/data创建并修改/usr/local/redis/conf/redis.confsudo vim /usr/local/redis/conf/redis.conf填入以下内容  bind 0.0.0.0 开启远程权限  appendonly yes 开启aof持久化4 启动redis服务运行容器docker run --name redis  -v /usr/local/redis/data:/data  -v /usr/local/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 -d redis:6.0.10  redis-server /usr/local/etc/redis/redis.conf 解释： -v /usr/local/redis/data:/data  # 将数据目录挂在到本地保证数据安全 -v /usr/local/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf   # 将配置文件挂在到本地修改方便 5  直接进去redis客户端。docker exec -it redis redis-cli\n\n\n\n1.5 git配置以下均在git bash中输入：\n123456789101112131415161718192021# 配置用户名git config --global user.name &quot;username&quot;  //(名字，随意写)# 配置邮箱git config --global user.email &quot;55333@qq.com&quot; // 注册账号时使用的邮箱# 配置ssh免密登录ssh-keygen -t rsa -C &quot;55333@qq.com&quot;三次回车后生成了密钥，也可以查看密钥cat ~/.ssh/id_rsa.pub浏览器登录码云(github操作一样)后，个人头像上点设置、然后点ssh公钥、随便填个标题，然后赋值ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6MWhGXSKdRxr1mGPZysDrcwABMTrxc8Va2IWZyIMMRHH9Qn/wy3PN2I9144UUqg65W0CDE/thxbOdn78MygFFsIG4j0wdT9sdjmSfzQikLHFsJ02yr58V6J2zwXcW9AhIlaGr+XIlGKDUy5mXb4OF+6UMXM6HKF7rY9FYh9wL6bun9f1jV4Ydlxftb/xtV8oQXXNJbI6OoqkogPKBYcNdWzMbjJdmbq2bSQugGaPVnHEqAD74Qgkw1G7SIDTXnY55gBlFPVzjLWUu74OWFCx4pFHH6LRZOCLlMaJ9haTwT2DB/sFzOG/Js+cEExx/arJ2rvvdmTMwlv/T+6xhrMS3 894548575@qq.com# 测试ssh -T git@gitee.com# 测试成功Hi unique_perfect! You&#x27;ve successfully authenticated, but GITEE.COM does not provide shell access.\n\n\n\n1.6 maven12345678910111213141516171819202122232425262728在maven配置文件配置配置阿里云镜像&lt;mirrors&gt;\t&lt;mirror&gt;\t\t&lt;id&gt;nexus-aliyun&lt;/id&gt;\t\t&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;\t\t&lt;name&gt;Nexus aliyun&lt;/name&gt;\t\t&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;\t&lt;/mirror&gt;&lt;/mirrors&gt;idea中配置 jdk 1.8 编译项目&lt;profiles&gt;\t&lt;profile&gt;\t\t&lt;id&gt;jdk-1.8&lt;/id&gt;\t\t&lt;activation&gt;\t\t\t&lt;activeByDefault&gt;true&lt;/activeByDefault&gt;\t\t\t&lt;jdk&gt;1.8&lt;/jdk&gt;\t\t&lt;/activation&gt;\t\t&lt;properties&gt;\t\t\t&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;\t\t\t&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;\t\t\t&lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;\t\t&lt;/properties&gt;\t&lt;/profile&gt;&lt;/profiles&gt;\n\n\n\n1.7 创建仓库123在github上新建仓库，仓库名gulimall，选择语言java，在.gitignore选中maven，许可证选Apache-2.0，如果是码云上创建的 开发模型可以选生产/开发模型，开发时在dev分支，发布时在master分支。创建如图所示\n\n\n1.8 新建项目并创建出以下服务模块123456789101112在IDEA中New Project from version control Git  复制刚才项目的地址，如https://github.com/Vegetabhl/gulimall.git创建以下模块商品服务product存储服务ware订单服务order优惠券服务coupon用户服务member每个模块导入web和openFeign如下图所示\n\n\n\n效果图如下\n\n12345678910111213141516171819202122232425创建父模块：在gulimall中创建pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.bhl.gulimall&lt;/groupId&gt;    &lt;artifactId&gt;gulimall&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;gulimall&lt;/name&gt;    &lt;description&gt;谷粒商城-聚合服务&lt;/description&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;modules&gt;        &lt;module&gt;gulimall-coupon&lt;/module&gt;        &lt;module&gt;gulimall-member&lt;/module&gt;        &lt;module&gt;gulimall-order&lt;/module&gt;        &lt;module&gt;gulimall-product&lt;/module&gt;        &lt;module&gt;gulimall-ware&lt;/module&gt;    &lt;/modules&gt;&lt;/project&gt;\n\n\n\n123456789101112131415161718192021222324252627在maven窗口刷新，并点击+号，找到刚才的pom.xml添加进来，发现多了个root。这样比如运行root的clean命令，其他项目也一起clean了。修改总项目的.gitignore，把小项目里的垃圾文件在提交的时候忽略掉target/pom.xml.tagpom.xml.releaseBackuppom.xml.versionsBackuppom.xml.nextrelease.propertiesdependency-reduced-pom.xmlbuildNumber.properties.mvn/timing.properties.mvn/wrapper/maven-wrapper.jar**/mvnw**/mvnw.cmd**/.mvn**/target.idea**/.gitignore**/README.md\n\n\n\n1.9 VSCode后台管理系统构建\n12345678在码云上搜索人人开源，我们使用renren-fast（后端代码），renren-fast-vue（前端代码）项目。（前后端分离）git clone https://gitee.com/renrenio/renren-fast.gitgit clone https://gitee.com/renrenio/renren-fast-vue.git下载到了桌面，我们把renren-fast移动到我们的项目文件夹（删掉.git文件），而renren-fast-vue是用VSCode打开\n\n\n\n\nrenren-fast\n\n12345678910111213141516171819202122在idea(root)项目里的pom.xml添加一个&lt;modules&gt;    &lt;module&gt;gulimall-coupon&lt;/module&gt;    &lt;module&gt;gulimall-member&lt;/module&gt;    &lt;module&gt;gulimall-order&lt;/module&gt;    &lt;module&gt;gulimall-product&lt;/module&gt;    &lt;module&gt;gulimall-ware&lt;/module&gt;    &lt;module&gt;renren-fast&lt;/module&gt;&lt;/modules&gt;然后打开renren-fast/db/mysql.sql，复制全部，在sqlyog中创建库gulimall_admin，粘贴进去并执行。=======================================================================================================================然后修改项目里renren-fast中的application.yml，修改application-dev.yml中的数库库的url: jdbc:mysql://192.168.86.129:3306/gulimall_admin?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghaiusername: rootpassword: root然后执行java下的RenrenApplication浏览器输入http://localhost:8080/renren-fast/ 得到&#123;“msg”:“invalid token”,“code”:401&#125;就代表无误\n\n\n\n\nrenren-fast-vue\n\n123456789101112131415161718用VSCode打开renren-fast-vue安装node：注意:node版本过高可能会有问题，比如node-sass这个依赖安装失败，一直报错此处选用node版本为12.18.2， npm版本为6.14.5接下来在VScode的终端进入项目输入以下内容：npm config set registry https://registry.npm.taobao.org  # 设置node仓库。提高下载速度修改项目 package.json \t&quot;node-sass&quot;: &quot;4.14.1&quot;   【 node12对应的sass版本是4.14  】npm i node-sass --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/npm installnpm run dev 浏览器输入localhost:8001 就可以看到内容了，登录账号admin 密码admin （记得后端和数据库服务启动，否则验证码没有）\n\n\n\n1.10 逆向工程搭建product\n1\n1234567891011121314git clone https://gitee.com/renrenio/renren-generator.git下载到桌面后，同样把里面的.git文件删除，然后移动到我们IDEA项目目录中，同样加入控制去配置pom.xml&lt;modules&gt;\t\t&lt;module&gt;gulimall-coupon&lt;/module&gt;\t\t&lt;module&gt;gulimall-member&lt;/module&gt;\t\t&lt;module&gt;gulimall-order&lt;/module&gt;\t\t&lt;module&gt;gulimall-product&lt;/module&gt;\t\t&lt;module&gt;gulimall-ware&lt;/module&gt;\t\t&lt;module&gt;renren-fast&lt;/module&gt;\t\t&lt;module&gt;renren-generator&lt;/module&gt;&lt;/modules&gt;\n\n2\n12345678910111213141516修改renren-generator的application.ymlurl: jdbc:mysql://192.168.86.129/gulimall_pms?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTCusername: rootpassword: root修改generator.propertiesmainPath=com.bhl # 主目录package=com.bhl.gulimall # 包名moduleName=product   # 模块名author=bhl  # 作者email=xxx@qq.com  # emailtablePrefix=pms_   # 我们的pms数据库中的表的前缀都有pms，注意：如果写了表前缀，每一张表对于的javaBean就不会添加前缀了\n\n3\n123456运行RenrenApplication。如果启动不成功，修改application中是port为80。访问http://localhost:80然后点击全部，点击生成代码。下载了压缩包解压压缩包，把main放到gulimall-product的同级目录下。\n\n这里需要注意：下载的时候必须将所有数据在一页展示出来，否则下载的文件不全（只会下载第一页展示的逆向工程文件）。\n4 通过common依赖来抽取公共依赖\n1234567然后在项目上右击（在项目上右击很重要）new modules— maven—然后在name上输入gulimall-common。在pom.xml中也自动添加了&lt;module&gt;gulimall-common&lt;/module&gt;在common项目的pom.xml（我们把每个微服务里公共的类和依赖放到common里。）中添加 ，具体添加的参照代码吧，后续添加的挺多的就不写了\n\n\n\n5 测试 测试与整合商品服务里的mybatisplus\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647在product项目的resources目录下新建application.ymlspring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    jdbc:mysql://192.168.86.129/gulimall_ums?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC    username: root    password: root# MapperScan# sql映射文件位置mybatis-plus:  mapper-locations: classpath:/mapper/**/*.xml  global-config:    db-config:      id-type: auto然后在主启动类上加上注解@MapperScan()@MapperScan(&quot;com.bhl.gulimall.product.dao&quot;)@SpringBootApplicationpublic class gulimallProductApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(gulimallProductApplication.class, args);    &#125;&#125;然后去单元测试，先通过下面方法给数据库添加内容@SpringBootTestclass gulimallProductApplicationTests &#123;    @Autowired    BrandService brandService;    @Test    void contextLoads() &#123;        BrandEntity brandEntity = new BrandEntity();        brandEntity.setDescript(&quot;hello&quot;);        brandEntity.setName(&quot;华为&quot;);        brandService.save(brandEntity);        System.out.println(&quot;保存成功&quot;);    &#125;&#125;\n\n\n\n6 其余服务的逆向工程和product一样，不再重复描述\n2  SpringCloud Alibaba2.1 环境spring-cloud-alibaba版本和springboot版本不对应可能会有一些小问题，下面是我的实际敲的过程中版本选择\n1234567891011121314151617&lt;spring-boot.version&gt;2.6.1&lt;/spring-boot.version&gt;在common的pom.xml中加入# 下面是依赖管理，相当于以后再dependencies里引spring cloud alibaba就不用写版本号， 全用dependencyManagement进行管理 &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;                &lt;version&gt;2021.1&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;\n\n\n\n2.2 Nacos-注册中心1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253先了解一下 Spring Cloud 应用如何接入 Nacos Discovery。1 首先，修改 common中的pom.xml 文件，引入 Nacos Discovery Starter。&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;2 在应用的common中的application.yml 配置文件中配置 Nacos Server 地址和微服务名称spring:  application:    name: gulimall-coupon  datasource:    driver-class-name: com.mysql.cj.jdbc.Driverurl: jdbc:mysql://192.168.86.129/gulimall_sms?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC    username: root    password: root  cloud:    nacos:      discovery:        server-addr: 127.0.0.1:8848mybatis-plus:  mapper-locations: classpath:/mapper/**/*.xml  global-config:    db-config:      id-type: autoserver:  port: 70003 我们要配置nacos服务器的地址，也就是注册中心地址，但是我们还没有nacos服务器，所以我们需要启动nacos server创建nacos服务器（软件官方可以下载）启动命令windows：startup.cmd -m standalone注意：nacos如何双击没反应需要陪一下JAVA_HOME这个环境变量4 使用 @EnableDiscoveryClient 注解开启服务注册与发现功能@EnableDiscoveryClient@SpringBootApplicationpublic class GulimallCouponApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(GulimallCouponApplication.class, args);    &#125;&#125;5 访问http://127.0.0.1:8848/nacos/  账号密码nacos出现页面，则表示访问成功\n\n同理按照上述步骤注册member\n2.3 测试member和coupon的远程调用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283想要获取当前会员领取到的所有优惠券。先去注册中心找优惠券服务，注册中心调一台优惠券服务器给会员，会员服务器发送请求给这台优惠券服务器，然后对方响应。Feign与注册中心spring cloud feign声明式远程调用feign是一个声明式的HTTP客户端，他的目的就是让远程调用更加简单。给远程服务发的是HTTP请求。1 会员服务想要远程调用优惠券服务，只需要给会员服务里引入openfeign依赖，他就有了远程调用其他服务的能力。     //调用方&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  2 在coupon中修改如下的内容                    //被调用方内@RequestMapping(&quot;coupon/coupon&quot;)public class CouponController &#123;    @Autowired    private CouponService couponService;    @RequestMapping(&quot;/member/list&quot;)    public R membercoupons()&#123;    //全系统的所有返回都返回R        // 应该去数据库查用户对于的优惠券，但这个我们简化了，不去数据库查了，构造了一个优惠券给他返回        CouponEntity couponEntity = new CouponEntity();        couponEntity.setCouponName(&quot;满100减10&quot;);//优惠券的名字        return R.ok().put(&quot;coupons&quot;,Arrays.asList(couponEntity));    &#125;3 这样我们准备好了优惠券的调用内容在member的配置类上加注解@EnableFeignClients(basePackages=&quot;com.bhl.gulimall.member.feign&quot;)，  //调用方告诉spring这里面是一个远程调用客户端，member要调用的接口@EnableFeignClients(basePackages=&quot;com.bhl.gulimall.member.feign&quot;)@EnableDiscoveryClient@SpringBootApplicationpublic class GulimallMemberApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(GulimallMemberApplication.class, args);    &#125;&#125;4 那么要调用什么东西呢？就是我们刚才写的优惠券的功能，复制函数部分，在member的com.bhl.gulimall.member.feign包下新建接口CouponFeignService：@FeignClient(&quot;gulimall-coupon&quot;) //告诉spring cloud这个接口是一个远程客户端，要调用coupon服务，再去调用coupon服务/coupon/coupon/member/list对应的方法，&quot;gulimall-coupon&quot;是远程服务的名字，可以从nacos处看到public interface CouponFeignService &#123;    @RequestMapping(&quot;/coupon/coupon/member/list&quot;)  //注意这个请求是被调用方的请求地址    public R membercoupons();//得到一个R对象&#125;5 然后我们在member的控制层写一个测试请求@RestController@RequestMapping(&quot;member/member&quot;)public class MemberController &#123;    @Autowired    private MemberService memberService;    @Autowired    CouponFeignService couponFeignService;    @RequestMapping(&quot;/coupons&quot;)    public R test()&#123;        MemberEntity memberEntity = new MemberEntity();        memberEntity.setNickname(&quot;张三&quot;);        R membercoupons = couponFeignService.membercoupons(); //假设张三去数据库查了后返回了张三的优惠券信息        // 打印会员和优惠券信息        return R.ok().put(&quot;member&quot;,memberEntity).put(&quot;coupons&quot;,membercoupons.get(&quot;coupons&quot;));    &#125;    6 重新启动服务\n\n\n\n注意：如果member报错couponFeignService注入失败需要在comomn的pom文件中加入以下的依赖。这其实也是上面说的版本冲突带来的一些小问题\n1234567&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;    &lt;version&gt;3.0.4&lt;/version&gt; 我这里是用的3.0.4版本，对应spring-boot是2.6.1,spring-cloud-alibaba-dependencies是2021.1&lt;/dependency&gt;\n\n\n\n2.4 Nacos-配置中心12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970我们还可以用nacos作为配置中心。配置中心的意思是不在application.properties等文件中配置了，而是放到nacos配置中心公用，这样无需每台机器都改。1 引入配置中心依赖，放到common中&lt;dependency&gt;     &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;     &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; 2 在coupons项目中创建/src/main/resources/bootstrap.properties ，这个文件是springboot里规定的，他优先级别application.properties高# 改名字，对应nacos里的配置文件名spring.application.name=gulimall-couponspring.cloud.nacos.config.server-addr=192.168.11.1:88483 @RestController@RequestMapping(&quot;coupon/coupon&quot;)public class CouponController &#123;    @Autowired    private CouponService couponService;    @Value(&quot;$&#123;coupon.user.name&#125;&quot;)//从application.properties中获取//不要写user.name，他是环境里的变量    private String name;    @Value(&quot;$&#123;coupon.user.age&#125;&quot;)    private Integer age;    @RequestMapping(&quot;/test&quot;)    public R test()&#123;        return R.ok().put(&quot;name&quot;,name).put(&quot;age&quot;,age);\t&#125;&#125;4 浏览器去nacos里的配置列表，点击＋号，data ID：gulimall-coupon.properties，配置# gulimall-coupon.propertiescoupon.user.name=&quot;张三&quot;      coupon.user.age=125 然后点击发布。重启coupon，http://localhost:7000/coupon/coupon/test&#123;&quot;msg&quot;:&quot;success&quot;,&quot;code&quot;:0,&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:12&#125;6 但是修改肿么办？实际生产中不能重启应用。在coupon的控制层上加@RefreshScope7 最终代码如下@RefreshScope@RestController@RequestMapping(&quot;coupon/coupon&quot;)public class CouponController &#123;    @Autowired    private CouponService couponService;    @Value(&quot;$&#123;coupon.user.name&#125;&quot;)//从application.properties中获取//不要写user.name，他是环境里的变量    private String name;    @Value(&quot;$&#123;coupon.user.age&#125;&quot;)    private Integer age;    @RequestMapping(&quot;/test&quot;)    public R test()&#123;        return R.ok().put(&quot;name&quot;,name).put(&quot;age&quot;,age);    &#125;&#125;8 重启后，在nacos浏览器里修改配置，修改就可以观察到能动态修改了nacos的配置内容优先于项目本地的配置内容。\n\n\n\n2.5 Nacos-配置中心进阶12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576在nacos浏览器中还可以配置：命名空间：用作配置隔离。（一般每个微服务一个命名空间）默认public。默认新增的配置都在public空间下\t开发、测试、开发可以用命名空间分割。properties每个空间有一份。\t在bootstrap.properties里配置spring.cloud.nacos.config.namespace=b176a68a-6800-4648-833b-be10be8bab00  \t# 可以选择对应的命名空间 ,即写上对应环境的命名空间ID\t也可以为每个微服务配置一个命名空间，微服务互相隔离配置集：一组相关或不相关配置项的集合。配置集ID：类似于配置文件名，即Data ID配置分组：默认所有的配置集都属于DEFAULT_GROUP。自己可以创建分组，比如双十一，618，双十二spring.cloud.nacos.config.group=DEFAULT_GROUP  # 更改配置分组最终方案：每个微服务创建自己的命名空间，然后使用配置分组区分环境（dev/test/prod）加载多配置集我们要把原来application.yml里的内容都分文件抽离出去。我们在nacos里创建好后，在coupons里指定要导入的配置即可。bootstrap.propertiesspring.application.name=gulimall-couponspring.cloud.nacos.config.server-addr=192.168.11.1:8848spring.cloud.nacos.config.namespace=ed042b3b-b7f3-4734-bdcb-0c516cb357d7  # # 可以选择对应的命名空间 ，即写上对应环境的命名空间IDspring.cloud.nacos.config.group=dev  # 配置文件所在的组spring.cloud.nacos.config.ext-config[0].data-id=datasource.ymlspring.cloud.nacos.config.ext-config[0].group=devspring.cloud.nacos.config.ext-config[0].refresh=truespring.cloud.nacos.config.ext-config[1].data-id=mybatis.ymlspring.cloud.nacos.config.ext-config[1].group=devspring.cloud.nacos.config.ext-config[1].refresh=truespring.cloud.nacos.config.ext-config[2].data-id=other.ymlspring.cloud.nacos.config.ext-config[2].group=devspring.cloud.nacos.config.ext-config[2].refresh=truedatasource.ymlspring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://192.168.1.103:3306/gulimall_sms?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai    username: root    password: rootmybatis.ymlmybatis-plus:  mapper-locations: classpath:/mapper/**/*.xml  global-config:    db-config:      id-type: autoother.ymlspring:  application:    name: gulimall-coupon  cloud:    nacos:      discovery:        server-addr: 192.168.11.1:8848server:  port: 7000\n\n2.5 网关","slug":"谷粒商城","date":"2022-02-22T13:01:19.605Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"97ee172f7fe606eea665b3155aa4c504","title":"mmdet","content":"mmdet安装详见官方文档，先装mmcv-full，再装mmdet\nhttps://mmdetection.readthedocs.io/zh_CN/v2.20.0/get_started.html\n训练-测试-推理修改在configs&#x2F;目录下找到要训练的模型配置文件，然后根据继承的配置文件去修改，\n​\t举例：configs&#x2F;mask_rcnn&#x2F;mask_rcnn_r50_fpn_1x_coco.py\n\n上数四个文件代码中我已经标注清楚，自行查找（如果使用的是voc格式数据，修改上图中和coco_detection.py在同一路径下的voc0712.py）\n其余需要修改的地方：\n1 mmdet&#x2F;datasets&#x2F;coco.py 修改\n\ncoco类别名\n\niou_thrs (列表形式，如 iou_thrs&#x3D;[0.5]，未修改前默认为None)  修改此处的目的是评估时通过 –options  “classwise&#x3D;True” 查看单一类别在固定Iou阈值下的ap值，不改默认求的是0.5：0.95下的。\n\n\n2 mmdet&#x2F;core&#x2F;evaluation&#x2F;class_names.py 修改 \n\ncoco或者voc的类别名称\n\n3.mmdet&#x2F;core&#x2F;evaluation&#x2F;mean_ap.py下\n\n修改后得到precision值的评估代码\n\n数据格式(都在根路径下)1 coco格式:\n\n2 voc格式:\n\n训练train:\n1python tools/train.py configs/mask_rcnn/mask_rcnn_r50_fpn_1x_coco.py --work-dir bhl_mask-rcnn --gpus 1\n\n\n\ntest(验证测试):\n1python tools/test.py bhl_mask-rcnn/mask_rcnn_r50_fpn_1x_coco.py bhl_mask-rcnn/epoch12.pt --eval bbox\n\n\n\nfps值测试：\n123456python -m torch.distributed.launch --nproc_per_node=1 --master_port=29500 \\  tools/analysis_tools/benchmark.py \\           bhl_work/mask_rcnn_r50_fpn_1x_coco.py \\  bhl_work/epoch_12.pth \\  --launcher pytorch \\  --fuse-conv-bn\n\n\n\n\n\n\n\n注意事项1官方默认是在8个gpu下训练的模型，如果是自己单卡训练的话记得设置学习率的时候除以8\n2 coco格式数据评估时不会有precision和recall，voc格式数据评估时可以得到recall(也不会得到precison)，如果需要得到precision，代码我已经修改过了，请将测试数据转成voc格式然后评估即可（记得其他和voc相关的py文件有需要修改的也要改下）。\n3 如果发现自己明明修改了却还是报错，去虚拟环境下的源码看下有没有改成功（通常时安装的编译版本和源代码版本不匹配，手动在源代码里修改就行了），或者用python setup.py develop或者python setup.py install重新编译下看看行不行。\n总结修改顺序：\n1 配置文件或者继承的配置文件（configs&#x2F;_base&#x2F;models&#x2F;）下修改 num_classes，\n2 配置文件或者（configs&#x2F;_base&#x2F;datasets&#x2F;coco_detection.py）下修改 img_scale，samples_per_gpu， 以及训练、验证、测试数据集的路径。\n3 配置文件或者继承的配置文件下修改学习率之类的超参数\n4  （mmdet&#x2F;datasets&#x2F;coco.py）下修改CLASSES类别名，（mmdet&#x2F;core&#x2F;evaluation&#x2F;class_names.py）下修改coco_classes或者voc_classes的类别名.\n集合的配置文件下修改runner的epoch数，load_from，其他自己看需要改吧。\n最后以上基本很多都能从官方文档找到，有问题还是从文档或者issues找\n","slug":"mmdet","date":"2022-01-12T12:59:27.473Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"cdb05b27ae17178365a48c6021a17029","title":"environment","content":"[TOC]\n一、MySQL 8.0 zip压缩包版本（免安装）的下载、配置安装1 下载MySQL 8.0 for Windows zip 压缩包版本 下载地址：https://dev.mysql.com/downloads/file/?id=480557mysql-connector-java-8.0.13下载地址：https://dev.mysql.com/downloads/file/?id=480292注意：进入页面后可以不登录。后点击底部“No thanks, just start my download.”即可开始下载。\n\n2 配置安装2.1、解压下载好的zip包到要安装的目录\n我的解压在了“E:\\mysql-8.0.13-winx64”。\n2.2、配置环境变量\n找到系统变量Path，点击编辑在后面添加 E:\\mysql-8.0.13-winx64\\bin\n2.3、配置初始化的my.ini文件\n解压后的目录并没有my.ini文件，可以自行创建。在安装根目录下添加 my.ini（可以新建文本文件，将文件类型改为.ini），写入如下的配置：\n12345678910111213141516171819202122232425[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8 [mysql]# 设置mysql客户端默认字符集default-character-set=utf8[mysqld]#设置3306端口port = 3306#设置mysql的安装目录basedir=E:\\mysql-8.0.13-winx64#设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错#datadir=E:\\mysql-8.0.13-winx64\\sqldata#允许最大连接数max_connections=20# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统max_connect_errors=10#服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8#创建新表时将使用的默认存储引擎default-storage-engine=INNODB\n\n设置完成后，如图所示：\n\n2.3、安装\n注意：在安装时，必须以管理员身份运行cmd，否则在安装时会报错，会导致安装失败的情况。**&lt;1&gt;**以管理员身份打开 cmd 命令行工具，切换到安装目录的bin目录下（即解压缩的目录，这里是“E:\\mysql-8.0.13-winx64\\bin”）：输入命令e:切换到E盘目录然后输入命令cd mysql-8.0.13-winx64\\bin\n&lt;2&gt;初始化数据库输入命令mysqld --initialize --console\n执行完成后，会输出 root 用户的初始默认密码，如图所示：\n\n注意：执行输出结果里面有一段： “ [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: phaT,bFs88. ”，其中root@localhost:后面的“phaT,bFs88.”就是初始密码（不含首位空格）。在没有更改密码前，需要记住这个密码，后续登录需要用到。如果cmd关快了或者没记住，则删掉初始化的 datadir 目录，再执行一遍初始化命令，又会重新生成的。当然，也可以使用安全工具，强制改密码。\n**&lt;3&gt;**安装服务输入安装命令：mysqld --install备注：mysqld --remove是卸载MySQL服务。\n\n&lt;4&gt;启动服务输入命令：net start mysql备注：net stop mysql是停止服务。\n\n注意: 在 5.7 需要初始化 data 目录：\n123cd C:\\web\\mysql-8.0.11\\bin mysqld --initialize-insecure \n\n初始化后再运行 net start mysql 即可启动 mysql。\n2.4、登录 MySQL\n123456789当 MySQL 服务已经运行时, 我们可以通过 MySQL 自带的客户端工具登录到 MySQL 数据库中, 首先打开命令提示符, 输入以下格式的命名：mysql -h 主机名 -u 用户名 -p参数说明：-h : 指定客户端所要登录的 MySQL 主机名, 登录本机(localhost 或 127.0.0。1)该参数可以省略;-u : 登录的用户名;-p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。\n\n如果我们要登录本机的 MySQL 数据库，只需要在MySQL安装目录的 bin 目录下执行mysql -u root -p命令即可,按回车确认, 如果安装正确且 MySQL 正在运行, 会得到以下响应:\n1Enter password:\n\n若密码存在, 输入密码登录, 不存在则直接按回车登录（这里输入2.3.2产生的密码）。登录成功后你将会看到 Welecome to the MySQL monitor… 的提示语，如图所示：\n\n然后命令提示符会一直以 mysq&gt; 加一个闪烁的光标等待命令的输入, 输入 exit 或 quit 退出登录。\n\n2.5、更改密码\n按照2.4的步骤登录成功，进入MySQL命令模式。在MySQL中执行命令ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘新密码’;    修改密码，下图以密码设置为“root”为例。注意：命令尾的分号一定要有，这是mysql的语法。\n到此，安装部署就完成了。官方说测试速度MySQL 8.0比5.0快两倍。\n来源：https://blog.csdn.net/weixin_43209201/article/details/86158043\n二、 git以下均在git bash中输入：\n123456789101112131415161718192021# 配置用户名git config --global user.name &quot;username&quot;  //(名字，随意写)# 配置邮箱git config --global user.email &quot;55333@qq.com&quot; // 注册账号时使用的邮箱# 配置ssh免密登录ssh-keygen -t rsa -C &quot;55333@qq.com&quot;三次回车后生成了密钥，也可以查看密钥cat ~/.ssh/id_rsa.pub浏览器登录码云(github操作一样)后，个人头像上点设置、然后点ssh公钥、随便填个标题，然后赋值ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6MWhGXSKdRxr1mGPZysDrcwABMTrxc8Va2IWZyIMMRHH9Qn/wy3PN2I9144UUqg65W0CDE/thxbOdn78MygFFsIG4j0wdT9sdjmSfzQikLHFsJ02yr58V6J2zwXcW9AhIlaGr+XIlGKDUy5mXb4OF+6UMXM6HKF7rY9FYh9wL6bun9f1jV4Ydlxftb/xtV8oQXXNJbI6OoqkogPKBYcNdWzMbjJdmbq2bSQugGaPVnHEqAD74Qgkw1G7SIDTXnY55gBlFPVzjLWUu74OWFCx4pFHH6LRZOCLlMaJ9haTwT2DB/sFzOG/Js+cEExx/arJ2rvvdmTMwlv/T+6xhrMS3 894548575@qq.com# 测试ssh -T git@gitee.com# 测试成功Hi unique_perfect! You&#x27;ve successfully authenticated, but GITEE.COM does not provide shell access.\n\n\n\n\n\n三、Maven修改settings.xml配置文件\n1 配置本地仓库路径\n\n2 阿里镜像加速\n\n3 idea中修改如下\n\n四、Oracle123456789oracle完整客户端(Oracle Database 19c)下载地址：https://www.oracle.com/database/technologies/oracle-database-software-downloads.html#db_free （用这个）https://www.oracle.com/cn/database/technologies/oracle19c-windows-downloads.htmloracle即时客户端(Oracle Instant Client)下载地址：https://www.oracle.com/cn/database/technologies/instant-client/downloads.htmlPL/SQL下载地址：https://www.allroundautomations.com/registered-plsqldev/\n\n4.1 oracle完整客户端(Oracle Database 19c)下载安装首先到 Oracle 官网下载页面，下载 Oracle Database 19c：\n\n推荐，将 WINDOWS.X64_193000_db_home.zip 解压到一个好辨识的文件夹内，如，本文解压在 C:\\Oracle19c 目录下，且，路径中不能有空格或者中文括号之类的，不然安装文件闪退：\n管理员身份运行下图中的，setup.exe:\n\n\n安装\n\n\n选择：创建并配置单实例数据库，然后 “下一步”：\n\n选择：桌面类，然后 “下一步”：\n\n选择：创建新 Windows 用户，用户名英文，同时注意口令设置，尽量包含大小写字母和数字，选择下一步\n\nOracle 基目录选择一个好找的目录，如本文为 C:\\Oracle，简单纯英文，无空格\n然后设置口令，随便设置就行，如 123456\n“创建为容器数据库” 点掉，不要勾选\n\n正常密码应该是 8 位，包括大小写字母和数字，如果不是按规定来的，可能弹出\n\n不用管，直接点 “是”，弹出配置检检查界面，等待…\n\n检查完成后，点击 “安装”：\n\n在安装过程中，可能会遇到，卡在 42% 不动的情况，这个一般不要惊慌，等一会儿自动就装好了。(不排除例外情况)\n\n安装完成后，界面如下：\n\n复制网址：https://localhost:5500/em\nOracle 安装验证\n方法一：再命令行 cmd 中，cd 到安装文件的解压目录，本文为 C:\\Oracle19c\n然后输入指令：sqlplus&#x2F;nolog\n\n出现版本信息，表示安装成功。\n方法二：打开网址 https://localhost:5500/em\n\nUsername: sys(不是安装时候的 orcl)\nPassword: 123456（前文图片上第 4 步中，orcl 的口令，本文为 123456）\n出现版本信息，即为安装成功。\n\n4.2 oracle即时客户端(Oracle Instant Client)下载安装1. 下载 Oracle Instant Client官方下载地址：Oracle Instant Client Downloads\n官方下载需要oracle账号\n文件下载完毕后，放在电脑的某个目录下：\n\n2. 配置 tnsnames.ora 文件在 instantclient_11_2 文件夹下新建文件夹 network，在 network 下再建 admin 文件夹\n文件目录结构如下图：\n\n在 admin 里面新建文件 tnsnames.ora，打开写入如下内容：\nLOCAL&#x3D;(DESCRIPTION &#x3D;    (ADDRESS_LIST &#x3D;      (ADDRESS &#x3D; (PROTOCOL &#x3D; TCP)(HOST &#x3D; 192.168.51.11)(PORT &#x3D; 1521))    )    (CONNECT_DATA &#x3D;      (SERVICE_NAME &#x3D; ORCL)    ))\n需要注意的是 192.168.51.11 要改为自己需要连接的远程服务器的地址，ORCL 是数据库实例的名称。\n3. 配置环境变量不同的操作系统配置环境变量的方法可能有差别，以 Windows10 操作系统为例，在我的电脑中，右键选择属性，然后点击高级系统设置，环境变量，新建，具体操作如下截图所示：\n\n\n\n\n新建两个系统环境变量，具体内容如下\n\n变量名：NLS_LANG\n变量值：SIMPLIFIED CHINESE_CHINA.ZHS16GBK\n\n变量名：TNS_ADMIN\n变量值：D:\\SoftInstall\\instantclient_11_2\\instantclient_11_2\\network\\admin\n注意变量值需要根据自己电脑上的文件路径进行修改，对应到第二步操作中的 admin 文件夹的路径。\n到此为止，Instant Client 的配置已经完成了，下面就是安装数据库可视化操作工具 PL&#x2F;SQL，使用 PL&#x2F;SQL 对数据库进行相关操作。\n4.3 plsql下载安装PL&#x2F;SQL Developer 专为 Oracle 数据库定制开发的，功能强大，使用方便的数据库操作软件。\nPL&#x2F;SQL 的下载地址（这个为官网地址，也可以去网上找那种别人提供的带汉化包和注册码的）\nhttps://www.allroundautomations.com/registered-plsqldev/\n下载完成后，进行安装。\n1. 对 PL&#x2F;SQL 进行配置初次打开，先不着急连接数据库，选择 cancle。\n\n首先设置软件语言为中文：\n菜单栏 Configure&gt;&gt;Preferences:\n\n再 Appearance 中，Language 下，选择 Chinese.lang，然后点击左下角 OK 即可。\n\n配置 oracle 的主目录和 oci 库：\n继续进入菜单栏 Configure(配置)&gt;&gt;Preferences(首选项)&gt;&gt; 连接，在 Oracle 主目录位置，下拉选项中，选择 OraDB19Home1，弹出的对话框，点击确定：\n\n在 “OCI 库” 位置，填写 Oracle 安装文件的解压位置下 bin 目录中的 oci.dll，如本文为 C:\\Oracle19c\\bin\\oci.dll，一般下拉选项中已自动识别，若没有可以自己查找。\n\n点击 “确定”，然后关闭 PLSQL，重启一次，这次需要填入数据库的用户名和密码，其中用户名并不是之前设定的 orcl，而是 system，密码还是之前设定的密码 123456。数据库选择 ORCL，点击 “确定”。\n\n菜单栏 “文件”&gt;&gt;“新建”&gt;&gt;”SQL 窗口”：\n输入验证代码，并运行：\n1select sysdate from dual;\n\n\n运行结果：\n\n2. 使用 PL&#x2F;SQL 进行连接在登录页面填写需要连接的 oracle 远程服务器信息和数据库用户信息：\n\n注意这里的数据库，需要填写完整的 IP 地址 + 端口 + 数据库实例名称，也就是4.2节第二步操作中 tnsnames.ora 文件里面配置的 IP 地址和数据库实例名称（颜色标记内容）。\n点击确定，就可以连接到远程 oracle 服务器了。\n五、SQL Server5.1 sqlserver安装下载地址：https://www.microsoft.com/zh-cn/sql-server/sql-server-downloads\n安装前把杀毒软件关闭。\n安装进行到功能选择这一步，如果安装的三个目录有灰化无法改变的，参考这篇文章: https://vegetabhl.netlify.app/post/sql%20server%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95%E7%AD%89%E7%9B%B8%E5%85%B3%E8%B7%AF%E5%BE%84%E6%97%A0%E6%B3%95%E6%9B%B4%E6%94%B9\n选择的自定义安装，安装目录选择了D盘，非默认路径\n\n\n\n\n\n\n\n\n\n\n\n\n5.2 下载管理工具ssms\n","slug":"environment","date":"2021-12-14T06:11:49.500Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"17b5d6214e0613f1c9b9851fb72327c9","title":"什么是vlan、三层交换机、网关、DNS、子网掩码","content":"什么是vlan、三层交换机、网关、DNS、子网掩码一、什么是VLANVLAN中文是“虚拟局域网”。LAN可以是由少数几台家用计算机构成的网络，也可以是数以百计的计算机构成的企业网络。VLAN所指的LAN特指使用路由器分割的网络——也就是广播域。\n听上面的概念，肯定有不少朋友是一头雾水的，什么是虚拟局域网？好好的，为什么要划分vlan？\n这里举个例：通俗的了解\n一所高中，新学期高一招了800个学生，这800个学生，如果放在一个班里，那肯定是管理不过来，面对800个人，老师看了也头疼，这边在授课，那边完全听不到，老师布置什么任务，也会有一些传达不到，老师要是想找某个学生的信息，要从800份信息中去找，极其麻烦，浪费时间；\n而实际中，也是一样，电脑A要想要与电脑B通信，于是电脑A就需要发送arp请求，而网络中电脑众多，最终ARP请求会被转发到同一网络中的所有电脑，才能找到电脑B，如此一来，为了找到电脑B，消耗了网络整体的带宽，收到广播信息的计算机还要消耗一部分CPU时间来对它进行处理。造成了网络带宽和CPU运算能力的大量无谓消耗。\n那么怎么办呢？\n学校就针对这800个学生，分成了10个班，每个班80人，分别命名为高一（1）班，高一（2）班、、、、高一（10）班，每个人都会获得一个班级编号。\n1101表示一班01号学生。\n1102表示一班02号学生。\n1201表示2班01号学生。\n同一个班的学生编号尾数不同，其它的都相同。\n那么这样老师再管理起来就轻松多了，可以把一班这80人管理的妥妥的，隔壁2班与3班乱成一锅粥也不管一班的事，我就要这一班80人好好上课就行。\n这就是vlan，每个班就相当于一个vlan，而每个班名称，就相当于vlan的名称，而每个学生的编号就是ip地址；同班同学（同一个vlan的ip），因为同一个教室，朝夕相处，且可以相互通信，不同班的同学，若不做其它工作，很难往来通信。\n所以同一个vlan间，可以相互通信；不同vlan，若不做配置，不能相互通信。\n那么不同vlan如何通通信呢？就需要单臂路由与三层交换机。\n二、单臂路由与三层交换机我们知道要实现不同vlan间通信，就必须需要有路由功能，不同VLAN之间相互通信的两种方式（单臂路由、三层交换机）。\n什么是单臂路由？\n单臂路由的实现方式，其实就是普通二层交换机加路由器，从而实现不同vlan间的可以互相通信。\n\n那什么是三层交换机呢？\n对于小型的网络，单臂路由可以应付，但随着VLAN之间流量的不断增加，很可能导致路由器成为整个网络的瓶颈，出现掉包、或者通信堵塞。\n为了解决上述问题，三层交换机应运而生。三层交换机，本质上就是“带有路由功能的（二层）交换机”。路由属于OSI参照模型中第三层网络层的功能，因此带有第三层路由功能的交换机才被称为“三层交换机”。\n关于三层交换机的内部结构，可以参照下面的简图。\n\n在一台本体内，分别设置了交换机模块和路由器模块；而内置的路由模块与交换模块相同，使用ASIC硬件处理路由。因此，与传统的路由器相比，可以实现高速路由。并且，路由与交换模块是汇聚链接的，由于是内部连接，可以确保相当大的带宽，所以对于正规的项目，需要使用三层交换机来实现网网络间的通信。 \n三、什么是网关在了解了vlan与三层交换机后，能不能通信，还需要看网关是否正确。\n一、什么是网关\n网关(Gateway)又称网间连接器、协议转换器。网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。\n二、如何来理解网关\n大家都知道，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也必须经过一道“关口”，这道关口就是网关。顾名思义，网关(Gateway)就是一个网络连接到另一个网络的“关口”。\n按照不同的分类标准，网关也有很多种。TCP&#x2F;IP协议里的网关是最常用的，在这里我们所讲的“网关”均指TCP&#x2F;IP协议下的网关。\n三、网关的ip地址\n那么网关到底是什么呢？\n网关实质上是一个网络通向其他网络的IP地址，网关在网段内的可用ip中选一个，不过，一般用的是第1个和最后一个。\n例如\n比如有网络A和网络B，\n网络A：的IP地址范围为“192.168.1.1~192. 168.1.254”，子网掩255.255.255.0；\n如果需要与其它网段通信，那么它的网关可以设置为192.168.1.1，当然也可以设置为网段内其它的一个ip地址。\n网络B：的IP地址范为“192.168.2.1~192.168.2.254”，子网掩码255.255.255.0。\n如果需要与其它网段通信，那么它的网关可以设置为192.168.2.1，当然也可以设置为网段内其它的一个ip地址。\n\n四、网关是如何实现通信？\n在没有路由器的情况下，不同的两个网络之间是不能进行TCP&#x2F;IP通信的，即使是两个网络连接在同一台交换机(或集线器)上，TCP&#x2F;IP协议也会根据子网掩码(255.255.255.0)判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。\n如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机(如附图所示)。网络B向网络A转发数据包的过程。\n所以说，只有设置好网关的IP地址，TCP&#x2F;IP协议才能实现不同网络之间的相互通信。\n五、什么是默认网关？\n　　如果搞清了什么是网关，默认网关也就好理解了。就好像一个房间可以有多扇门一样，一台主机可以有多个网关。默认网关的意思是一台主机如果找不到可用的网关，就把数据包发给默认指定的网关，由这个网关来处理数据包。现在主机使用的网关，一般指的是默认网关。  \n四、什么是DNSDNS是域名解析服务器（Domain Name System），是把网址变成IP地址的服务器。\nDNS说白了是把域名翻译成IP地址用的，这里面举个例子，大家就很容易清楚了。\n例如我们在浏览器里面输入www.baidu.com的时候，机器要跟百度这个网站进行通信，机器要往外面发送数据包，数据包里面要写百度这台服务器的IP地址，我们不知道IP地址是多少，那么就需要主机问DNS服务器，DNS服务器就自动帮我们把www.baidu.com这个域名翻译成了IP地址61.135.169.105。然后写到了数据包的目的IP地址里面就可以进行通信。\n就跟我们写信一样，你得写个收信人的地址邮局才能给你发送吧，你给国外写信，你写中文地址邮局不认识，需要这个一个人帮你翻译成英语。这就是DNS的作用，所以你的在本地连接里面写DNS才可以正常浏览网页，如果不设置DNS，是无法正常访问网页的。\n五、MAC地址讲到MAC地址，就不得不提ip地址，这里顺便把ip地址也说下。\nIP与MAC\n虽然现在已经ipv6了，但我们基本用的大多数还是ipv4协议，所谓ip就是你电脑整个网络的编号。其他电脑想访问电脑就得需要这个编号。但是这个编号很多情况下是一直在变化的。唯一不变的是你的MAC地址：物理地址。\nMAC是网络中用来标识网卡设备的唯一网络地址。由相关硬件制造商统一分配，每台电脑的MAC地址都是唯一的。\n做个比喻，你经常搬家，你没搬一次家都有一个地址，XX小区XX单元XX号，这个就是IP。但是你的名字不变，这个就是MAC，不同的是我们的MAC不允许重名。 \n\n我们的IP分为两个部分：如上图分为网络部分和主机部分。网络部分好比就是你在XX省XX市XX镇，这个是国家固定下来了的。但是XX小区XX单元XX号是开发商自己定的。两个编号加起来就是你的ip了。不同的是在现实中两个编号的长度是固定的，在网络上A、B、C、D的ip地址却是变化的，这个在前天有详细讲到。\n六、子网掩码子网掩码是为了区分网络位和主机位，上面我们说到过，一个ip地址是由网络部分和主机部分。正如一个人的名字由姓与名组成。\n那么我们可以把IP地址比作一个人的名字，那么子网掩码就像是一份名单，可以快速的知道那些人同姓，那些人不同姓，把同姓的人分在一组，让他们之前可以互相交流。\n举个例子\n有一个网段是192.168.1.0-192.1.254，这个网段就像一个村子一样，就称它为安防村，此这网段有个ip地址是192.168.1.1，我们就叫他安防一，另外一个人叫安防二，它的ip地址为192.168.1.2，我们一看他们，就知道他们是同村的。\n另外有一个网段，是192.168.0.0——192.168.255.254，我们叫它安村，村里有个同样有两个ip地址为92.168.1.1与192.168.1.2，也叫安防一，安防二，那么问题来了？这个时候，如何区分他们是属于那个村的？\n这个时候就需要子网掩码了来判断他们是属于那个网段的，需要把安防一、安防二带到村里去认下，就知道他们是属于那个村了，安防村的网段是255.255.255.0，安村的网段是255.255.0.0。\n网络中也会出现类似于“同名”“同姓”的ip地址，如何区分他们到底是属于那个网段，就需要依靠子网掩码了。\n","slug":"什么是vlan、三层交换机、网关、DNS、子网掩码","date":"2021-12-13T13:48:41.462Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"4122a09df2e4f3d18921791a0dcc0507","title":"docker","content":"0 参考12345678910111213141516171819查找镜像：docker search xxx  查看镜像：docker images     看终止状态的容器：docker ps -a显示当前正在运行的容器（未终止）docker ps--------------------------运行镜像：docker run -it --name=mycentos7 centos:7 /bin/bash   -启动交互式容器之后是直接进入容器终端；可以查看容器的文件结构；使用exit命令则会退出终端并且停止容器。docker run -itd --name=mycentos2 centos:7      -启动守护式容器之后不会进入容器终端；容器在后台运行--------------------------进入容器：sudo docker attach  容器ID   这种方式进入后如果执行exit退出容器，则容器也会终止sudo docker exec -it 775c7c9ee1e1 /bin/bash   推荐使用这种命令进入容器，因为此退出容器终端，不会导致容器的停止。---------------------退出容器:exit\n\n123456789101112终止运行中的容器：docker stop $CONTAINER_ID来终止一个运行中的容器。启动终止状态的容器：docker start来启动。删除容器：docker rm -f $CONTAINER_ID   只能删除停止状态的容器；-注意删除的是容器不是镜像  -f表示强制删除删除镜像：docker rmi 镜像id （镜像id可以通过docker images命令查看，并且删除镜像需要提前删除该镜像的容器，否则会失败）重启一个容器：docker restart命令来重启。容器开机自动启动：sudo docker update redis --restart=always\n\n进入容器\n在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：\n\n**docker attach  容器ID **\ndocker exec  容器ID   ：  推荐使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。\n\n1sudo docker exec -it 775c7c9ee1e1 /bin/bash  \n\n\n\ndocker容器使用\nhttps://www.runoob.com/docker/docker-container-usage.html\n1. Docker概述目标：了解Docker是什么、应用场景及其组成部分\n小结：\n\nDocker是一个应用容器引起；\n应用场景：web的自动化打包发布，自动化测试、可持续集成，安装各种组件；\n与传统虚拟机比较：docker启动速度比较快，占用体积较小；\n组成：docker守护进程，仓库，镜像，容器，docker客户端\n\n2. Docker安装与启动目标：在线安装docker并使用命令启动、停止docker\n分析：\n\n更新yum源为ustc；\n安装docker;\n更新docker的镜像源为ustc；\n使用docker命令操作docker\n\n小结：\n需求更新yum源和镜像源安装docker；安装之后可以使用 docker -v\n1234567# 启动systemctl start docker# 停止systemctl stop docker#查看docker启动状态systemctl status docker\n\n\n\n3. 镜像相关命令目标：能够使用镜像的查看、搜索、拉取、删除命令\n小结：\n\n\n\n\n\n\n\n\n\n拉取：docker pull 镜像名称:版本号（若不指定则会拉取最新的版本）\n删除全部镜像：docker rmi ` docker images -q ` （慎用）\n4. 查看&amp;创建并启动交互式容器目标：使用查看容器命令；拉取centos:7的镜像之后结合容器启动命令和选项 -it 启动交互式容器\n分析：\n\n拉取镜像（容器是基于镜像运行）；\n创建并启动交互式容器，docker交互式容器（启动容器之后会直接进入容器的命令行终端，如果退出则容器停止运行）\n\n小结：\n12345# 查看终止状态的容器容器docker ps -a# 创建并启动交互式容器docker run -it --name=mycentos7 centos:7 /bin/bash   启动交互式容器之后是直接进入容器终端；可以查看容器的文件结构；使用exit命令则会退出终端并且停止容器。\n\n\n\n\n\n\n\n\n\n\n启动交互式容器之后是直接进入容器终端；可以查看容器的文件结构；使用exit命令则会退出终端并且停止容器。\n5. 创建并启动守护式容器目标：结合容器启动命令和选项 -di 启动守护式容器\n分析：\n创建并启动docker容器，可以在后台运行；\n在创建交互式容器之后如果退出的话，容器处于停止状态，可以使用命令再次启动容器，使用命令进入容器并操作。\n12345# 创建并启动守护式容器docker run -itd --name=mycentos2 centos:7  启动守护式容器之后不会进入容器终端；容器在后台运行# 启动容器后再进入容器docker exec -it mycentos2 /bin/bash\n\n小结：\n\n\n\n\n\n\n\n\n\n守护式容器在启动之后会一直在后台运行，即使进入容器之后执行exit命令也不会停止容器；\n适用于需要长期运行容器的情况\n6. 停止&amp;拷贝&amp;挂载&amp;查看ip&amp;删除容器目标：能够使用容器的停止、拷贝文件、目录挂载、查看IP、删除命令\n小结：\n\n容器停止、启动\n\n拷贝文件：容器与宿主机之间的文件互拷\n\n目录挂载：将宿主机的目录映射到容器对于目录\n\n查看容器IP\n\n\n容器删除：只能删除停止状态的容器；docker rm `docker ps -a -q`\n\n\n7. MySQL容器部署目标：拉取mysql镜像，启动容器，操作容器中的mysql\n分析：\n\n拉取mysql镜像；\n\n创建并启动守护式容器；\n\n在容器中操作mysql；\n\n使用图形界面工具（windows）操作在docker中安装的mysql；在创建mysql容器的时候使用-p指定端口映射实现连接\n在创建容器的时候mysql的root用户可以指定远程访问的密码。\n\n\n小结：\n\n\n\n\n\n\n\n\n\n在创建容器的时候指定环境变量MYSQL_ROOT_PASSWORD表示使用root进行远程连接时候的密码。如果需要进行远程连接的话可以使用-p进行端口映射。\n8. Tomcat容器部署目标：拉取tomcat镜像，启动容器，操作容器中的tomcat\n分析：\n\n将项目文件上传到容器中的tomcat目录（webapps）\n创建容器的时候可以指定-v进行目录挂载，tomcat在容器中的目录（&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps）\n\n可以通过外部浏览器访问容器中的项目\n创建容器的时候可以指定-p进行端口映射\n\n\n\n拉取tomcat镜像；docker pull tomcat\n创建并启动tomcat容器；\n\n1docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/tomcat/webapps:/usr/local/tomcat/webapps tomcat\n\n\n\n\n访问容器中tomcat\nhttp://192.168.76.128:9000\n\n\n小结：\n\n\n\n\n\n\n\n\n\n上传项目文件可以使用容器的目录挂载功能，外部访问可以使用端口映射\n9. Nginx容器部署目标：拉取nginx镜像，启动容器，访问nginx\n分析：\nnginx的默认访问端口是：80\n在创建容器的时候需要进行端口映射，指定-p，映射的端口80\n\n拉取nginx镜像；\n创建并启动nginx容器；\n在浏览器上访问容器中nginx，http://192.168.76.128\n\n小结：\n\n\n\n\n\n\n\n\n\n如果被占用了80端口，那么在指定映射的时候可以改变宿主机的端口映射，在访问时也需要带上端口号。\n10. Redis容器部署目标：拉取redis镜像，启动容器，操作容器中的redis\n分析：\n\n拉取redis镜像；\n创建并启动redis容器；默认端口是6379，如果需要外部访问则可以使用端口映射；\n连接redis: ①使用命令行客户端 ②使用图形界面工具\n\n小结：\n12345# 创建容器docker run -di --name=myredis -p 6379:6379 redis# 进入容器docker exec -it myredis /bin/bash\n\n\n\n11. docker-compose简介&amp;安装目标：docker-compose的作用；能够安装docker-compose\n小结：\ndocker-compose是一个应用工具；可以通过配置docker-compose.yml文件同时启动多个容器。\n\n\n\n\n\n\n\n\n\n部署项目时可以编写一个docker-compose.yml文件作为启动项目单位，同时启动项目相关的那些容器。\n12. docker-compose应用目标：编写模版文件同时启动docker容器\n分析：\ndocker-compose可以实现一次启动多个容器；通过配置docker-compose模板文件（docker-compose.yml）,在这个配置文件中去配置各个容器及其相关的依赖。\n\n编写模板文件；\n创建并启动docker-compose项目（模板文件所在的目录，docker-compose.yml）\n测试\n\n小结：\ndocker-compose可以配置一个模板文件实现一次可以启动多个容器，运行时候可以执行一个up则会创建并启动模板文件中的各个服务。\n\n\n\n\n\n\n\n\n\n模板文件是yml格式的；编写的时候需要注意其格式。\n13. 迁移与备份目标：能够将容器保存为镜像，备份，恢复镜像再启动以恢复的镜像作为基础的容器\n分析：\n在当前的容器中安装了各种组件；期望在其他服务器上也能快速拥有该容器的一切环境；可以将当前的容器制作为一个镜像，再将该奖项复制到其他服务器，其他服务器再基于镜像运行容器。\n\n将容器保存为一个镜像；\n备份镜像；\n恢复镜像；\n基于镜像运行容器\n\n小结：\ndocker容器可以保存为一个镜像；备份为一个镜像包（*.tar）可以复制迁移到其他服务器，再恢复该tar包中的镜像，基于镜像运行容器实现环境的一致。\n14. 使用Dockerfile创建镜像目标：使用Dockerfile创建一个自定义jdk1.8的镜像\n分析：\n假设在centos7作为基础镜像上；添加jdk1.8并构建一个包含jdk1.8的centos7新镜像。\n– Dockerfile可以实现；Dockerfile是由一系列命令和参数构成的文本文件，在文件中可以指定各个组件资源和运行命令等。\n实现步骤：\n\n拉取centos7镜像；\n上传jdk1.8；\n编写Dockerfile文件；\n构建镜像；\n测试（基于新镜像创建并运行容器，运行java -version）\n\n小结：\nDockerfile可以基于镜像制作镜像；docker build -t=&#39;jdk1.8&#39; . \n15. 私有仓库搭建与配置目标：拉取、启动私有仓库镜像并可以访问私有仓库\n小结：\n拉取registry镜像；基于镜像创建私有仓库容器；需要去修改docker的一个配置文件指定私有仓库地址；再访问私有仓库：http://ip:5000/v2/_catalog\n16. 将镜像上传至私有仓库目标：将制作的jdk1.8的镜像上传到私有仓库\n小结：\n将本地镜像打标签（标记本地镜像为一个私有仓库中的镜像）；将打了标签的镜像推送到私有仓库。\n17. 从私有仓库拉取镜像目标：将私有仓库中的jdk1.8镜像拉取到本地\n小结：\n\n私有仓库与拉取镜像的服务器是在同一台机器上：直接拉取镜像； docker pull 私有仓库地址/镜像名称\n私有仓库与拉取镜像的服务器是不在同一台机器上：需要去修改docker的配置文件，指定私有仓库地址；再执行拉取镜像的命令。\n\n\n\n\n\n\n\n\n\n\n如果本地存在同名的镜像需要先删除镜像后拉取\n","slug":"docker","date":"2021-12-08T08:51:52.984Z","categories_index":"网络,常用工具,项目,环境配置,docker","tags_index":"网络,常用工具,项目,环境配置,docker","author_index":"Vegetabhl"},{"id":"80bfd9d8e471d51824c7169f84655c0e","title":"hexo迁移","content":"hexo 迁移1 备份你旧电脑的文件删除node_modules文件夹，然后把剩余的文件全部备份。\n\n2 新电脑准备安装好GIt，Node.js。\nNode.js配置\n给你的npm换成淘宝源，这样待会下东西下的更快。\n1npm config set registry https://registry.npm.taobao.org/\n\nnpm安装上hexo\n1npm install hexo-cli -g\n\n\n\n1 备份文件转移到新电脑\n就是直接把你那个文件复制到新电脑上。\n\n2 然后进入文件，打开gitbash或者cmd，安装依赖（就是把你之前删除的node_modules文件装回来）\n1npm install\n\n\n执行完了以后看一下你的文件夹里应该已经出现node_modules文件夹了。\n3 下载hexo的git工具\n1npm install hexo-deployer-git --save\n\n下载完以后，你就可以在新电脑上正常使用了。写一个新文章，试试\n注意：\n因为设置了Git的代理，所以上传博客的时候记得打开代l。\n","slug":"hexo 迁移","date":"2021-12-08T08:51:52.982Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"1a69fb790e48bb61a9f696f17dd47fdf","title":"子网划分","content":"子网划分的两个示例例1：本例通过子网数来划分子网，未考虑主机数量。一家集团公司有12家子公司，每家子公司又有4个部门。上级给出一个172.16.0.0&#x2F;16的网段，让给每家子公司以及子公司的部门分配网段。\n思路：既然有12家子公司，那么就要划分12个子网段，但是每家子公司又有4个部门，因此又要在每家子公司所属的网段中划分4个子网分配给各部门。\n步骤：\nA. 先划分各子公司的所属网段。\n有12家子公司，那么就有2的n次方≥12，n的最小值&#x3D;4。因此，网络位需要向主机位借4位。那么就可以从172.16.0.0&#x2F;16这个大网段中划出2的4次方&#x3D;16个子网。\n详细过程：\n先将172.16.0.0&#x2F;16用二进制表示\n&#x3D;&#x3D;10101100.00010000.00000000&#x3D;&#x3D;.00000000&#x2F;16\n借4位后（可划分出16个子网）：\n\n&#x3D;&#x3D;10101100.00010000.0000&#x3D;&#x3D;0000.00000000&#x2F;20【172.16.0.0&#x2F;20】\n&#x3D;&#x3D;10101100.00010000.0001&#x3D;&#x3D;0000.00000000&#x2F;20【172.16.16.0&#x2F;20】\n&#x3D;&#x3D;10101100.00010000.0010&#x3D;&#x3D;0000.00000000&#x2F;20【172.16.32.0&#x2F;20】\n&#x3D;&#x3D;10101100.00010000.0011&#x3D;&#x3D;0000.00000000&#x2F;20【172.16.48.0&#x2F;20】\n&#x3D;&#x3D;10101100.00010000.0100&#x3D;&#x3D;0000.00000000&#x2F;20【172.16.64.0&#x2F;20】\n&#x3D;&#x3D;10101100.00010000.0101&#x3D;&#x3D;0000.00000000&#x2F;20【172.16.80.0&#x2F;20】\n&#x3D;&#x3D;10101100.00010000.0110&#x3D;&#x3D;0000.00000000&#x2F;20【172.16.96.0&#x2F;20】\n&#x3D;&#x3D;10101100.00010000.0111&#x3D;&#x3D;0000.00000000&#x2F;20【172.16.112.0&#x2F;20】\n&#x3D;&#x3D;10101100.00010000.1000&#x3D;&#x3D;0000.00000000&#x2F;20【172.16.128.0&#x2F;20】\n&#x3D;&#x3D;10101100.00010000.1001&#x3D;&#x3D;0000.00000000&#x2F;20【172.16.144.0&#x2F;20】\n&#x3D;&#x3D;10101100.00010000.1010&#x3D;&#x3D;0000.00000000&#x2F;20【172.16.160.0&#x2F;20】\n&#x3D;&#x3D;10101100.00010000.1011&#x3D;&#x3D;0000.00000000&#x2F;20【172.16.176.0&#x2F;20】\n&#x3D;&#x3D;10101100.00010000.1100&#x3D;&#x3D;0000.00000000&#x2F;20【172.16.192.0&#x2F;20】\n&#x3D;&#x3D;10101100.00010000.1101&#x3D;&#x3D;0000.00000000&#x2F;20【172.16.208.0&#x2F;20】\n&#x3D;&#x3D;10101100.00010000.1110&#x3D;&#x3D;0000.00000000&#x2F;20【172.16.224.0&#x2F;20】\n&#x3D;&#x3D;10101100.00010000.1111&#x3D;&#x3D;0000.00000000&#x2F;20【172.16.240.0&#x2F;20】\n\n我们从这16个子网中选择12个即可，就将前12个分给下面的各子公司。每个子公司最多容纳主机数目为2的12次方-2&#x3D;4094。\nB. 再划分子公司各部门的所属网段以甲公司获得172.16.0.0&#x2F;20为例，其他子公司的部门网段划分同甲公司。有4个部门，那么就有2的n次方≥4，n的最小值&#x3D;2。因此，网络位需要向主机位借2位。那么就可以从172.16.0.0&#x2F;20这个网段中再划出2的2次方&#x3D;4个子网，正符合要求。详细过程：先将172.16.0.0&#x2F;20用二进制表示\n&#x3D;&#x3D;10101100.00010000.0000&#x3D;&#x3D;0000.00000000&#x2F;20\n借2位后（可划分出4个子网）：① &#x3D;&#x3D;10101100.00010000.000000&#x3D;&#x3D;00.00000000&#x2F;22【172.16.0.0&#x2F;22】② &#x3D;&#x3D;10101100.00010000.000001&#x3D;&#x3D;00.00000000&#x2F;22【172.16.4.0&#x2F;22】③ &#x3D;&#x3D;10101100.00010000.000010&#x3D;&#x3D;00.00000000&#x2F;22【172.16.8.0&#x2F;22】④ &#x3D;&#x3D;10101100.00010000.000011&#x3D;&#x3D;00.00000000&#x2F;22【172.16.12.0&#x2F;22】\n将这4个网段分给甲公司的4个部门即可。每个部门最多容纳主机数目为2的10次方-2&#x3D;1024\n例2：本例通过计算主机数来划分子网。某集团公司给下属子公司甲分配了一段IP地址192.168.5.0&#x2F;24，现在甲公司有两层办公楼（1楼和2楼），统一从1楼的路由器上公网。1楼有100台电脑联网，2楼有53台电脑联网。如果你是该公司的网管，你该怎么去规划这个IP？\n根据需求，画出下面这个简单的拓扑。将192.168.5.0&#x2F;24划成3个网段，1楼一个网段，至少拥有101个可用IP地址；2楼一个网段，至少拥有54个可用IP地址；1楼和2楼的路由器互联用一个网段，需要2个IP地址。\n\n**思路:**我们在划分子网时优先考虑最大主机数来划分。在本例中，我们就先使用最大主机数来划分子网。101个可用IP地址，那就要保证至少7位的主机位可用（2的m次方-2≥101，m的最小值&#x3D;7）。如果保留7位主机位，那就只能划出两个网段，剩下的一个网段就划不出来了。但是我们剩下的一个网段只需要2个IP地址并且2楼的网段只需要54个可用IP，因此，我们可以从第一次划出的两个网段中选择一个网段来继续划分2楼的网段和路由器互联使用的网段。步骤：A. 先根据大的主机数需求，划分子网因为要保证1楼网段至少有101个可用IP地址，所以，主机位要保留至少7位。先将192.168.5.0&#x2F;24用二进制表示：11000000.10101000.00000101.00000000&#x2F;24主机位保留7位，即在现有基础上网络位向主机位借1位（可划分出2个子网）：① 11000000.10101000.00000101.00000000&#x2F;25【192.168.5.0&#x2F;25】② 11000000.10101000.00000101.10000000&#x2F;25【192.168.5.128&#x2F;25】1楼网段从这两个子网段中选择一个即可，我们选择192.168.5.0&#x2F;25。2楼网段和路由器互联使用的网段从192.168.5.128&#x2F;25中再次划分得到。\nB. 再划分2楼使用的网段2楼使用的网段从192.168.5.128&#x2F;25这个子网段中再次划分子网获得。因为2楼至少要有54个可用IP地址，所以，主机位至少要保留6位（2的m次方-2≥54，m的最小值&#x3D;6）。先将192.168.5.128&#x2F;25用二进制表示：&#x3D;&#x3D;11000000.10101000.00000101&#x3D;&#x3D;.10000000&#x2F;25主机位保留6位，即在现有基础上网络位向主机位借1位（可划分出2个子网）：① &#x3D;&#x3D;11000000.10101000.00000101.1&#x3D;&#x3D;0000000&#x2F;26【192.168.5.128&#x2F;26】② &#x3D;&#x3D;11000000.10101000.00000101.1&#x3D;&#x3D;1000000&#x2F;26【192.168.5.192&#x2F;26】2楼网段从这两个子网段中选择一个即可，我们选择192.168.5.128&#x2F;26。路由器互联使用的网段从192.168.5.192&#x2F;26中再次划分得到。\nC. 最后划分路由器互联使用的网段路由器互联使用的网段从192.168.5.192&#x2F;26这个子网段中再次划分子网获得。因为只需要2个可用IP地址，所以，主机位只要保留2位即可（2的m次方-2≥2，m的最小值&#x3D;2）。先将192.168.5.192&#x2F;26用二进制表示：&#x3D;&#x3D;11000000.10101000.00000101.11&#x3D;&#x3D;000000&#x2F;26主机位保留2位，即在现有基础上网络位向主机位借4位（可划分出16个子网）：① &#x3D;&#x3D;11000000.10101000.00000101.110000&#x3D;&#x3D;00&#x2F;30【192.168.5.192&#x2F;30】② &#x3D;&#x3D;11000000.10101000.00000101.110001&#x3D;&#x3D;00&#x2F;30【192.168.5.196&#x2F;30】③ &#x3D;&#x3D;11000000.10101000.00000101.110010&#x3D;&#x3D;00&#x2F;30【192.168.5.200&#x2F;30】…………………………………④ &#x3D;&#x3D;11000000.10101000.00000101.111101&#x3D;&#x3D;00&#x2F;30【192.168.5.244&#x2F;30】⑤ &#x3D;&#x3D;11000000.10101000.00000101.111110&#x3D;&#x3D;00&#x2F;30【192.168.5.248&#x2F;30】⑥ &#x3D;&#x3D;11000000.10101000.00000101.111111&#x3D;&#x3D;00&#x2F;30【192.168.5.252&#x2F;30】路由器互联网段我们从这16个子网中选择一个即可，我们就选择192.168.5.252&#x2F;30。\nD. 整理本例的规划地址1楼：网络地址：【192.168.5.0&#x2F;25】主机IP地址：【192.168.5.1&#x2F;25—192.168.5.126&#x2F;25】广播地址：【192.168.5.127&#x2F;25】2楼：网络地址：【192.168.5.128&#x2F;26】主机IP地址：【192.168.5.129&#x2F;26—192.168.5.190&#x2F;26】广播地址：【192.168.5.191&#x2F;26】路由器互联：网络地址：【192.168.5.252&#x2F;30】两个IP地址：【192.168.5.253&#x2F;30、192.168.5.254&#x2F;30】广播地址：【192.168.5.255&#x2F;30】\n快速划分子网确定IP我们以例2为例：题目需要我们将192.168.5.0&#x2F;24这个网络地址划分成能容纳101&#x2F;54&#x2F;2个主机的子网。因此我们要先确定主机位，然后根据主机位决定网络位，最后确定详细的IP地址。① 确定主机位将所需要的主机数自大而小的排列出来：101&#x2F;54&#x2F;2，然后根据网络拥有的IP数目确定每个子网的主机位：如果2的n次方-2≥该网段的IP数目，那么主机位就等于n。于是，得到：7&#x2F;6&#x2F;2。② 根据主机位决定网络位用32减去主机位剩下的数值就是网络位，得到：25&#x2F;26&#x2F;30。③ 确定详细的IP地址在二进制中用网络位数值掩盖IP前面相应的位数，然后后面的为IP位。选取每个子网的第一个IP为网络地址，最后一个为广播地址，之间的为有效IP。得到：【网络地址】 【有效IP】 【广播地址】【192.168.5.0&#x2F;25】【192.168.5.1&#x2F;25-192.168.5.126&#x2F;25】【192.168.5.127&#x2F;25】【192.168.5.128&#x2F;26】【192.168.5.129&#x2F;26-192.168.5.190&#x2F;26】【192.168.5.191&#x2F;26】【192.168.5.192&#x2F;30】【192.168.5.193&#x2F;30-192.168.5.194&#x2F;30】【192.168.5.195&#x2F;30】\n","slug":"子网划分","date":"2021-10-20T07:41:10.906Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"280453c071f773487797f4620c8f79e5","title":"归档压缩","content":"1 归档管理：tar计算机中的数据经常需要备份，tar是Unix&#x2F;Linux中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解开以恢复数据。\ntar使用格式\n1tar  [参数]  打包文件名  文件\n\ntar命令很特殊，其参数前面可以使用“-”，也可以不使用。\n常用参数：\n\n\n\n参数\n含义\n\n\n\n-c\n生成档案文件，创建打包文件\n\n\n-v\n列出归档解档的详细过程，显示进度\n\n\n-f\n指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后\n\n\n-t\n列出档案中包含的文件\n\n\n-x\n解开档案文件\n\n\n注意：除了f需要放在参数的最后，其它参数的顺序任意。\n\n2 文件压缩解压：gzip\nl tar与gzip命令结合使用实现文件打包、压缩。\nl tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz。\n\ngzip使用格式如下：\n1gzip  [选项]  被压缩文件\n\n\n\n常用选项：\n\n\n\n选项\n含义\n\n\n\n-d\n解压\n\n\n-r\n压缩所有子目录\n\n\n\ntar这个命令并没有压缩的功能，它只是一个打包的命令，但是在tar命令中增加一个选项(-z)可以调用gzip实现了一个压缩的功能，实行一个先打包后压缩的过程。\n压缩用法：tar cvzf 压缩包包名 文件1 文件2 …\n\n\n\n-z\n指定压缩包的格式为：file.tar.gz\n\n\n\n\n\n\n\n例如：tar zcvf test.tar.gz 1.c 2.c 3.c 4.c把 1.c 2.c 3.c 4.c 压缩成 test.tar.gz\n\n解压用法： tar zxvf 压缩包包名\n\n\n\n参数\n含义\n\n\n\n-z\n指定压缩包的格式为：file.tar.gz\n\n\n\n解压到指定目录：-C （大写字母“C”）\n例子：tar -xvf new.tar.gz -C .&#x2F;test&#x2F; 将 new.tar.gz 解压到当前目录下的 test 目录下：\n\n","slug":"归档压缩","date":"2021-08-31T05:19:48.413Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"7a48cc7cea05ed47296a8afb17fd1c59","title":"C盘目录介绍","content":"先放张图，这是一个win10系统的系统盘的文件目录，笔者将对该目录下的文件做一个简要的总结，和大家分享交流。\n\n1.文件夹（加粗为隐藏文件夹）\n\n\n\n文件夹\n说明\n是否可以删除\n\n\n\n$Recycle.Bin\n回收站，用于保存删除文件数据\n可以删除，会自动重建\n\n\nBoot\n用于保存操作系统启动引导文件的文件夹\n绝对不能删除\n\n\nDocuments and Settings\n系统用户设置文件夹，包括各个用户的文档、收藏夹、上网浏览信息、配置文件等。这里面保存着系统所有用户的文档和账户设置，尤其是里面的default user、all users、administrator和以你当前登陆用户名的文件夹。\n不能删除，否则会造成系统重新启动不能登陆的情况发生\n\n\nEFI\n自己装的系统可能会有这个文件夹，里面的是启动文件，用于GPT分区，UEFI启动的机器。如果是UEFI安装的机器的话，EFI文件夹的内容在EFI分区里也会有一份的\n可以删除\n\n\nPerfLogs\n是系统日志信息文件夹，如磁盘扫描 错误信息，是系统自动生成的，系统测试之后，测试记录文件也会自动存放在这个文件夹下\n不建议删除，会降低系统速度\n\n\nProgram Files\n系统自带应用应用和软件的安装目录\n不能删除\n\n\nProgr Files(X86)\n这是系统中32位软件的安装目录\n不能删除\n\n\nProgram Data\nWind7以上系统系统文件夹，放置程序的使用数据、设置等文件\n不建议删除\n\n\nRecovery\n用于存放恢复系统用的恢复环境的文件夹，如果您习惯于系统出现状况后重装系统的话\n可以删除这个文件夹，对系统不会造成任何影响。\n\n\nSystem Volume Information\n这是任何一个分区下都会存在的一个文件夹，一般翻译成系统卷标信息文件夹。用于存储系统还原的备份信息以及磁盘分区数据信息\n可以删除\n\n\nWindows\n是Windows系统安装文件所在文件夹，一般用来存储系统安装文件和硬件驱动程序等内容，是系统正常运转的必要保证\n不能删除\n\n\n用户(Users)\n用来储存系统所有用户数据、用户应用程序数据、桌面和开始菜单等内容的文件夹\n一般不删除，但可以移动到其他分区\n\n\n2.文件（下面全部为隐藏文件）\n\n\n\n文件\n说明\n是否可以删除\n\n\n\nbootmgr\n系统启动引导文件\n不能删除\n\n\nconfig.sys\n用于设置一些相关的系统环境,如命令提示符等，该文件内存储着一些配置命令\n不能删除\n\n\nhiberfil.sys\n记录系统进入休眠状态时内存的所有数据。当我们重新开机时，操作系统使用Hiberfil.sys把所有信息放回内存，电脑恢复到关闭前的状态。\n可以删除\n\n\npagefile.sys\n是虚拟内存页面文件，只有在物理内存不够使用的时候，它才会发挥作用\n不能删除，但我们可以将它设置到其他非系统盘\n\n\nswapfile.sys\nWin10系统Metro应用所使用的交换文件，Metro程序会自动挂起在后台运行，会在C盘产生swapfile.sys，Swapfile文件可以加快开关机速度\n不能删除\n\n\n3.Windows文件夹主要文件（※标识重要文件）\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960├WINDOWS  │ ├-system32（存放Windows的系统文件和硬件驱动程序）  ※│ │ ├-config（用户配置信息和密码信息）  │ │ │ └-systemprofile（系统配置信息，用于恢复系统）  │ │ ├-drivers（用来存放硬件驱动文件）  │ │ ├-spool（用来存放系统打印文件。包括打印的色彩、打印预存等）  │ │ ├-wbem（存放WMI测试程序，用于查看和更改公共信息模型类、实例和方法等）  │ │ ├-IME（用来存放系统输入法文件，类似WINDOWS下的IME文件夹）  │ │ ├-CatRoot（计算机启动测试信息目录，包括了计算机启动时检测的硬软件信息）  │ │ ├-Com（用来存放组件服务文件）  │ │ ├-ReinstallBackups（电脑中硬件的驱动程序备份）  │ │ ├-DllCache（用来存放系统缓存文件。当系统文件被替换时，文件保护机制会复制这个文件夹下的文件去覆盖非系统文件）  │ │ ├-GroupPolicy（组策略文件夹）  │ │  │ ├-system（系统文件夹，用来存放系统虚拟设备文件）  ※│ ├-$NtUninstall$（系统每打一个补丁，就会自动创建这样的一个目录）  │ ├-security（系统安全文件夹，用来存放系统重要的数据文件）  │ ├-srchasst（搜索助手文件夹，用来存放系统搜索助手文件，与msagent文件夹类似）  │ ├-repair（系统修复文件夹，用来存放修复系统时所需的配置文件）  │ ├-Downloaded Program Files（下载程序文件夹，用来存放扩展IE功能的ActiveX等插\t件）  │ ├-inf（用来存放INF文件，INF文件最常见的应用是为硬件设备提供驱动程序服务）  │ ├-Help（Windows帮助文件）  │ ├-Config（系统配置文件夹，用来存放系统的一些临时配置的文件）  │ ├-msagent（微软助手文件夹，存放动态的卡通形象，协助更好地使用系统）  │ ├-Cursors（鼠标指针文件夹）  │ ├-Media（声音文件夹，开关机等wav文件存放于此）  │ ├-Mui（多语言包文件夹，用来存放多国语言文件。简体中文系统中这个文件夹默认是空\t的）  │ ├-java（存放Java运行的组件及其程序文件。）  │ ├-Web  │ │ ├-Wall*****（存放桌面壁纸的文件夹）  │ │  │ ├-addins（系统附加文件夹，用来存放系统附加功能的文件）  │ ├-Connection Wizard（连接向导文件夹，用来存放“Internet连接向导”的相关文件）  │ ├-Driver Cache（驱动缓存文件夹，用来存放系统已知硬件的驱动文件）  │ │ └-i386（Windows操作系统自带的已知硬件驱动文件 │ ├-TEMP（系统临时文件夹）  │ ├-twain_32（扫描仪相关）  │ ├-AppPatch（应用程序修补备份文件夹，用来存放应用程序的修补文件）  │ ├-Debug（系统调试文件夹，用来存放系统运行过程中调试模块的日志文件）  │ ├-Resources（系统资源文件夹，存放系统SHELL资源文件，即桌面主题）  │ │ └-Themes（桌面主题都存放于此）  │ ├-WinSxS（存储各个版本的Windows XP组件，减少因为DLL文件而引起的配置问题）  │ ├-ime（输入法信息）  │ ├-PCHealth（用来存放协调、配置和管理计算机正常运行的文件）  │ │ └-HelpCtr（帮助和支持）  │ │ ├-Binaries（常用的msconfig就在这里）  │ ├-Offline Web Pages（脱机浏览文件存放于此）  │ ├-Prefetch（预读取文件夹，用来存放系统已访问过的文件的预读信息(此信息是系统在访\t\t\t\t问时自动生成的新信息)，以加快文件的访问速度，其扩展名为“PF”。）  │ ├-ShellNew  │ ├-Fonts（字体文件夹。要安装某种字体只需将字体文件复制到该目录下即可）  │ ├-pss（用来备份系统启动配置文件的，一般对“Boot.ini”、“System.ini”和“Win.ini”\t三个文件进行备份，扩展名为“backup”。如果系统原有的这三个文件损坏的话，可以从\t这里进行恢复。）  │ ├-Registration（注册文件夹，用来存放用于系统COM＋或者其他组件注册的相关文\t件。）  │ └-Downloaded Installations（存放一些使用Windows Installer技术的安装程序，主\t要用来对程序进行修复等操作）  \n\n\n\n","slug":"C盘目录介绍","date":"2021-05-10T12:15:57.940Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"b5ce2ffbcd0c3dfcb1b8e26446e4a650","title":"Object Detection_番外篇","content":"1 数据集\n2 评价指标\n\n3 COCO mAP在COCO数据集评价指标中，所有的AP 默认为mAP\n\n\n4 train_val_test\n","slug":"Object Detection_番外篇","date":"2021-04-30T07:25:20.179Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"d0833af25ffe4b7c183344dd301cd999","title":"Image_Classfication","content":"0 前言以下为读研期间针对分类模型做的一些相关工作。\n1 AlexNet\n\n2 VGG\n\n\n3 GooleNet\n\n\n\n4 RestNet\n两种残差块\n\n\n\n\n\n5 MobileNet5.1 MobileNet V1\n\n\n\n5.2 MobileNet V2\n\n\n这个n表示我们使用多少个该倒残差结构，这个图上s仅仅是针对的第一个倒残差结构的第一层，如果有两个倒残差结构，\n那么第二个倒残差结构的第一层就是1，和图上无关。\n这个扩展因子t指的是倒残差结构的第一层1 * 1卷积的输出channel是输入channel的多少倍，也就是一共有t * k个1 * 1 的卷积核。具体可以看上面一张图。\n\n5.3 MobileNet V3\n创新1：更新Block\n\nSE模块 ：\n\n更新的激活函数：\n\n创新2：重新设计耗时层结构\n\n网络设计：\nexp_size：经过1 * 1卷积升到多少维度\n这个注意点：本来1 * 1的卷积我们是希望它起到升维的作用的，但是在图上会发现这一层的eexp_size和输入的channel\n是一样大小的，这也就是说在这一层其实并没有用到1 * 1卷积。论文中这里没有说，留意下即可。\n\n6 ShuffleNet6.1 ShuffleNet V1\n\n\n6.2 ShuffleNet V2\n\n\n\n\n\n7 EfficientNet\n\n\n\n\n8 FPN\n网络结构：\n\n\n","slug":"Image_Classfication","date":"2021-04-25T06:40:04.949Z","categories_index":"Python,deep learning,object detection","tags_index":"Python,deep learning,object detection","author_index":"Vegetabhl"},{"id":"633ca7106f3b7f3dd7a3e374f591dcba","title":"Object Detection","content":"0 前言以下为读研期间做的一些相关工作，其中one-stage相关模型没有写全，截止毕业时期的sota模型详情请参照毕业论文。\n\n1 two-stage1.1 RCNNRCNN没写 \n\n1.2 Fast-RCNN1.2.1 整体结构\n1.2.2 算法推理流程\n这里的正负样本是用来训练分类和边界框回归参数的训练数据\n\n1.2.3 训练过程-边界框回归损失\n\n1.3  Faster-CNN1.3.0 RPN参考：\nhttps://www.cnblogs.com/Terrypython/p/10584384.html\n这里需要说下，下面这张图上的9是每个特征点对应的anchor个数，也就是分配的9个，所有的anchor个数应该等于对应下图的16 * 16 *9。\n\n问题：如果特征图上一个特征点（对应一维特征向量）的感受野小于实际anchor的大小，那还能预测准确吗？比如下图采用VGG作为backbone，那它的实际感受野大小仅为228，但是我最大的anchor已经达到了512。\n​        答：可以，可以用一个小的感受野的特征来近似代替大的anchor的特征，从而完成预测。论文中有提及到，这就像假设平时人眼观察某一物体，只需要观察一部分就可以推断出具体是什么一样。\n\nloss:\n\nN_cls：表示我们采样的正负样本个数，也就是说只有我们采样的正负样本（anchor）才贡献了loss,不是所有的。\n\nN_reg:表示所有位置，也就是特征图的W * H\n\n\n具体loss部分看1.3.3\n\n1.3.1 整体结构\n1.3.2 算法推理过程\n1.3.3 训练过程\n正负样本机制选取策略（训练阶段）：\n\n这里只写了RPN分类损失，对于边界框回归损失和Fsat-RCNN写的一样\n\n原论文采用的分步训练分步训练RPN网络和Fast-RCNN网络，现在更多的是采用联合训练的办法\n\n2 one-stage2.1 yolov1\nconfidence损失：w，h求损失的时候使用开根号后计算loss。假设对于两个不同尺度大小的gt。假设我们的预测bbox相对gt的偏移量都相同。那大尺度的预测效果会更好一些，因为它的iou大嘛。那所有我们肯定是希望效果好的（大目标）loss小一点，效果差的（小目标）loss大一点，所以就用开根号来缓解。看下根号下x的函数图就明白了。\n\n2.2 yolov2\n\n2.2.1高分辨率分类器之前学习的分类器都是采用224*224大小输入图像进行训练，作者在这里使用448 * 448的输入大小训练得到的分类网络进行迁移学习。\n\n2.2.2 直接位置预测那其实可以很容易想到，如果不限制t_x，t_y。一开始的时候因为是随机初始化的参数，那对t_x，t_y的预测就可能非常大，那bbox就不知道飘哪去了。再回过头来通过梯度下降来修正，那这样肯定很不稳定啊，并且多此一举，为什么不直接在一开始就限制t_x，t_y的大小呢。\n所以这就是yolov2关于位置预测的改进：不再使用直接预测的偏移量来计算box，而是使用相对grid cell的偏移量进行预测。\n这个相对grid cell的偏移量就是对直接预测的偏移量再套个sigmod函数限制。\n\n2.2.3 更精细的特征图也就是通过和低层的特征进行融合，作者发现这样可以提升检测小目标的效果。\n\n2.2.4 多尺度训练增强模型鲁棒性\n\n\n2.3 yolov3建议参考链接\nhttps://blog.csdn.net/qq_37963059/article/details/116610443\n\n\n\n\n2.4 yolov3spp\n\n\n\n\n网络结构：\n\n2.5 RetinaNet\nbackbone:\n\nhead:\n\nloss:\n\n","slug":"Object Detection","date":"2021-04-23T07:46:28.308Z","categories_index":"Python,deep learning,object detection","tags_index":"Python,deep learning,object detection","author_index":"Vegetabhl"},{"id":"15f9d1d91ee25a75875831eb19af361b","title":"base_env","content":"1 常用命令\n列举当前所有环境\n\n1conda env list                    //显示所有的虚拟环境\n\n\n\n\n创建虚拟环境\n\n1conda create -n your_env_name python=3.x #也可以在python后面直接输入想要安装的库，但是不建议，最好统一pip安装\n\n\n\n\n删除某个虚拟环境\n\n1conda remove -n xxxx --all   //删除xxxx虚拟环境\n\n\n\n\n进入某个环境\n\n1activate your_env_name\n\n\n\n\n更新pip\n\n1python -m pip install --upgrade pip\n\n\n\n\n查询可升级的包\n\n1pip list -o\n\n\n\n\n查询Python版本\n\n1python -V\n\n\n\n\n查询对应库信息\n\n1pip show xxx\n\n\n\n\n\n查看当前环境所安装的包\n\n1pip list\n\n\n\n\n安装所需要的包\n\n1pip install xxx -i https://mirrors.aliyun.com/pypi/simple/\n\n\n\n\npip卸载该环境下安装的某个包\n\n1pip uninstall xxx  #结合上面那个pip list \n\n\n\n\nconda卸载环境下安装的某个包\n\n1conda uninstall xxx   //卸载xxx包\n\n\n\n\nTensorboard\n\n1tensorboard --logdir ./\n\n注意：conda 和 pip 是两套机制，尽量不要去混用。\n conda的pkgs文件夹下的清理\n​\t\t通过conda clean -p来删除一血没用的包，这个命令会检查哪些包没有在包缓存中被硬依赖到其他地方，并删除它们。第二步：通过conda clean -t可以将conda保存下来的tar包。经过上面两步，我的anaconda便变成了4.3G，几乎瘦身一半。有一点要注意的是，conda clean命令是对所有anaconda下的包进行搜索，当然也包括构建的其他Python环境中的包，这一点还是很高效的，不用再进入其他环境重复操作。事实上conda clean -a g更高效。具体看文档链接。\nhttps://docs.conda.io/projects/conda/en/latest/commands/clean.html#Removal%20Targets\n2 PyTorch安装2.1 TensorFlow2参考：https://blog.csdn.net/qq_37963059/article/details/113339101\n注意下cuda安装的时候一些小细节还有环境变量的配置，可以参照龙龙老师，上面博客安装的不好，很乱，没有细说。\n&#x2F;&#x2F;或者可以直接conda命令在不同环境下安装不同版本cudatoolkit，区分管理。（建议这样做，更建议只用conda命令创建环境，其余全部用pip命令来安装，可以本采用本地安装的方式安装多个不同版本cuda和cudnn会更直观一些）\n2.2 PyTorch安装官网：https://pytorch.org/get-started/previous-versions/#osx-1\n离线下载地址：https://download.pytorch.org/whl/torch_stable.html\n注：版本对应关系官网选择下载时已经写清楚\n1 验证安装成功\n123import torchtorch.cuda.is_available()exit()\n\n2 官方地址\n12conda安装    -c pytorchpip安装      -f https://download.pytorch.org/whl/torch_stable.html\n\n\n\n3 注意：PyTorch 将 CUDA Runtime API 内置到了他自己的 Python 包里。也就是说 PyTorch 是自带 Runtime API 的，不需要在安装 cuda-toolkit 😥（cuda-toolkit 就是安装 CUDA Runtime API）\n\n3 TensorFlow安装conda install tensorflow-gpu&#x3D;&#x3D;2.x.x  这一条命令就可以了\n3.1 构建配置版本对应关系查看–\nwindows（Tensorflow）\n\n​          版本对应：https://tensorflow.google.cn/install/source_windows\n\nLinux&#x2F;macOS下（Tensorflow）\n\n​          版本对应：https://tensorflow.google.cn/install/source#tested_build_configurations\n3.2 离线下载\ntensorflow-gpu离线下载地址：\n\n​\t\t-  http://mirrors.aliyun.com/pypi/simple/tensorflow-gpu/\n​\t\t-  https://pypi.org/\n\ncudnn离线下载地址（cuda和cudnn对应关系）：\n\n​\t\thttps://developer.nvidia.com/rdp/cudnn-archive#a-collapse742-10  （尽量不需要乱动cudnn）\n\ncuda离线下载地址\n\n​\t\thttps://developer.nvidia.com/cuda-toolkit-archive\n3.3 TensorFlow本地安装流程、环境变量设置、验证安装成功​\thttps://blog.csdn.net/qq_37963059/article/details/113339101\n\n这个地方可以下载各种conda安装的包，包括cuda、cudnn：https://repo.anaconda.com/pkgs/main/\n\n注意：这里要提一下，如果采用conda install tensorflow-gpu&#x3D;&#x3D;1.12.0这种命令形式，它会连带把比如cudatoolkit，cudnn这些全部给安装好，类似集成化的形式。\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n4 CUDA对应的NVIDIA驱动版本https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html\n5 conda和pip更改国内镜像源5.1 conda切换国内源清华好像已经停止服务了，这里用上交大源\n1234conda config --add channels https://mirrors.sjtug.sjtu.edu.cn/anaconda/cloud/pytorch/conda config --add channels https://mirrors.sjtug.sjtu.edu.cn/anaconda/pkgs/main/conda config --add channels https://mirrors.sjtug.sjtu.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.sjtug.sjtu.edu.cn/anaconda/cloud/conda-forge/\n\n1234#显示安装通道conda config --set show_channel_urls yes恢复复默认设置conda config --remove-key channels\n\n注意输入终端命令一定要去掉官网指令最后面的-c pytorch\n.condarc\n1234567891011121314151617channels:  - defaultsshow_channel_urls: truedefault_channels:  - https://mirrors.bfsu.edu.cn/anaconda/pkgs/main  - https://mirrors.bfsu.edu.cn/anaconda/pkgs/free  - https://mirrors.bfsu.edu.cn/anaconda/pkgs/r  - https://mirrors.bfsu.edu.cn/anaconda/pkgs/pro  - https://mirrors.bfsu.edu.cn/anaconda/pkgs/msys2custom_channels:  conda-forge: https://mirrors.bfsu.edu.cn/anaconda/cloud  msys2: https://mirrors.bfsu.edu.cn/anaconda/cloud  bioconda: https://mirrors.bfsu.edu.cn/anaconda/cloud  menpo: https://mirrors.bfsu.edu.cn/anaconda/cloud  pytorch: https://mirrors.bfsu.edu.cn/anaconda/cloud  simpleitk: https://mirrors.bfsu.edu.cn/anaconda/cloud\n\n修改后再执行这条命令生效下 -\n1conda config --set show_channel_urls yes\n\n\n\n\n\n5.2 pip切换国内源打开用户目录%HOMEPATH%，在此目录下创建 pip 文件夹，在 pip 目录下创建 pip.ini 文件, 内容如下 ：\n12345678[global]  index-url = http://mirrors.aliyun.com/pypi/simpletrusted-host = mirrors.aliyun.comdisable-pip-version-check = truetimeout = 120   [list]format = columns\n\n\n\n6 总结6.1 conda和pip命令的个人使用习惯位置1234conda create -n your_env_name python=3.xactivate your_env_nameconda 安装cudatoolkit和cudnn (安装了系统环境下一个本地通用的版本后一般来说都能用，不能用再使用这个命令)pip 安装需要的库\n\n用国内源安装，如下：\nconda install cudatoolkit&#x3D;10.1 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/linux-64/\n找不到对应版本去这个地址找，下同：https://anaconda.org/\n在安装了 cudatoolkit 后，只要系统上存在与当前的 cudatoolkit 所兼容的 Nvidia 驱动，则已经编译好的 CUDA 相关的程序就可以直接运行，而不需要安装完整的 Nvidia 官方提供的 CUDA Toolkit .\nconda install cudnn&#x3D;7.6.5 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/linux-64/\n注意：conda 和 pip 是两套机制，尽量不要去混用，另外像cuda和cudnn采用本地安装的方式安装多个不同版本可能会看着更整齐一些。\n6.2 conda install和pip install有什么区别?6.2.1 pip1234pip install xxx ,在特定环境里使用pip，下载的包会存在特定环境的目录里面，例如:D:\\Anaconda3\\envs\\nlp\\Lib\\site-packages\\fasttext使用pip uninstall xxx，包就卸载掉了，也可以用conda remove --name nlp --all 来删除环境\n\n6.2.2 conda123conda install xxx ，不管在什么环境下载的包，都统一放在一个目录里面：D:\\Anaconda3\\pkgs在某个环境下面下载了某个包，再到另外一个环境下载同样的包,conda会自动在上面的目录里面找，和直接pip install 一样）\n\n\n\n使用conda uninstall xxx时，和pip uninstall一样，删除了当前虚拟环境下site-packages里面的包内容，但是在上述目录里面还存在这个包，此时再到另外一个环境下载这个包，还是将site-packages复制一份到当前环境下，做到了一次下载，到处使用。\n注：以上配置全部为windows环境下，linux环境下配置可能会有差异，没试过。\n\nsame卷积：如果f为奇数，则p设置为p &#x3D; ( f − 1 ) &#x2F; 2\n卷积后的尺寸大小：(n+2p-f)&#x2F;s +1 （向下取整）需要注意的是这里的2p表示的是左右两列增加列数之和，左右两列不一定完全是相等的。\n","slug":"base_env","date":"2021-01-28T11:41:12.984Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"0d6a3caed7148d18d6e5a146bd1ec2e3","title":"tf-gpu","content":"配置tensorflow环境先提前下载好Cudnn和CUDA并安装好。\nWin+R启动cmd，在命令提示符内输入以下命令：\n\nconda create –n tensorflow-gpu python&#x3D;3.6\t（或者anconda手动创建个环境也一样）\n\nactivate tensorflow-gpu \n\npip install tensorflow-gpu&#x3D;&#x3D;1.13.2 -i https://mirrors.aliyun.com/pypi/simple/\n\npip install keras&#x3D;&#x3D;2.1.5 -i https://mirrors.aliyun.com/pypi/simple/\n\n\n注意：\n由于h5py库的更新，安装过程中会自动安装h5py&#x3D;3.0.0以上的版本，会导致decode(“utf-8”)的错误！各位一定要在安装完tensorflow后利用命令装h5py&#x3D;2.10.0！\n\npip install h5py&#x3D;&#x3D;2.10.0\n\n参考来源：\nhttps://blog.csdn.net/weixin_44791964/article/details/104702142\n","slug":"tf-gpu","date":"2020-12-21T08:49:38.158Z","categories_index":"","tags_index":"Python","author_index":"Vegetabhl"},{"id":"bda54d69820bfb5fcc76ba62cbc330ef","title":"IDEA_Debug","content":"01_Debug简介和意义\n什么是程序DeBug？\n\nDebug，是程序开发人员必会的一项调试程序的技能。\n\n企业中程序开发和程序调试的比例为1:1.5，可以说如果你不会调试程序，你就没有办法从事编程工作。\n\n\n\nDebug能帮助我们做什么？\n\n追踪代码的运行流程。\n程序运行异常定位。\n线上问题追踪。\n\n\nDebug对于程序学习者的意义\n\n通过调试能够更好的查看程序的执行流程。\n复杂的程序逻辑，通过老师的口述讲解，很难理解清楚，这个时候借助调试能够很好的帮助同学们理解程序。\n定位问题，提高自我解决问题的能力。\n\n\n\n02_IDEA中的Debug步骤\n设置断点（F9）\n\n调试程序（8个按钮）\n\n\n\n\n按钮\n说明\n\n\n\n\n(Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行\n\n\n\n(F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。\n\n\n\n(F7)：步入。如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法。\n\n\n\n(Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。\n\n\n\n(Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。\n\n\n\n回退断点。\n\n\n\n(Alt + F9)：运行到光标处，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。\n\n\n\n(Alt + F8)：计算表达式。\n\n\n\n观察变量\n\n查看变量有三种方式：\n程序区查看变量\nDebugger的Variables中查看变量\n鼠标悬停到变量名上会弹出当前变量的值\n\n\n\n\n\n查看输出\n\n\n03_跳转到当前代码执行的行\n跳转到当前代码执行的行（Alt + F10）\n\n作用\n\n使程序窗口切换到当前正在运行的程序处。\n\n\n\n04_步过调试的使用\n步过调试\n步过调试按钮（F8）\n\n\n作用\n步过，一行一行地往下走，如果这一行上有方法不会进入方法。\n常用于调试过程中不想进入调用的方法体的情况。\n\n\n\n05_步入调试的使用\n步入调试\n\n步过调试按钮（F7）\n\n\n作用\n\n步入，一行一行地往下走，如果这一行上有方法，则进入方法内部。\n\n一般用于进入自定义方法内，不会进入官方类库的方法。\n\n\n\n\n06_强制步入调试的使用\n强制步入调试\n\n强制步入调试按钮（Alt + Shift + F7）\n\n\n作用\n\n进入官方类库方法\n\n帮助我们学习和查看JDK源码\n\n\n\n\n07_步出调试的使用\n步出调试\n\n步出调试按钮（Shift + F8）\n\n\n作用\n\n从方法内退出到方法调用处。\n调试的时候，有时候会跳入到自己不想查看的方法体，这个时候使用步出。\n\n\n\n08_回退断点调试的使用\n回退断点\n\n回退断点按钮\n\n\n作用\n\n回退到当前方法的调用处。\n\n当想重新查看该方法体的执行过程时，不用重新启动Debug，可以使用回退断点方式。\n\n\n\n\n09_运行到光标处\n运行到光标处\n运行光标处按钮 （F9）\n作用\n使程序运行到光标处，而无需设置断点。\n\n\n\n\n\n10_计算表达式\n计算表达式\n\n计算表达式按钮（Alt + F8）\n\n\n\n\n作用\n\n设置变量，在计算表达式的框里，可以改变变量的值，这样有时候就能很方便我们去调试各种值的情况了。\n\n\n\n11_条件断点\n条件断点\n\n右键单击断点处，可以设置进入断点的条件\n\n\n\n\n作用\n\n通过设置断点条件，在满足条件时，才停在断点处，否则直接运行。\n\n\n\n12_多线程调试\n步骤\n多线程调试，需要调整断点挂起级别为Thread\n\n\nFrame中选择线程进行调试\n\n\n\n\n","slug":"IDEA_DeBug","date":"2020-12-06T07:54:31.221Z","categories_index":"","tags_index":"Java","author_index":"Vegetabhl"},{"id":"4e798bd33064c933781222772b766c85","title":"Welcome","content":"\n","slug":"Welcome","date":"2020-12-05T14:11:31.111Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"48a8382a301dd15da0fdbd2032cdbee9","title":"hexo搭建  --Vegeta","content":"Vegetahexo搭建流程—\t#安装Nodejs （简单理解就是一个js的运行环境）node -v\t#查看node版本npm -v\t#查看npm版本npm install -g cnpm –registry&#x3D;http://registry.npm.taobao.org\t#安装淘宝的cnpm 管理器，或者直接nrm切换镜像源工具我感觉更好，nrm使用教程在最下面，建议nrmcnpm -v\t#查看cnpm版本cnpm install -g hexo-cli    #安装hexo框架hexo -v\t#查看hexo版本mkdir blog\t#创建blog目录cd blog\t #进入blog目录sudo hexo init \t#生成博客 初始化博客hexo s\t#启动本地博客服务http://localhost:4000/\t#本地访问地址hexo n “我的第一篇文章” #创建新的文章#返回blog目录hexo clean #清理hexo g #生成#Github创建一个新的仓库 YourGithubName.github.iocnpm install –save hexo-deployer-git #在blog目录下安装git部署插件-—#配置_config.yml-—-\nDeployment\nDocs: https://hexo.io/docs/deployment.html\n​\tdeploy:          type: git         repo: https://github.com/YourGithubName/YourGithubName.github.io.git          branch: master   #注意，这里要看你githhub默认分支是哪个-—-hexo d\t#部署到Github仓库里https://YourGithubName.github.io/  #访问这个地址可以查看博客\n git clone https://github.com/litten/hexo-theme-yilia.git themes&#x2F;yilia  #下载yilia主题到本地，嫌慢直接根据上面地址下载解压到对应的themes&#x2F;yilia路径下也行\n#修改hexo根目录下的 _config.yml 文件 ： theme: yilia\nhexo c\t#清理一下hexo g\t#生成hexo d\t#部署到远程Github仓库https://YourGithubName.github.io/  #查看博客\nnrm我们首先安装nrm，这里-g代表全局安装。可能需要一点儿时间\n1npm install nrm -g\n\n\n然后通过nrm ls命令查看npm的仓库列表,带*的就是当前选中的镜像仓库：\n\n通过nrm use taobao来指定要使用的镜像源：\n\n关于hexo 本地图片不显示问题解决先放链接：\nhttps://blog.csdn.net/Strong997/article/details/97767929?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-6.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-6.control\n测试：\n\n","slug":"hexo搭建","date":"2020-12-04T15:29:12.000Z","categories_index":"","tags_index":"","author_index":"Vegetabhl"},{"id":"7d84a4176eacfd91fe4b92da8af8cc6a","title":"Python","content":"0 格式格式要求如下：\n\n在索引和内容之间需要加一个空格，包括所有级索引、标题和内容。\n内容顶格书写\n所有级标题之间需要添加一行空白行\n正文段落首行缩进，但是对于提出的问题不需要缩进\n\n–return;      ：结束当前方法，不在方法内无法使用\nbreak;        :  结束当前循环\n1 变量注意事项：\n\nPython定义变量的时候只能包含字母、数字、下划线，并且不能以数字开头。\n严格区分大小写，大小写s不一样，变量也不一样。\n\n2 格式化输出1234567891011# 小数点后保留两位有效数字print(&#x27;我的体重是%.2f公斤&#x27; % weight)# 表示输出的整数显示位数，不足以0补全，超出当前位数则原样输出print(&#x27;我的学号为%03d&#x27; % stuId)print(&#x27;我的名字是%s,我今年%d岁了&#x27; % (name, age))#  f&#x27;&#123;表达式&#125;&#x27;print(f&#x27;我叫&#123;name&#125;,我今年&#123;age+1&#125;岁了&#x27;)\n\n\n\n3 转义字符12345# 转义字符，稍微注意下是反斜杠# \\n# \\t(相当于四个空格间距)print(&quot;Hello\\nWorld&quot;)print(&quot;\\tabcde&quot;)\n\n\n\n4 自己写结束符123print(&quot;结束符1&quot;, end=&quot;\\n&quot;)print(&quot;结束符2&quot;, end=&quot;...&quot;)print(&quot;结束符2&quot;)\n\n\n\n5 输入1234# 输入password = input(&quot;请输入密码&quot;)print(f&#x27;密码是&#123;password&#125;&#x27;)print(type(password))\n\n\n\n6 数据类型6.1 转换数据类型的函数\n\n\nint(x [,base ])\n将x转换为一个整数\n\n\n\nfloat(x)\n将对象 x 转换为字符串\n\n\nstr(x)\n将对象 x 转换为字符串\n\n\neval(str)\n用来计算在字符串中的有效Python表达式,并返回⼀个对象\n\n\ntuple(s)\n将序列 s 转换为⼀个元组\n\n\nlist(s)\n将序列 s 转换为一个列表\n\n\n​\t注意：\n​\t\t\t每一次转换后都是一个新的值了，用新的变量接收它。\n6.2 eval() –把字符串中的数据转换为它原本的类型12345678910# eval() --把字符串中的数据转换为它原本的数据类型str1=&quot;1&quot;str2=&quot;1.1&quot;str3=&quot;[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]&quot;str4=&quot;(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;)&quot;print(type(eval(str1)))print(type(eval(str2)))print(type(eval(str3)))print(type(eval(str4)))\n\n\n\n7 运算符复习\n\n\n运算符\n描述\n实例\n\n\n\n&#x2F;&#x2F;\n整除\n9 &#x2F;&#x2F; 4 输出结果为2\n\n\n%\n取余\n9 % 4 输出结果为 1\n\n\n**\n指数\n2 ** 4 输出结果为 16，即 2 * 2 * 2 * 2\n\n\n()\n小括号\n小括号⽤用来提高运算优先级，即 (1 + 2) * 3 输出结果为 9\n\n\n​\t注意：\n​\t1是斜杠，不是反斜杠\n​\t2在运算中，若有数字为小数，则最后结果也为浮点数，如2*0.5&#x3D;1.0\n​\t3运算中，指数的优先级要高于普通的乘法，如2*3**2&#x3D;18\n​\t\n8 Python Console在做一些简单测试时可以在Python Console中写代码，数据是保存在内存中临时的\n9 多个变量量赋值9.1 多个变量赋相同值123a = b = 10print(a)print(b)\n\n\n\n9.2 多个变量赋不相同值1234num1, float1, str1 = 10, 0.5, &#x27;hello world&#x27;print(num1)print(float1)print(str1)\n\n\n\n10 复合赋值运算符注意：\nc&#x3D;10\nc +&#x3D; 1 * 2 在这个式子中，是先算1 * 2 &#x3D;2,然后再算c&#x3D; c+2\n结果c&#x3D;12\n11逻辑运算符\n12 条件语句12.1 if嵌套if 条件1：    条件1成立执行的代码        if 条件2：            条件2成⽴执行的代码\n12.2 猜拳游戏 1 导出random模块\n 2 使用random模块中的随机整数功能–random.randint(开始,结束) \n12345678910import randomplayer = int(input(&quot;玩家请出拳，0-拳头，1-剪刀，2-布:\\n&quot;))computer = random.randint(0, 2) # 这个方法这种写法随机数有三个0,1,2。也就是说它是左右都包括print(f&quot;电脑出拳为&#123;computer&#125;&quot;)if ((player == 0 and computer == 1) or (player == 1 and computer == 2) or (player == 2 and computer == 0)):    print(&quot;玩家获胜&quot;)elif (player == computer):    print(&quot;平局&quot;)else:    print(&quot;电脑获胜&quot;)\n\n\n\n12.3 三目运算符条件成立执⾏的表达式 if 条件 else 条件不成立执行的表达式 \n12345# 三目运算符aa = int(input(&quot;输入数字aa&quot;))bb = int(input(&quot;输入数字bb&quot;))cc = (aa - bb) if (aa &gt; bb) else (bb - aa)print(cc)\n\n\n\n13 while循环(嵌套循环)13.1 代码注意：\n​\t\t在使用continue的之前一定要修改计数器，否则就会导致死循环现象（对计数器的改变代码通常放在continue的上一行代码）\n12345678j = 0while j &lt; 5:    if j == 2:        print(&quot;吃饱了&quot;)        j += 1        continue    print(f&#x27;吃了&#123;j&#125;个苹果&#x27;)    j += 1\n\n注意：\n​\t\t使用while嵌套循环的时候记得要把内层嵌套循环的计数器放到里面，注意格式顺序问题\n九九乘法表“(注意联动关系)：\n12345678j = 1while j &lt; 10:    i = 1    while i &lt;= j:        print(f&quot;&#123;i&#125;*&#123;j&#125;=&#123;j * i&#125; &quot;, end=&quot;\\t&quot;)        i += 1    print()    j += 1\n\n\n\n13.2 while…else格式：\nwhile 条件:    条件成立重复执行的代码else:   循环正常结束之后要执行的代码\n注意（同样适用与for循环中的else）：\n1：如果是break结束的循环，则属于非正常结束循环，也就不会执行else之后的代码\n2：如果是continue跳过的循环，则结束后属于正常结束循环，会执行else之后的代码\n14 字符串注意 \n单引号和双引号是单行字符串三引号是多行字符串，可以直接输入回车，而不需要用\\n来表示也可以用来表示多行注释\n1 三引号也是字符串类型\n2 三引号形式的字符串支持写代码时换行。并且打印输出的时候也是换行的，而单引号和双引号则不行\n3 单引号只能套双引号，反之也一样，当然也可以 通过 \\ 的方式来做转义符\n12345# 三个引号支持换行str1 = &quot;&quot;&quot;helelworld&quot;&quot;&quot;print(type(str1[5:6])) #注意这里，上面的helel后面不是直接跟着w，而是还有个空字符串\n\n\n\n15 切片：对字符串的切片操作切片是指对操作的对象截取其中⼀部分的操作。字符串、列表、元组都支持切片操作。\n15.1 语法格式：序列[开始位置下标:结束位置下标:步长]\n15.2 代码注意：\n左闭右开，只包含左边，不包含右边。\n123456789101112131415# 切片# 序列[开始位置下标:结束位置下标:步长]    # 默认步长就是1    #（步长为正数表示从左往右数，为负数表示从右往左走）    #-1表示最后一个，0表示第一个str1 = &#x27;012345678&#x27;print(str1[0:4:1])  # 步长1可以省略，默认步长就是1print(str1[0:4])  # 默认步长就是1print(str1[2:])  # 从下标为2处开始，一直到结束print(str1[:-1])  # 从第一个字母开始，一直到结束，但是不包含最后一个（左闭右开原则）#print(str1[-5:-1:-1]) #注意这种输出是没有结果的，因为顺序不对。                      # -5到-1位置应该是从右往左，步长应该写为正数，或者将开始结束下标改变\n\n\n\n16 对字符串的查找&amp;修改操作16.1 查找1 find()： 检测某个子串是否包含在这个字符串中，如果在,返回这个子串开始的位置下标，否则则返回**-1**。\n语法：字符串序列.find(子串, 开始位置下标, 结束位置下标)  &#x2F;&#x2F;开始和结束为止下标可以不写，默认从0为止开始查找\n1234mystr = &quot;hello world and itcast and itheima and Python&quot;print(mystr.find(&quot;and&quot;)) #12print(mystr.find(&quot;and&quot;,15,30)) #23\n\n\n\n2 index()：检测某个子串是否包含在这个字符串中，如果在,返回这个子串开始的位置下标，否则则报异常。\n字符串序列.index(子串, 开始位置下标, 结束位置下标) \n1234mystr = &quot;hello world and itcast and itheima and Python&quot;print(mystr.index(&#x27;and&#x27;)) # 12print(mystr.index(&#x27;and&#x27;, 15, 30)) # 23print(mystr.index(&#x27;ands&#x27;)) # 报错\n\n\n\n3 count()：返回统计某个子串在字符串中出现的次数\n\nrfind()： 和find()功能相同，但查找方向为右侧开始。\nrindex()：和index()功能相同，但查找方向为右侧开始。\ncount()：返回某个子串在字符串中出现的次数\n\n16.2 修改replace()：替换\n语法：字符串序列.replace(旧子串, 新子串, 替换次数) \n这里需要注意下，字符串为不可变类型，使用replace()方法后必须用一个新的变量来接收\n12345678mystr = &quot;hello world and itcast and itheima and Python&quot;# 结果：hello world he itcast he itheima he Pythonprint(mystr.replace(&#x27;and&#x27;, &#x27;he&#x27;))# 结果：hello world he itcast he itheima he Pythonprint(mystr.replace(&#x27;and&#x27;, &#x27;he&#x27;, 10))# 结果：hello world and itcast and itheima and Pythonprint(mystr)\n\n\n\n\n\nsplit()：按照指定字符分割字符串。\n语法：字符串序列.split(分割字符, num) \n注意：num表示的是分割字符出现的次数，即将来返回数据个数为num+1个。\n123456789mystr = &quot;hello world and itcast and itheima and Python&quot;# 结果：[&#x27;hello world &#x27;, &#x27; itcast &#x27;, &#x27; itheima &#x27;, &#x27; Python&#x27;]print(mystr.split(&#x27;and&#x27;))# 结果：[&#x27;hello world &#x27;, &#x27; itcast &#x27;, &#x27; itheima and Python&#x27;]print(mystr.split(&#x27;and&#x27;, 2))# 结果：[&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;and&#x27;, &#x27;itcast&#x27;, &#x27;and&#x27;, &#x27;itheima&#x27;, &#x27;and&#x27;, &#x27;Python&#x27;]print(mystr.split(&#x27; &#x27;))# 结果：[&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;and itcast and itheima and Python&#x27;]print(mystr.split(&#x27; &#x27;, 2))\n\n\n\n\n\njoin()：用⼀个字符或子串合并字符串，即是将多个字符串合并为一个新的字符串。\n语法:字符或子串.join(多字符串组成的序列) \n123456list1 = [&#x27;chuan&#x27;, &#x27;zhi&#x27;, &#x27;bo&#x27;, &#x27;ke&#x27;]t1 = (&#x27;aa&#x27;, &#x27;b&#x27;, &#x27;cc&#x27;, &#x27;ddd&#x27;)# 结果：chuan_zhi_bo_keprint(&#x27;_&#x27;.join(list1))# 结果：aa...b...cc...dddprint(&#x27;...&#x27;.join(t1))\n\n\n\n\n\njoin()：用⼀个字符或子串合并字符串，即是将多个字符串合并为⼀个新的字符串。\n语法:字符或子串.join(多字符串组成的序列) \n1# 注意使用join()时，列表或者元祖里面只能是字符串\n\n123456list1 = [&#x27;chuan&#x27;, &#x27;zhi&#x27;, &#x27;bo&#x27;, &#x27;ke&#x27;] #列表或者元祖里面只能是字符串t1 = (&#x27;aa&#x27;, &#x27;b&#x27;, &#x27;cc&#x27;, &#x27;ddd&#x27;)# 结果：chuan_zhi_bo_keprint(&#x27;_&#x27;.join(list1))# 结果：aa...b...cc...dddprint(&#x27;...&#x27;.join(t1))\n\n\n\n\n\n其余对字符串的操作\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546mystr = &quot;hello world and itcast and itheima and Python&quot;# 只有首字母大写print(mystr.capitalize())# 每个单词首字母大写print(mystr.title())# 全部字母转大写print(mystr.upper())# 全部字母转小写print(mystr.lower())print(&quot;1-----------------------------------------&quot;)mystr2 = &quot;    hello world and itcast and itheima and Python    &quot;# 删除字符串左边空白print(mystr2.lstrip())# 删除字符串右边空白print(mystr2.rstrip())# 删除字符串两边空白print(mystr2.rstrip())print(&quot;2-----------------------------------------&quot;)mystr3 = &quot;hello&quot;# 返回⼀个原字符串左对⻬,并使用指定字符(默认空格)填充⾄对应⻓度的新字符串。print(mystr3.ljust(10,&quot;.&quot;))# 返回⼀个原字符串右对⻬,并使用指定字符(默认空格)填充⾄对应⻓度的新字符串。print(mystr3.rjust(10,&quot;.&quot;))# 返回⼀个原字符串居中对⻬,并使用指定字符(默认空格)填充⾄对应⻓度的新字符串。print(mystr3.center(10,&quot;.&quot;))print(&quot;3-----------------------------------------&quot;)mystr4 = &quot;hello world and itcast and itheima and Python&quot;# 检查字符串是否是以指定⼦串开头，是则返回 True，否则返回 False。如果设置了开始和结束位置下标，则在指定范围内检查。print(mystr4.startswith(&quot;world&quot;,6,15))# 检查字符串是否是以指定⼦串结尾，是则返回 True，否则返回 False。print(mystr4.endswith(&quot;Python&quot;))print(&quot;4-----------------------------------------&quot;)mystr5 = &quot;hello world and itcast and itheima and Python&quot;# 全是字母返回true,否则falseprint(mystr5.isalpha())# 全是字母返回数字,否则falseprint(mystr5.isdigit())# 字母或数字或组合返回true,否则falseprint(mystr5.isalnum())# 全是空白返回true,否则falseprint(mystr5.isspace())\n\n运行结果\n\n17 列表列表是一个可变类型\n所谓可变类型就是说我可以在列表自身基础之上修改，而不用重新赋值给一个新的变量接收。\n17.1 列表的常用操作1234567891011121314151617181920212223242526272829303132name_list = [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]# 打印索引下标为1的数据print(name_list[1])# 返回&quot;张三&quot;的索引下标print(name_list.index(&quot;张三&quot;))# 统计&quot;王五&quot;出现的次数print(name_list.count(&quot;王五&quot;))# 列表长度print(len(name_list))# &quot;张三&quot;在列表则返回true，否则falseprint(&quot;张三&quot; in name_list)# &quot;张三&quot;不在列表则返回true,否则falseprint(&quot;张三&quot; not in name_list)# reverse() 逆置lis1.reverse()print(lis1)# sort() 排序,默认升序# lis1.sort()lis1.sort(reverse=True)print(lis1)# copy() 列表复制list2 = lis1.copy()print(list2)\n\n\n\n17.2 列表的增删改查操作123456789101112131415161718192021222324252627282930313233343536name_list = [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]# 列表增加操作# 注意：# 1 如果列表用append()追加的是一个序列，则追加整个序列到列表最后。# 2 如果用extend()追加，则是将这个序列的数据逐⼀添加到列表最后# 3 列表追加元素可以是重复元素name_list.append(&quot;赵六&quot;)name_list.append((11,22))name_list.extend(&quot;abcde&quot;)# 4 insert()指定位置增加元素name_list.insert(0,&quot;指定位置增加元素&quot;)print(name_list)# 列表删除操作# 1 del()删除指定下标元素del(name_list[0])print(name_list)# 2 pop()如果不指定下标，默认弹出最后一个元素,需要一个变量来接收pao_name=name_list.pop(1)print(name_list)# 3 remove(数据)name_list.remove(&quot;王五&quot;)# 4 clear() 清空列表name_list.clear()print(name_list)# 列表修改操作name_list[0]=&quot;aaa&quot;print(name_list)# 列表查找操作print(name_list[0])\n\n17.3 随机分配老师到办公室问题123456789101112131415161718192021# 问题描述：&quot;&quot;&quot;8位老师分别叫&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;3个办公室将8位老师随机分配到3个办公室&quot;&quot;&quot;import randomteachers = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;]offices = [[], [], []]for name in teachers:    num = random.randint(0, 2)    offices[num].append(name)print(offices)i = 1for office in offices:    print(f&quot;办公室&#123;i&#125;的老师有&#123;len(office)&#125;位&quot;)    for tec in office:        print(tec)    i += 1\n\n\n\n18 元祖元祖内的数据是不能修改的，也不能删除某个数据，除非是要删除整个元祖\n！！！但是：如果元祖里面有列表，那么列表里的数据是可以修改的，尽管如此，但是不建议去做\n这里需要说明下：元祖和列表一样其实是可以存储不同类型的数据的，但是建议使用同一种类型数据\n18.1 定义元祖123# 注意：元祖只有一个数据时也必须加，否则就不是元祖类型了t2 = (1,)print(type(t2))\n\n\n\n18.2 元祖的常见操作（主要是查找操作）123456789t3 = (&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)# 查找print(t3[0])# index()：查找某个数据，如果数据存在返回对应的下标，否则报错，语法和列表、字符串的index()相同print(t3.index(&quot;a&quot;))# 统计某个元素的个数print(t3.count(&quot;a&quot;))\n\n\n\n19 字典字典里的数据必须是键值对的形式，可以看成map集合\n符号是大括号{}\n19.1 字典的增删改查操作12345678910111213141516171819202122232425262728dict1 = &#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 18, &quot;address&quot;: &quot;徐州&quot;&#125;# key在字典中不存在就是新增，如果存在就是修改dict1[&quot;id&quot;]=1print(dict1)dict1[&quot;age&quot;]=19print(dict1)# 删除或者清空字典或者删除指定键值对# del dict1# dict1.clear()del dict1[&quot;name&quot;]print(dict1)# 字典数据的查找(和map一样，keys集合，values集合，entry集合这样)keys = dict1.keys()for key in keys:    print(dict1[key])values = dict1.values()for value in values:    print(value)items = dict1.items()for item in items:    print(item)    # 拆包动作for key,value in dict1.items():    print(f&quot;&#123;key&#125;=&#123;value&#125;&quot;)\n\n\n\n20  集合集合里的数据 没有重复的（参照set集合）它会去重。\n集合没有顺序，所以不支持下标的操作\n20.1 集合增删查操作12345678910111213141516171819202122s1 = &#123;12, 22, 322, 42, 5&#125;print(s1)# 集合增加数据# add追加一个元素s1.add(100)# update只能追加序列s1.update([&quot;a&quot;, &quot;b&quot;])print(s1)# 集合删除操作# 删除指定数据，不存在则报错s1.remove(12)# 删除指定数据，不存在也不会报错s1.discard(12)# 随机删除一个数据s1.pop()print(s1)# 集合查找操作print(10 in s1)print(12 not in s1)\n\n\n\n20.2 注意：创建集合可以使用{}或者set()，但是如果只创建空集合则只能使用set()，因为{}会创建空字典\n21 公共操作\n1print(&quot;_&quot;*20)\n\n\n\n\n1234# 公共操作# rnage(),注意：rnage()是左闭右开的，所以不包含结束数字for i in range(1,10,1):    print(i,end=&quot;&quot;)\n\n\n\n22 函数函数都是先定义再调用\n定义格式：\n1234def 函数名():    代码1    代码2    ...\n\n22.1 一些关键函数\nhelp()函数，查看函数说明文档\n未完\n\n22.2 说明文档类似如下代码所示，可以输入多行注释（””” “””），按下回车后会给出说明文档格式的参数注释（比如参数和返回值）\n12345678def sum_num(a,b):    &quot;&quot;&quot;    :param a:参数1    :param b:参数2    :return:返回值    &quot;&quot;&quot;    return a+b\n\n\n\n22.3 函数执行的一些细节（重要）\nglobal可以用来声明一个变量为全局变量，一般都是用来提升作用域之类的，稍微注意下这个声明即可\n\n12345678910111213141516a = 100def testA():    global b # 这里声明b为全局变量（注意上面并未提前声明）    b=300    print(a)def testB():    global a    a = 200    print(a)testA()testB()print(a) # 此时这里打印a可以看到已经变成了200print(b) # 注意看下这里，因为b被声明为了全局变量，所以此处可以打印到b的值\n\n\n\n\n函数返回多个返回值格式：\n\n12345678# 函数返回多个返回值格式：def return_num():    # return 1, 2 #默认是元祖类型    # return [1,2,3,4,5]    return &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:18&#125;result = return_num()print(type(result))\n\n\n\n\n关键字参数顺序问题\n\n如果没有关键参数，则参数值和定义的参数必须一一对应（参数位置也必须一样）\n12345678910# def info(关键字参数1=位置参数1,关键字参数2=位置参数2,...),关键字参数在前，位置参数在后def user_info(name, gender, age):     print(f&quot;&#123;name&#125;的性别是&#123;gender&#125;,年龄为&#123;age&#125;岁&quot;)   user_info(&quot;张三&quot;, &quot;男&quot;, 18) #顺序必须一样user_info(age=11,name=&quot;李四&quot;,gender=&quot;女&quot;) #顺序可以不一样（比如这个age就是关键字参数，11就是位置参数）user_info(&quot;李四&quot;,gender=&quot;男&quot;,age=18) #像这种关键参数和位置参数混合书写的，首先位置参数必须在关键字参数前面，并且位置参数（李四）的顺序必须一样，但是关键字参数之间却不存在先后顺序\n\n\n\n注意！！！\n如果是混合书写，也就是既有关键字参数和位置参数的，也有只是位置参数的，则位置参数必须在关键字参数前面（并且位置参数必须顺序对应），但是关键字参数之间却不存在先后顺序\n\n缺省参数\n\n缺省参数又叫默认参数，注意，调用函数时可不传该默认参数的值（注意：所有位置参数必须出现在默认参数前，包括函数定义和调用）。\n\n\n可变参数\n\n1.包裹位置传递\n1234def user_info(*args):    print(args)user_info(&quot;张三&quot;) #它会根据传进参数的位置合并为⼀个元组(tuple)，args是元组类型，这就是包裹位置传递。\n\n注意：它会根据传进参数的位置合并为⼀个**元组(tuple)**，args是元组类型，这就是包裹位置传递。\n2.包裹关键字传递\n12345# 收集所有关键字参数，返回的是一个字典def user_info2(**kwargs):    print(kwargs)user_info2(name=&quot;张三&quot;, age=18, gender=&quot;男&quot;)\n\n注意：它会收集所有关键字参数，返回的是一个字典，kwargs是字典类型，这就是包裹关键字传递。\n上面的这两种情况又叫做组包过程（就是把零散的数据整合到一起）\n\n拆包\n\n1.拆包元祖\n1234567# 拆包元祖def user_info():    return 1, 2num1, num2 = user_info()print(f&quot;&#123;num1&#125;,&#123;num2&#125;&quot;)\n\n\n\n2.拆包字典\n12345# 拆包字典userInfo = &#123;&quot;name&quot;: &quot;TOM&quot;, &quot;age&quot;: &quot;18&quot;&#125;name, age = userInfoprint(f&quot;&#123;name&#125;,&#123;age&#125;&quot;)print(f&quot;&#123;userInfo[name], userInfo[age]&#125;&quot;)\n\n\n\n\nPython的交换变量方式\n\n123a, b = 1, 2a, b = b, aprint(f&quot;&#123;a&#125;,&#123;b&#125;&quot;)\n\n\n\n22.4 可变和不可变类型\n23 学生管理系统（综合上面所学知识）这个看下代码就行了\n一些注意点：\n\n像这种for后接else的语法\n总结起来比较简单，如果for循环正常结束，else中语句执行。如果是break的，则不执行。\n\n\n12345678for i in info:    if user_name == i[&quot;name&quot;]:        i[&quot;id&quot;] = input(&quot;请输入修改的学号&quot;)        i[&quot;tel&quot;] = input(&quot;请输入要修改的手机号&quot;)        print(&quot;修改成功&quot;)        breakelse:    print(&quot;该学员不存在&quot;)\n\n\n\n24 lambda如果一个函数有一个返回值，并且只有一句代码，可以使用 lambda简化\n1格式：lambda 参数列表 ： 表达式 \n\n\n\n24.1 示例（计算a + b）求和示例\n12345678def l1(a, b):    return a + bprint(l1(1, 2))# 格式：lambda 参数列表 ： 表达式l2 = lambda a, b: a + bprint(l2(1, 2))\n\n\n\n注意：\n\n上面打印的时候是   l2(x,x),  如果使用直接打印l2，那么打印的是地址。\n\n24.2 lambda的参数形式这里注意下对于默认参数，如果传了参数，那么就会覆盖掉默认参数，见下面代码\n12345678910111213141516171819202122# lambda参数l1 = lambda: 100print(l1())# lambda 一个参数l2=lambda a:a*10print(l2(10))# lambda 默认参数(缺省参数)l3 = lambda a, b, c=100: a + b + cprint(l3(1,2))print(l3(1,2,3)) #这里需要说明下如果传了参数，那么就会覆盖掉默认参数# lambda  可变参数(*args)l4 = lambda *args: argsprint(l4(1,2))# lambda  可变参数(**kwargs)l5 = lambda **kwargs: kwargsprint(l5(name=&quot;张三&quot;,age=18))\n\n\n\n24.3 lambda应用—列表数据按字典key的值排序123456789101112students=[    &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:15&#125;,    &#123;&quot;name&quot;:&quot;wangwu&quot;,&quot;age&quot;:17&#125;,    &#123;&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:16&#125;]# 按照name升序排序students.sort(key=lambda x:x[&quot;name&quot;])print(students)# 按照age降序排序students.sort(key=lambda x:x[&quot;age&quot;],reverse=True)print(students)\n\n\n\n24.4 高阶函数1234567891011def sum_num(a, b, f):    return f(a) + f(b)# 绝对值求求和num = sum_num(-1, 2, abs)print(num)# 四舍五入num2 = sum_num(1.1, 2, round)print(num2)\n\n\n\n24.5 内置高阶函数简单说就是把函数功能作用于列表序列\n下面是三个常见的内置高阶函数\n24.5.1 map()123456789lis1 = [1, 2, 3, 4, 5]def fun1(x):\treturn x ** 2iterator = map(fun1, lis1)print(list(iterator))\n\n24.5.2 reduce()这里需要注意下：\nreduce(func(x,y)，lst)          其中func必须有两个参数，每次func计算的结果继续和序列的下一个元素做累积计算。\n12345678910import functoolslis1 = [1, 2, 3, 4, 5] def fun2(a,b):     return a+b#求和 reduce = functools.reduce(fun2, lis1) print(reduce)\n\n\n\n24.5.3 filter()从函数名就知道干什么的了\n123456789lis1 = [1, 2, 3, 4, 5]def fun3(x):    return x%2==0filt = filter(fun3, lis1)print(list(filt))\n\n\n\n\n\n\n\n25 文件操作步骤：\n\n打开文件\n读写等操作\n关闭文件\n\n25.1 打开文件模式\n圈中的几个都可以用于读写，区别看下文件指针的位置移动情况\n25.2 文件对象方法\nwrite()\n\n1对象对象.write(&#x27;内容&#x27;) \n\n注意：\n\nw 和 a 模式：如果文件不存在则创建该文件；如果文件存在， w 模式先清空再写入， a 模式直接末尾追加。\n\nr 模式：如果文件不存在则报错。\n\n\n\nread()\n\n1文件对象.read(num) \n\nnum表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据。\n\nreadlines()\n\n按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表\n\nreadline()\n\n一次读取一行\n\nseek()\n\n用来移动文件指针\n1文件对象.seek(偏移量, 起始位置)\n\n起始位置：\n​\t0：文件开头\n​\t1：当前位置\n​\t2：文件结尾\n1234f = open(&quot;2.txt&quot;, &quot;a+&quot;)  #2.txt中数据为aaaaabbbbbcccccf.seek(3,0)              #从0（开头开始，向右偏移三个单位）print(f.read())          #a+模式，所以可以读写f.close()\n\n\n\n注意：\n如果seek（x，y）中x,y均为0 ，那么可以省略写成一个0\n其余的一些方法看下下面总结的代码就行了\n12345678910111213141516171819import os# os.rename(&quot;4.txt&quot;,&quot;b.txt&quot;)  将4.txt改名为b.txt# os.remove(&quot;b.txt&quot;)          删除b.txt文件# print(os.getcwd())          打印当前文件路径# os.mkdir(&quot;aaa&quot;)             创建文件夹# os.rmdir(&quot;aaa&quot;)              删除文件夹# os.chdir(&quot;aaa&quot;)             chdir(&quot;xxx&quot;)  改变目录路径# f = open(&quot;bbb.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;)  写入中文，避免乱码# f.write(&quot;你好&quot;)# f.close()print(os.listdir(&quot;../day01&quot;))   #获取某个文件夹下的所有文件，返回一个列表                                # (稍微注意下这里涉及到相对和绝对路径的一些注意事项 )\n\n\n\n\n\n25.3 总结案例（批量重命名添加&#x2F;删除）1234567891011121314151617&quot;&quot;&quot;批量重命名添加/删除   字符串&quot;&quot;&quot;import osos.chdir(&quot;aaa&quot;)  # 进入aaa文件夹# print(os.listdir())flag = 1for i in os.listdir():    if flag == 1:        newName = &quot;python_&quot; + i    elif flag == 2:        num = len(&quot;python_&quot;)        newName = i[num:]    os.rename(i, newName)print(os.listdir())\n\n\n\n26 面向对象26.1 几种魔法方法类比Java里的几种方法\n123456789101112131415161718class Washer():    def __init__(self, width, height):  # 这样写就类似于Java的构造方法一样        self.width = width        self.height = height        print(&quot;你好&quot;)    def __str__(self):        return &quot;打印对象不再输出地址值，而是此处_str_()魔法方法的返回值&quot; #--相当于tostring()    # def __del__(self):    #     print(f&quot;&#123;self&#125;对象被删除时自动调用&quot;)    def print_info(self):        print(f&quot;宽度为&#123;self.width&#125;，高度为&#123;self.height&#125;&quot;)w1 = Washer(100, 300)print(w1) #测试__str__(self)魔法方法# del w1    #测试__del__(self)魔法方法   删除时自动调用\n\n\n\n小示例\n12345678910111213141516171819202122232425262728# 烤地瓜class SweetPotato():    def __init__(self):        self.cook_time = 0        self.cook_static = &quot;生的&quot;        self.condiments = []    def cook(self, time):        self.cook_time += time        if 0 &lt;= self.cook_time &lt; 3:            self.cook_static = &quot;生的&quot;        elif 3 &lt;= self.cook_time &lt; 5:            self.cook_static = &quot;半生不熟&quot;        elif 5 &lt;= self.cook_time &lt; 8:            self.cook_static = &quot;熟了&quot;        elif 8 &lt;= self.cook_time &lt; 10:            self.cook_static = &quot;烤糊了&quot;    def add_condiments(self,condiments):        self.condiments.append(condiments)    def __str__(self):        return f&quot;这个地瓜烤了&#123;self.cook_time&#125;小时了，状态为&#123;self.cook_static&#125;,加了调料&#123;self.condiments&#125;&quot;sp = SweetPotato()sp.cook(5)sp.add_condiments(&quot;辣椒面&quot;)print(sp)\n\n\n\n26.2  继承（留意下几个注意点）- \n12345678910111213141516171819202122232425class A(object):    def __init__(self):        self.name = &quot;张三&quot;    def info_print(self):        print(self.name)class B(object):    def __init__(self):        self.name = &quot;李四&quot;        self.age = &quot;11&quot;    def info_print2(self, address):        print(f&quot;&#123;self.name&#125;+&#123;address&#125;&quot;)# 注意：当一个类有多个⽗类的时候，默认使用第一个⽗类的同名属性和方法。# 子类和父类具有同名属性和方法，默认使⽤用子类的同名属性和方法。class C(A, B):    passc = C()c.info_print2(&quot;徐州&quot;)\n\n注意：\n\n当一个类有多个父类的时候，默认使用第一个父类的同名属性和方法。\n\n子类和父类具有同名属性和方法，默认使用子类的同名属性和方法。\n\nsuoer（）\n\n\n1234567891011121314151617181920212223242526272829303132333435363738394041class A(object):    def __init__(self):        self.name = &quot;张三&quot;    def info_print(self):        print(self.name)class B(object):    def __init__(self):        self.name = &quot;李四&quot;    def info_print(self):        print(self.name)class C(A, B):    def __init__(self):        self.name = &quot;王五&quot;    def info_print(self):        super().__init__()        # 还可以用super()这样更方便,遵循_mro_顺序        super().info_print()        # print(self.name)    # 如果在子类中想要去调用父类的同名方法，那么需要先对父类进行如下的初始化，然后如下格式调用    # 还可以用super()这样更方便    # def info_print1(self):    #     A.__init__(self)    #     A.info_print(self)    # 如果在子类中想要去调用父类的同名方法，那么需要先对父类进行如下的初始化，然后如下格式调用    # 还可以用super()这样更方便    # def info_print2(self):    #     B.__init__(self)    #     B.info_print(self)c = C()c.info_print()\n\n\n\n- \n12345678910111213141516171819202122232425class A():    def __init__(self):        self.__name = &quot;张三&quot;    def __str__(self):        return self.__name    def get__name(self):        return self.__name    def set__name(self):        self.__name = &quot;李四&quot;    def info(self):        print(f&quot;&#123;self.__name&#125;&quot;)## class B(A):#     def ina(self):#         print(f&quot;&#123;self.__name&#125;&quot;)a = A()print(a)\n\n\n\n26.3 多态\n稍微看下就ok了，思想都一样\n\n12345678910111213141516class Dog(object):    def work(self):  # ⽗父类提供统⼀一的⽅方法，哪怕是空⽅方法        print(&#x27;指哪打哪...&#x27;)class ArmyDog(Dog):  # 继承Dog类    def work(self):  # ⼦子类重写⽗父类同名⽅方法        print(&#x27;追击敌⼈人...&#x27;)class DrugDog(Dog):    def work(self):        print(&#x27;追查毒品...&#x27;)class Person(object):    def work_with_dog(self, dog):  # 传⼊入不不同的对象，执⾏行行不不同的代码，即不不同的work函数        dog.work()\n\n\n\n\nclassmethod\n\n12345678910class Dog():    __tooth = 10    @classmethod    def get__tooth(cls):        return cls.__tootha = Dog()print(Dog.get__tooth())\n\n\n\n27 异常\n捕获异常并描述信息  except Exception as result: #异常描述信息\n\n12345678try:    print(1 / 0)except Exception as result: #异常描述信息    print(f&quot;有异常&#123;result&#125;&quot;)else:    print(&quot;没有异常&quot;)finally:    print(&quot;finally&quot;)\n\n示例   （注意需要在终端打开测试（ctrl+c终止程序））\n12345678910111213141516import timetry:    f = open(&quot;3.txt&quot;,&quot;r&quot;,encoding=&quot;utf-8&quot;)    try:        while True:            rl = f.readline()            if len(rl) == 0:                break            time.sleep(2)            print(rl)    except:        print(&quot;程序意外终止&quot;)except Exception:    print(&quot;文件不存在&quot;)\n\n\n\n\n自定义异常 （看下代码里我标注的要留意的事项）\n\n12345678910111213141516171819#自定义异常class shortInputException(Exception):   #Exception不要忘记    def __init__(self, length, min_length):        # 用户输入的长度        self.length = length        # 系统要求的最小输入长度        self.min_length = min_length    def __str__(self):        return f&quot;你输入的长度为&#123;self.length&#125;，不能少于&#123;self.min_length&#125;&quot;try:    pwd = input(&quot;请输入密码&quot;)    if len(pwd) &lt; 15:        raise shortInputException(len(pwd), 15)   #抛出自定义的异常except Exception as result:    print(f&quot;&#123;result&#125;&quot;)else:    print(&quot;输入长度符合&quot;)\n\n\n\n28 自定义包和模块28.1 模块\n导入模块\n\n123import 模块名from 模块名 import ⽬目标from 模块名 import *\n\n、\n28.2 包\n导入包\n\n12import 包名.模块名from 包名 import *\n\n\n注意下 __name___是什么，主要是测试时用到，用处不是很大，留意下即可\n\n123456def testA(a, b):    print(a + b)#__name__ 是一个系统变量，在当前文件中值是__main__，若在其他文件中则是该文件名if __name__ ==&quot;__main__&quot;:    testA(1,1)\n\n\n\n\n重点注意 如果我们使用 from 包名 import * 这种方式导入时，“必须，必须，必须”要在init模块设置all列表\n\n123456789# 两种导入方式，第一种建议忘掉😂# import mypackage.my_module1# mypackage.my_module1.testA()# 注意，# 如果我们使用 from 包名 import * 这种方式导入时，“必须，必须，必须”要在init模块设置__all__列表from mypackage import *my_module1.testA()\n\n\n\n29 学生管理系统（面向对象）\nmain.py\n\n12345from manageSystem import *if __name__ == &quot;__main__&quot;:    student_manager = StudentManager()    student_manager.run()\n\n\n\n\nstudent.py\n\n12345678class Student():    def __init__(self, name, gender, tel):        self.name = name        self.gender = gender        self.tel = tel    def __str__(self):        return f&quot;&#123;self.name&#125;,&#123;self.gender&#125;,&#123;self.tel&#125;&quot;\n\n\n\n\nmanageSystem.py\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121from student import *class StudentManager():    def __init__(self):        self.student_list = []    #   功能函数入口    def run(self):        # 加载学生数据        self.load_student()        while True:            self.show_menu()            menu_num = int(input(&quot;请输入功能序号：&quot;))            if menu_num == 1:                self.add_student()            elif menu_num == 2:                self.del_student()            elif menu_num == 3:                self.modify_student()            elif menu_num == 4:                self.search_student()            elif menu_num == 5:                self.show_student()            elif menu_num == 6:                self.save_student()            elif menu_num == 7:                break    # 加载学生信息 studentData.txt    def load_student(self):        try:            f = open(&quot;studentData.txt&quot;, &quot;r&quot;,encoding=&quot;utf-8&quot;)        except:            f = open(&quot;studentData.txt&quot;, &quot;w&quot;,encoding=&quot;utf-8&quot;)        else:            content = f.read()            self.student_list = [Student(i[&quot;name&quot;], i[&quot;gender&quot;], i[&quot;tel&quot;]) for i in eval(content)]            for i in self.student_list:                print(i)        finally:            f.close()    # 显示功能列表    def show_menu(self):        print(&#x27;请选择如下功能-----------------&#x27;)        print(&#x27;1:添加学员&#x27;)        print(&#x27;2:删除学员&#x27;)        print(&#x27;3:修改学员信息&#x27;)        print(&#x27;4:查询学员信息&#x27;)        print(&#x27;5:显示所有学员信息&#x27;)        print(&#x27;6:保存学员信息&#x27;)        print(&#x27;7:退出系统&#x27;)    # 添加    def add_student(self):        s_name = input(&quot;请输入学生姓名&quot;)        s_gender = input(&quot;请输入学生性别&quot;)        s_tel = input(&quot;请输入学生电话&quot;)        s = Student(s_name, s_gender, s_tel)        self.student_list.append(s)        for i in self.student_list:            print(i)    # 删除    def del_student(self):        s_name = input(&quot;请输入学生姓名&quot;)        for i in self.student_list:            if s_name == i.name:                self.student_list.remove(i)                print(&quot;删除成功&quot;)                break        else:            print(&quot;没有该学员&quot;)        for i in self.student_list:            print(i)    # 修改    def modify_student(self):        s_name = input(&quot;请输入要修改信息的学生姓名&quot;)        for i in self.student_list:            if s_name == i.name:                i.name = input(&quot;请输入修改的姓名&quot;)                i.gender = input(&quot;请输入修改的性别&quot;)                i.tel = input(&quot;请输入修改的电话&quot;)                print(i)                break        else:            print(&quot;该学生不存在&quot;)        for i in self.student_list:            print(i)    # 查询    def search_student(self):        s_name = input(&quot;请输入学生姓名&quot;)        for i in self.student_list:            if s_name == i.name:                print(i)                break        else:            print(&quot;没有该学生&quot;)        for i in self.student_list:            print(i)    # 显示学生    def show_student(self):        for i in self.student_list:            print(i)    # 保存到文件    def save_student(self):        f = open(&quot;studentData.txt&quot;, &quot;w&quot;,encoding=&quot;utf-8&quot;)        # 注意这里  对象.__dict__的用法，将内存地址写成字典的形式        new_list = [i.__dict__ for i in self.student_list]        print(new_list)        f.write(str(new_list))        f.close()\n\n\n\n\nstudentData.txt\n\n1[&#123;&#x27;name&#x27;: &#x27;qq&#x27;, &#x27;gender&#x27;: &#x27;qq&#x27;, &#x27;tel&#x27;: &#x27;qq&#x27;&#125;,&#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;gender&#x27;: &#x27;qq&#x27;, &#x27;tel&#x27;: &#x27;qq&#x27;&#125;]\n\n\n\n","slug":"Python","date":"2020-12-03T16:00:00.000Z","categories_index":"","tags_index":"Python","author_index":"Vegetabhl"},{"id":"875445e0a3c9118d4826bac86a89960d","title":"leyou","content":"0 格式1 SpringCloud1.1 Zuul网关1234567891011121314151617server:  port: 10010spring:  application:    name: itcast-zuuleureka:  client:    service-url:      defaultZone: http://localhost:10086/eurekazuul:  routes: #这个路由可以配置多个，想暴露哪个接口直接再配置一个就可以了    itcast-provider1: /providerUser/**   #将符合path规则的一切请求，都代理到 url参数指定的地址,itcast-provider1是服务ID，不能随便瞎起名，这里的意思就是说将符合/providerUser/**这个路径规则的请求路由到itcast-provider1，下面同理。    itcast-consumer1: /consumerUser/**  prefix: /api #路由前缀            # 核心句：我们将符合`path` 规则的一切请求，都代理到 `url`参数指定的地址\n\n\n\n1.2 consumer服务消费方yml 配置文件常见配置\n1234567891011121314151617181920server:  port: 8080spring:  application:    name: itcast-consumer1  # 应用服务实例名称，会在Eureka注册中心中显示eureka:  client:    service-url:      defaultZone: http://localhost:10086/eureka      registry-fetch-interval-seconds: 5  #每5秒拉去一次服务，这里设置小一点一遍尽快获取服务的更新，但是在生产环境下默认是30秒，我们不需要修改。hystrix:  command:    default:      execution:        isolation:          thread:            timeoutInMilliseconds: 6000 # 设置hystrix的超时时间为6000ms,Hystix的默认超时时长为1000msfeign:  hystrix:    enabled: true # 开启Feign的熔断功能,默认这里是关闭的，开启后\n\n\n\n1.3 registry注册中心yml 配置文件常见配置\n1234567891011121314server:  port: 10086spring:  application:    name: itcast-eureka # 应用名称，会在Eureka注册中心中显示eureka:  client:    service-url:      defaultZone: http://localhost:$&#123;server.port&#125;/eureka  #EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址\tregister-with-eureka: false # 注册中心不注册自己    fetch-registry: false # 在这里指的是注册中心本身不去拉去服务  server:    enable-self-preservation: false # 关闭自我保护模式（默认为打开）    eviction-interval-timer-in-ms: 5000 # 扫描失效服务的间隔时间（默认为为60*1000ms）\n\n\n\n1.4 provider服务提供方yml 配置文件常见配置\n1234567891011121314151617181920212223server:  port: 8090spring:  thymeleaf:    cache: false  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/db4?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC    username: root    password: root  application:      name: itcast-provider1 # 应用名称，会在Eureka注册中心中显示mybatis:  type-aliases-package: cn.itcast.pojoeureka:  client:    service-url:      defaultZone: http://localhost:10086/eureka  instance:    lease-renewal-interval-in-seconds: 5 #每5秒一次心跳时间    lease-expiration-duration-in-seconds: 15 #过期时间,超过15秒没有发送心跳就会过期，也就是认为服务宕机了    #每隔5秒发送一次心跳,即续约(rnew)证明自己还活着，超过15秒没有发送则说明死亡，注册中心就会将该实例剔除掉，在生产环境下默认为30,90不要动，但是在开发阶段可以设置的小一些。\n\n\n\n\n\n1.5 注意：​\t这里需要注意下，无论是服务消费方还是服务提供方，他们其实都是一个个的服务，也就是说服务方也可以是消费方，消费方也可以是服务方。\n1.6 熔断服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，形成雪崩效应。\nHystrix为每个依赖服务调用分配一个小的线程池，如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。\n1.6.1 开启熔断由于类上的注解越来越多，于是Spring就提供了一个组合注解：@SpringCloudApplication，相当于下面三个注解\n&#x2F;@SpringBootApplication@EnableDiscoveryClient &#x2F;&#x2F;开启Eureka客户端功能@EnableCircuitBreaker &#x2F;&#x2F;开启熔断&#x2F;\n123456789101112/*@SpringBootApplication@EnableDiscoveryClient //开启Eureka客户端功能@EnableCircuitBreaker //开启熔断*/@SpringCloudApplication//这个组合注解就相当于上面三个public class Consumer1Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Consumer1Application.class, args);    &#125;&#125;\n\n\n\n1.6.2编写降级逻辑（这里可以着重看下一节feign，将其合在一起写了）我们改造itcast-service-consumer，当目标服务的调用出现故障，我们希望快速失败，给用户一个友好提示。因此需要提前编写好失败时的降级处理逻辑，要使用HystixCommond来完成：\n12345678910111213141516171819202122@Controller@RequestMapping(&quot;consumer/user&quot;)@DefaultProperties(defaultFallback = &quot;fallBackMethod&quot;) // 指定一个类的全局熔断方法public class UserController &#123;    @Autowired    private RestTemplate restTemplate;    @GetMapping    @ResponseBody    @HystrixCommand // 标记该方法需要熔断,并且这里没有指定熔断放方法名，所以使用的是全局的熔断方法    public String queryUserById(@RequestParam(&quot;id&quot;) Long id) &#123;        String user = this.restTemplate.getForObject(&quot;http://service-provider/user/&quot; + id, String.class);        return user;    &#125;          \t//全局熔断方法    public String fallBackMethod()&#123;        return &quot;请求繁忙，请稍后再试！&quot;;    &#125;&#125;\n\n\n\n1.6.3 设置超时在之前的案例中，请求在超过1秒后都会返回错误信息，这是因为Hystix的默认超时时长为1，我们可以通过配置修改这个值：\n1234567hystrix:  command:    default:      execution:        isolation:          thread:            timeoutInMilliseconds: 6000 # 设置hystrix的超时时间为6000ms\n\n改造服务提供者\n改造服务提供者的UserController接口，随机休眠一段时间，以触发熔断：\n123456789@GetMapping(&quot;&#123;id&#125;&quot;)public User queryUserById(@PathVariable(&quot;id&quot;) Long id) &#123;    try &#123;        Thread.sleep(6000);    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125;    return this.userService.queryUserById(id);&#125;\n\n\n\n1.7 Feign服务间的内部调用\n1.7.1 开启Feign功能123456789@SpringCloudApplication//这个组合注解就相当于上面三个@EnableFeignClients //开启feign的启动器，有了这个就不需要再使用RestTemplate了，因为它内部已经集成了public class Consumer1Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Consumer1Application.class, args);    &#125;&#125;\n\n\n\n1.7.2 Feign的客户端\n1.7.2.1内容1 Controller\n1234567891011121314151617181920212223@Controller@RequestMapping(&quot;/consumer&quot;)//@DefaultProperties(defaultFallback = &quot;fallbackMethod&quot;)//这里是指定一个全局的熔断方法public class ConsumerController &#123;   @Autowired   private UserClient userClient; //注入feign实例对象    @GetMapping(&quot;/user&quot;)    @ResponseBody    //@HystrixCommand //这里没有指定熔断放方法名，所以使用的是全局的熔断方法    public String findById(@RequestParam(&quot;id&quot;) Long id) &#123;        return userClient.findById(id).toString();    &#125;    /*    //这是一个全局的熔断方法，注意这里的返回值类型    public String fallbackMethod() &#123;        return &quot;服务正在忙，请稍后再试!!!&quot;;    &#125;*/&#125;\n\n2 UserClient 接口\n123456@FeignClient(value = &quot;itcast-provider1&quot;,fallback = UserClientFallback.class)public interface UserClient &#123;    @GetMapping(&quot;/user/findById/&#123;id&#125;&quot;)    public User findById(@PathVariable(&quot;id&quot;) Long id);&#125;\n\n\n\n3 UserClientFallback\n123456789@Componentpublic class UserClientFallback implements UserClient &#123;    @Override    public User findById(Long id) &#123;        User user = new User();        user.setUsername(&quot;别看了,服务器忙着呢！&quot;);        return user;    &#125;&#125;\n\n\n\n1.8 Zuul网关网关的 一些基本配置，如路由配置等在上面1.1节中\n1.8.1 过滤器四种过滤类型：pre,  routing,  post,  error\n\n正常路程： pre-routing-post-response\n异常流程\n1：pre或者routing出错，则直接到error,再到post,然后response结束\n​\t若error也出错，则到post,然后response结束\n​\t\t若post也出错，则就直接response结束了\n2:pre和routing正常，但是post异常，则走error,然后直接response结束，error及时出错不再走post了，否则就成死循环了。\n1.8.2 自定义过滤器\n代码：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Componentpublic class LognFilter extends ZuulFilter &#123;    /**     * 过滤器类型，分为四种：pre,route,post,error，这里使用pre过滤器     * @return     */    @Override    public String filterType() &#123;        return &quot;pre&quot;;    &#125;    /**     *过滤器的优先级，返回值越小，优先级越高，这里不设置为0，因为后续可能会设置多个过滤器     * @return     */    @Override    public int filterOrder() &#123;        return 10;    &#125;    /**     * 是否执行该过滤器     * 返回值为true:执行run方法     * 返回值为false:不执行run方法     * @return     */    @Override    public boolean shouldFilter() &#123;        return true;    &#125;    /**     * 编写过滤器业务逻辑     * @return     * @throws ZuulException     */    @Override    public Object run() throws ZuulException &#123;        //初始化contex上下文对象        RequestContext context = RequestContext.getCurrentContext();//注意是com.netflix.zuul.context包下  ;        //获取request对象        HttpServletRequest request = context.getRequest();        //获取参数        String token = request.getParameter(&quot;token&quot;);        if(StringUtils.isBlank(token))&#123;            //拦截            context.setSendZuulResponse(false);            //设置响应状态码，401身份未认证            context.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED);            //设置响应提示            context.setResponseBody(&quot;request error!&quot;);        &#125;        return null;    &#125;&#125;\n\n1.9 vue-router1.9.1 路由vue-router示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;span&gt; &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;&lt;/span&gt;        &lt;span&gt;&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;&lt;/span&gt;        &lt;hr&gt;          &lt;!--这个是一个锚点--&gt;        &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;../node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../node_modules/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/loginForm.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/registForm.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    const router=new VueRouter(&#123;        //这里定义了一些路由的规则       routes:[           &#123;               path:&quot;/login&quot;,               component:loginForm           &#125;,           &#123;               path:&quot;/register&quot;,               component:registerForm           &#125;       ]    &#125;);    const vm=new Vue(&#123;        el:&quot;#app&quot;,        data:&#123;                    &#125;,                router // 引用上面定义的router对象    &#125;)&lt;/script&gt;&lt;/html&gt;\n\n\n\n2.0 nginx解决端口问题2.0.1 nginx作为反向代理首先先看下什么是正向代理\n正向代理: \n反向代理不好理解，正向代理大家总有用过，翻墙工具其实就是一个正向代理工具。它会把 们访问墙外服务器server的网页请求，代理到一个可以访问该网站的代理服务器proxy，这个代理服务器proxy把墙外服务器server上的网页内容获取，再转发给客户。具体的流程如下图。\n概括说：就是客户端和代理服务器可以直接互相访问，属于一个LAN（局域网）；代理对用户是非透明的，即用户需要自己操作或者感知得到自己的请求被发送到代理服务器；代理服务器通过代理用户端的请求来向域外服务器请求响应内容。\n反向代理：\n在反向代理中（事实上，这种情况基本发生在所有的大型网站的页面请求中），客户端发送的请求，想要访问server服务器上的内容。但将被发送到一个代理服务器proxy，这个代理服务器将把请求代理到和自己属于同一个LAN下的内部服务器上，而用户真正想获得的内容就储存在这些内部服务器上。看到区别了吗，这里proxy服务器代理的并不是客户，而是服务器，即向外部客户端提供了一个统一的代理入口，客户端的请求，都先经过这个proxy服务器，至于在内网真正访问哪台服务器内容，由这个proxy去控制。一般代理是指代理客户端，而这里代理的对象是服务器，这就是“反向”这个词的意思。Nginx就是来充当这个proxy的作用。 概括说：就是代理服务器和真正server服务器可以直接互相访问，属于一个LAN（服务器内网）；代理对用户是透明的，即无感知。不论加不加这个反向代理，用户都是通过相同的请求进行的，且不需要任何额外的操作；代理服务器通过代理内部服务器接受域外客户端的请求，并将请求发送到对应的内部服务器上。\n2.0.2 nginx启动nginx可以通过命令行来启动，操作命令：\n\n启动：start nginx\n停止：nginx -s stop\n重新加载：nginx -s reload   （每次更改配置文件后都需要重新加载下）\n\n启动过程会闪烁一下，启动成功后，任务管理器中会有两个nginx进程：\n\n2.0.3 请求流程\n浏览器准备发起请求，访问http://mamage.leyou.com，但需要进行域名解析\n\n优先进行本地域名解析，因为我们修改了hosts，所以解析成功，得到地址：127.0.0.1\n\n请求被发往解析得到的ip，并且默认使用80端口：http://127.0.0.1:80\n本机的nginx一直监听80端口，因此捕获这个请求\n\nnginx中配置了反向代理规则，将manage.leyou.com代理到127.0.0.1:9001，因此请求被转发\n\n后台系统的webpack server监听的端口是9001，得到请求并处理，完成后将响应返回到nginx\n\nnginx将得到的结果返回到浏览器\n\n\n2.0.4 注意注意：\n​\t这里的nginx监听80端口是在本机，即本机的nginx一直监听80端口，捕获我们发送的请求\n  后台系统的webpack server监听的端口是9001，得到请求并处理，完成后将响应返回到nginx\n2.1 项目启动2.1.1 后台管理前端\n在package.json文件中有scripts启动脚本配置，可以输入命令：npm run dev或者npm start\n\n发现默认的端口是9001。访问：http://localhost:9001\n","slug":"乐优商城","date":"2020-12-03T16:00:00.000Z","categories_index":"","tags_index":"Java","author_index":"Vegetabhl"}]